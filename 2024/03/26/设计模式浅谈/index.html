<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>设计模式浅谈 | easycodesniper | blog by chen qiyi</title>

  
  <meta name="author" content="chen qiyi">
  

  
  <meta name="description" content="多态多态的含义是：同一操作作用于不同对象上，可以产生不同的解释和不同的执行结果。也就是说，给不同的对象发送同一个消息，对象会做出不同的反馈
下面的代码就体现着多态性，当我们分别向程序员和老师发出工作的消息时，他们根据此作出了不同的反应
1234567891011121314let work = fu">
  

  
  
  <meta name="keywords" content="设计模式">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="设计模式浅谈"/>

  <meta property="og:site_name" content="easycodesniper"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="easycodesniper" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">easycodesniper</a>
    </h1>
    <p class="site-description">blog by chen qiyi</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/about">关于</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>设计模式浅谈</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/03/26/设计模式浅谈/" rel="bookmark">
        <time class="entry-date published" datetime="2024-03-26T13:01:25.000Z">
          2024-03-26
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态的含义是：同一操作作用于不同对象上，可以产生不同的解释和不同的执行结果。也就是说，给不同的对象发送同一个消息，对象会做出不同的反馈</p>
<p>下面的代码就体现着多态性，当我们分别向程序员和老师发出工作的消息时，他们根据此作出了不同的反应</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> work = <span class="keyword">function</span> (<span class="params">person</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(person <span class="keyword">instanceof</span> <span class="title class_">Coder</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;coding&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (person <span class="keyword">instanceof</span> <span class="title class_">Teacher</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;teaching&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Coder</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Teacher</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">work</span>(<span class="keyword">new</span> <span class="title class_">Coder</span>()) <span class="comment">// coding</span></span><br><span class="line"><span class="title function_">work</span>(<span class="keyword">new</span> <span class="title class_">Teacher</span>()) <span class="comment">// teaching</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但这样的多态性无法令人满意，如果现在要新增一个司机类型，那我们就需要修改work函数的代码。修改的代码越多，就存在越多的危险，并且work函数也会随着类型的变多成为一个巨大的函数</p>
<p>多态背后的思想是：将<strong>做什么</strong>与<strong>谁去做怎么做</strong>分离开来。<br>在上面的例子中，人都会工作，但是不同的人怎么工作是不同的。把不变的部分隔离出来，把可变的部分封装起来，这就给予了我们扩展程序的能力。</p>
<p>通过下面的改动，将不变的部分隔离出来，那就是所有人都会工作。然后把可变的部分各自封装起来</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> work = <span class="keyword">function</span> (<span class="params">person</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(person.<span class="property">work</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span>) &#123;</span><br><span class="line">    person.<span class="title function_">work</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Coder</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">Coder</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">work</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;coding&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Teacher</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">Teacher</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">work</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;teaching&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">work</span>(<span class="keyword">new</span> <span class="title class_">Coder</span>())</span><br><span class="line"><span class="title function_">work</span>(<span class="keyword">new</span> <span class="title class_">Teacher</span>())</span><br></pre></td></tr></table></figure>

<p>与静态语言类型不同的是，JavaScript的变量类型在运行期是可变的。一个JavaScript对象，既可以是<code>Coder</code>类型，也可以是<code>Teacher</code>类型。这就意味着<strong>JavaScript对象的多态性是与生俱来的</strong></p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装的目的是将信息隐藏，封装可以是<strong>对任何形式内容的封装</strong>。也就是说，封装不仅仅是隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型等</p>
<p>封装使得对象内部的变化对其他对象而言是透明的，其他对象也不关心它的内部实现。</p>
<p><strong>封装变化</strong></p>
<p>通过封装变化的方式，把系统中稳定不变的部分和易于变化的部分隔离开来，我们只需要替换易于变化的部分。这可以很大程度上保证程序的稳定性和可扩展性</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>在以类为中心的面向对象编程语言中，对象总是从类中创建出来的。而在原型编程的思想中，类不是必须的，对象也未必需要从类中创建出来。一个对象是通过克隆另一个对象所得到的。</p>
<p>原型模式的关键在于<strong>通过克隆来创建对象</strong>，即语言本身是否提供了clone方法。在ES5中提供了<code>Object.create</code>方法来克隆对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;easy code sniper&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clonePerson = <span class="title class_">Object</span>.<span class="title function_">create</span>( person )</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(clonePerson) <span class="comment">// &#123; name: &#x27;easy code sniper&#x27;, age: 22 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="JavaScript中的原型继承"><a href="#JavaScript中的原型继承" class="headerlink" title="JavaScript中的原型继承"></a>JavaScript中的原型继承</h3><p>JavaScript遵循原型编程的基本规则：</p>
<ul>
<li>所有的数据都是对象</li>
<li>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它</li>
<li>对象会记住它的原型</li>
<li>如果对象无法响应某个请求，它会把这个请求委托给自己的原型</li>
</ul>
<p><strong>1.所有的数据都是对象</strong></p>
<p>JavaScript有两种类型机制：基本类型 和 对象类型</p>
<p>基于一切都应该是对象的本意（除了undefined之外），基本类型数据可以通过包装类的方式变成对象类型数据</p>
<p>JavaScript中的根对象是<code>Object.prototype</code>对象，<code>Object.prototype</code>对象是一个空的对象。在JS中遇到的每个对象，实际都是从<code>Object.prototype</code>对象克隆而来的</p>
<p><strong>2.要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它</strong></p>
<p>在JavaScript中我们不需要关心克隆的细节，只是显式地调用<code>let obj = new Object()</code>或<code>let obj = &#123;&#125;</code>，引擎内部会从<code>Object.prototype</code>上面克隆一个对象出来</p>
<p>JavaScript的函数集可以作为普通函数被调用，也可以作为构造器被调用。当使用<code>new</code>运算符来调用函数时，此时的函数就是一个构造器。用<code>new</code>运算符来创建对象的过程，实际上也只是先克隆<code>Object.prototype</code>对象，再进行一些其他额外操作的过程</p>
<p>模拟<code>new</code>创建对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> objectFactory = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>() <span class="comment">// 先克隆一个空对象</span></span><br><span class="line">    <span class="title class_">Constructor</span> = [].<span class="property">shift</span>.<span class="title function_">call</span>( <span class="variable language_">arguments</span> ) <span class="comment">// 取出参数中的第一项，即外部传入的构造器</span></span><br><span class="line">    obj.<span class="property">__proto__</span> = <span class="title class_">Constructor</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// 指向正常的原型</span></span><br><span class="line">    <span class="keyword">let</span> ret = <span class="title class_">Constructor</span>.<span class="title function_">apply</span>(obj, <span class="variable language_">arguments</span>) <span class="comment">// 基于剩余的arguments给obj设置属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">&#x27;object&#x27;</span> ? ret : obj <span class="comment">// 确保构造器总是返回一个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="title function_">objectFactory</span>(<span class="title class_">Person</span>, <span class="string">&#x27;easy code sniper&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a.<span class="property">name</span> ); <span class="comment">// easy code sniper</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a.<span class="title function_">getName</span>() ); <span class="comment">// easy code sniper</span></span><br></pre></td></tr></table></figure>

<p><strong>3.对象会记住它的原型</strong></p>
<p>JavaScript给对象提供一个<code>__proto__</code>属性，某个对象的<code>__proto__</code>属性默认会指向它的构造器的原型对象，即<code>Constructor.prototype</code></p>
<p><code>__proto__</code>就是 对象 和 对象构造器的原型 联系起来的纽带。这就是我们在<code>objectFactory</code>函数中需要手动给obj对象设置正确的<code>__proto__</code>指向</p>
<h2 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h2><p>this 的指向大致可以分为 4 种情况：</p>
<ul>
<li>作为对象的方法调用</li>
<li>作为普通函数调用</li>
<li>构造器调用</li>
<li><code>call</code> 和 <code>apply</code> 调用</li>
</ul>
<h3 id="作为对象的方法调用"><a href="#作为对象的方法调用" class="headerlink" title="作为对象的方法调用"></a>作为对象的方法调用</h3><p>当函数作为对象的方法被调用时，this 指向该对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;easy code sniper&quot;</span>,</span><br><span class="line">  <span class="attr">getName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === obj); <span class="comment">// true</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// easy code sniper</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">getName</span>();</span><br></pre></td></tr></table></figure>

<h3 id="作为普通函数调用"><a href="#作为普通函数调用" class="headerlink" title="作为普通函数调用"></a>作为普通函数调用</h3><p>当函数作为普通函数被调用时，this 指向全局对象。在浏览器中，全局对象就是 window；在 Node 环境中，全局对象就是 globalThis</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">globalThis.<span class="property">name</span> = <span class="string">&quot;easy code sniper&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>(); <span class="comment">// easy code sniper</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line">globalThis.<span class="property">name</span> = <span class="string">&quot;cqy&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;easy code sniper&quot;</span>,</span><br><span class="line">  <span class="attr">getName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === obj); <span class="comment">// false</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// cqy</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func = obj.<span class="property">getName</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>();</span><br></pre></td></tr></table></figure>

<h3 id="构造器调用"><a href="#构造器调用" class="headerlink" title="构造器调用"></a>构造器调用</h3><p>除了一些内置函数，大部分 JS 函数都可以当作构造器使用。当使用 new 运算符调用函数时，该函数总是返回一个对象，通常情况下，构造器里的 this 就<strong>指向返回的对象</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Func</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;easy code sniper&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Func</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// easy code sniper</span></span><br></pre></td></tr></table></figure>

<p>如果构造器显式的返回一个对象，那么返回的将会是这个对象，this也会指向这个对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Func</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;easy code sniper&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;cqy&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Func</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// cqy</span></span><br></pre></td></tr></table></figure>


<h2 id="call-和-apply"><a href="#call-和-apply" class="headerlink" title="call 和 apply"></a>call 和 apply</h2><p><code>Function.prototype.call</code>和<code>Function.prototype.apply</code>是定义在Function的原型上的两个方法，用于动态的改变this指向</p>
<p>call和apply的作用一模一样，区别仅在于传入参数的形式不同：</p>
<ul>
<li>apply接受两个参数，第一个参数指定函数体内this的指向，第二个参数会作为参数传递给被调用的函数，类型为数组或类数组</li>
<li>call传入参数数量不固定，第一个参数指定函数体内this的指向，从第二个参数开始往后，每个参数被依次传入函数</li>
</ul>
<p>当使用call或者apply的时候，如果传入的第一个参数为null，函数体内的this会指向默认的宿主对象，在浏览器中则是window</p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p><strong>1.改变this指向</strong></p>
<p>call和apply最常见的用途是改变函数内部的this指向</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;easy code sniper&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;cqy&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getName = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getName</span>() <span class="comment">// window</span></span><br><span class="line">getName.<span class="title function_">call</span>(obj1) <span class="comment">// easy code sniper</span></span><br><span class="line">getName.<span class="title function_">call</span>(obj2) <span class="comment">// cqy</span></span><br></pre></td></tr></table></figure>

<p><strong>2.Function.prototype.bind</strong></p>
<p>大部分高级浏览器都实现了内置的<code>Function.prototype.bind</code>，用来指定函数内部的this指向，即使没有原生的<code>Function.prototype.bind</code>实现，也可以使用call或者apply模拟</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span> <span class="comment">// 保存调用bind的原函数</span></span><br><span class="line">  context = [].<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>) <span class="comment">// 借用数组的shift方法拿到arguments的第一项，即需要指向的this</span></span><br><span class="line">  args = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>) <span class="comment">// 将剩余参数转化为数组</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 指定this为之前传入的context</span></span><br><span class="line">    <span class="comment">// 合并两次传入的参数，作为新函数的参数</span></span><br><span class="line">    <span class="keyword">return</span> self.<span class="title function_">apply</span>(context, [].<span class="property">concat</span>.<span class="title function_">call</span>(args, [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;cqy&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func = <span class="keyword">function</span>(<span class="params">a,b,c,d</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>([a,b,c,d])</span><br><span class="line">&#125;.<span class="title function_">bind</span>(obj, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 输出：cqy [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p><strong>3.借用其他对象的方法</strong></p>
<p>借用方法较为常见的就是：<br>函数的参数列表arguments是一个类数组对象，它并非真正的数组，所以不能像数组一样，进行排序操作或者往集合里添加一个新的元素。我们常常会借用<code>Array.prototype</code>对象上的方法</p>
<p>比如想往arguments中添加一个新的元素，通常借用<code>Array.prototype.push</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure>

<p>在操作arguments的时候，我们经常非常频繁地找<code>Array.prototype</code>对象借用方法。<br>想把arguments转成真正的数组的时候，可以借用<code>Array.prototype.slice</code>方法;想截去arguments列表中的头一个元素时，又可以借用<code>Array.prototype.shift</code>方法。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><strong>变量的作用域</strong></p>
<p>在JS中，函数可以用来创造函数作用域。函数就像一层半透明的玻璃，在函数里面可以看到外面的便利，而在函数外面则无法看到函数里面的变量。</p>
<p>这是因为当在函数中搜索一个变量的时候，如果该函数内并没有声明这个变量，那么此次搜索的过程会随着代码执行环境创建的作用域链往外层逐层搜索，一直搜索到全局对象为止。变量的搜索是<strong>从内到外</strong>的。</p>
<p><strong>变量的生存周期</strong></p>
<p>对于全局变量来说，生存周期是永久的，除非主动销毁这个全局变量</p>
<p>对于函数内的局部变量来说，当退出函数时，这些局部变量就失去了他们价值，随着函数调用的结束而销毁</p>
<p>退出函数后局部变量a将被销毁</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>

<p>再看看下面这段代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    a++</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="title function_">func</span>()</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，退出函数之后，局部变量a并没有消失。当执行<code>let f = func()</code>时，f拿到一个匿名函数的引用，它可以访问到func被调用时产生的环境，而局部变量a一直处在这个环境里。</p>
<p>既然局部变量所在的环境还能被外界访问，这个局部变量就有了不被销毁的理由。在这里产生了一个闭包结构，局部变量的生命看起来被延续了。</p>
<h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><p><strong>封装变量</strong></p>
<p>闭包可以帮助把一些不需要暴露在全局的变量封装成‘私有变量’，例如下面有一个计算参数乘积的简单函数，并使用全局的cache变量缓存结果来提高性能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cache = &#123;&#125; <span class="comment">// 缓存结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mult = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">join</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="string">&#x27;,&#x27;</span>) <span class="comment">// 将参数拼接成字符串，作为cache中的属性名</span></span><br><span class="line">  <span class="keyword">if</span>( cache[args] ) &#123; <span class="comment">// 如果命中缓存就返回结果</span></span><br><span class="line">    <span class="keyword">return</span> cache[args]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++ ) &#123;</span><br><span class="line">    a *= <span class="variable language_">arguments</span>[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cache[args] = a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cache变量仅在mult函数中被使用，与其让他暴露在全局作用域下，不如将它封闭在mult函数内部</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mult = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> cache = &#123;&#125; <span class="comment">// 将cache封装在mult里面</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">join</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="string">&#x27;,&#x27;</span>) <span class="comment">// 将参数拼接成字符串，作为cache中的属性名</span></span><br><span class="line">    <span class="keyword">if</span>( cache[args] ) &#123; <span class="comment">// 如果命中缓存就返回结果</span></span><br><span class="line">      <span class="keyword">return</span> cache[args]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++ ) &#123;</span><br><span class="line">      a *= <span class="variable language_">arguments</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[args] = a</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数是指至少满足下列条件之一的函数：</p>
<ul>
<li>函数可以作为参数被传递</li>
<li>函数可以作为返回值输出</li>
</ul>
<h3 id="函数作为参数传递"><a href="#函数作为参数传递" class="headerlink" title="函数作为参数传递"></a>函数作为参数传递</h3><p>将函数作为参数进行传递，一个很重要的应用场景就是回调函数。这代表我们将容易变化的业务逻辑抽离出来，把这部分业务逻辑放在函数参数中，这样一来可以分离业务代码中变化与不变的部分</p>
<p>比如我们想在页面中创建一个div节点，然后给这个节点设置一些样式，下面是一种编写代码的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> appendDiv = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">  div.<span class="property">innerHTML</span> = <span class="string">&#x27;我是一个div&#x27;</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div)</span><br><span class="line">  div.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span> <span class="comment">// 设置样式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把<code>div.style.display = &#39;none&#39;</code>的逻辑硬编码在appendDiv里显然不太合理，这使得appendDiv有点太个性化里，成为了一个难以敷用的函数。</p>
<p>如果把<code>div.style.display = &#39;none&#39;</code>的逻辑抽离出来，用回调函数的形式传入appendDiv，这样appendDiv只要专注于创建节点就行了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> appendDiv = <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">  div.<span class="property">innerHTML</span> = <span class="string">&#x27;我是一个div&#x27;</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div)</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>)   &#123;</span><br><span class="line">    <span class="title function_">callback</span>(div)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">appendDiv</span>(<span class="keyword">function</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  node.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>除此之外，<code>Array.prototype.sort</code>方法接受一个函数作为参数，这个函数里面封装了数组元素的排序规则。排序规则是可变的，把可变的封装在函数参数里。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>].<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1, 3, 5</span></span><br></pre></td></tr></table></figure>

<h3 id="函数作为返回值输出"><a href="#函数作为返回值输出" class="headerlink" title="函数作为返回值输出"></a>函数作为返回值输出</h3><p>让函数返回一个可执行的函数，意味着运算过程是可延续的，更能体现函数式编程的巧妙</p>
<p><strong>1.判断数据的类型</strong></p>
<p>要判断数据类型，更好的方法是用<code>Object.prototype.toString</code>来计算，<code>Object.prototype.toString.call(obj)</code>返回一个字符串</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isString = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object String]&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isArray = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object Array]&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isNumber = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object Number]&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isObject = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object Object]&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些函数的发部分实现都是相同的，不同的是判断部分。为了避免多余的代码，我们可以把这些代表数据类型的字符串作为参数提前传入<code>isType</code>函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isType = <span class="keyword">function</span>(<span class="params">type</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isString = <span class="title function_">isType</span>(<span class="string">&#x27;String&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> isArray = <span class="title function_">isType</span>(<span class="string">&#x27;Array&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> isNumber = <span class="title function_">isType</span>(<span class="string">&#x27;Number&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> isObject = <span class="title function_">isType</span>(<span class="string">&#x27;Object&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="高阶函数的其他应用"><a href="#高阶函数的其他应用" class="headerlink" title="高阶函数的其他应用"></a>高阶函数的其他应用</h3><p><strong>1.函数柯里化（currying）</strong></p>
<p>一个currying的函数首先会接受一些参数，接受了这些参数后，该函数不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数真正需要求值的时候，之前传入的所有参数都会被一次性用于求值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于将函数进行柯里化</span></span><br><span class="line"><span class="comment"> * 接受一个参数：即将要被currying的函数 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> currying = <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [].<span class="property">push</span>.<span class="title function_">apply</span>(args, <span class="variable language_">arguments</span>)</span><br><span class="line">        <span class="comment">// arguments.callee 是一个在函数内部可用的属性，它指向当前正在执行的函数。这在匿名函数中特别有用，因为它允许你引用函数本身，而不需要知道函数的名字。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">arguments</span>.<span class="property">callee</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      res += <span class="variable language_">arguments</span>[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将sum函数进行柯里化</span></span><br><span class="line"><span class="keyword">let</span> curryingSum = <span class="title function_">currying</span>(sum)</span><br><span class="line"></span><br><span class="line"><span class="title function_">curryingSum</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">curryingSum</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">curryingSum</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curryingSum</span>()); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p><strong>2.函数节流</strong></p>
<p>函数有可能被非常频繁地调用，而造成大的性能问题。函数节流的原理：将即将要被执行的函数用setTimeout延迟一段时间执行。如果该次延迟执行还没有完成，则忽略接下来调用该函数的请求</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流函数</span></span><br><span class="line"><span class="comment"> * fn：需要被延迟执行的函数</span></span><br><span class="line"><span class="comment"> * interval：延迟执行的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> throttle = <span class="keyword">function</span>(<span class="params">fn, interval</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> _self = fn <span class="comment">// 保存被延迟执行的函数引用</span></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span> <span class="comment">// 定时器</span></span><br><span class="line">  <span class="keyword">let</span> firstTime = <span class="literal">true</span> <span class="comment">// 是否是第一次调用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="variable language_">arguments</span></span><br><span class="line">    <span class="keyword">let</span> _me = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(firstTime) &#123; <span class="comment">// 如果是第一次调用，不需要延迟执行</span></span><br><span class="line">      _self.<span class="title function_">apply</span>(_me, args)</span><br><span class="line">      <span class="keyword">return</span> firstTime = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(timer) &#123; <span class="comment">// 前一次延迟执行还没有完成，忽略此次请求</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 延迟一段时间执行</span></span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">      timer = <span class="literal">null</span></span><br><span class="line">      _self.<span class="title function_">apply</span>(_me, args)</span><br><span class="line">    &#125;, interval || <span class="number">500</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例：监听浏览器尺寸变化</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onresize</span> = <span class="title function_">throttle</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br></pre></td></tr></table></figure>

<p><strong>3.分时函数</strong></p>
<p>某些函数是用户主动调用的，但因为一些客观原因，这些函数会严重影响页面性能</p>
<p>例如我们要在页面上渲染1000个div节点，在短时间内往页面中大量添加DOM节点会导致浏览器卡顿甚至假死</p>
<p>解决方案之一就是将创建节点的工作分批进行。比如把1秒创建1000个节点，改为每隔200毫秒创建8个节点</p>
<p>设计一个<code>timeChunk</code>函数来分批创建节点，函数接受3个参数：</p>
<ul>
<li>ary：创建节点时需要用到的原始数据</li>
<li>fn：封装了创建节点逻辑的函数</li>
<li>count：每一批创建的节点数量</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timeChunk = <span class="keyword">function</span>(<span class="params">ary, fn, count</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> obj, timer</span><br><span class="line">  <span class="keyword">let</span> len = ary.<span class="property">length</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> start = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="title class_">Math</span>.<span class="title function_">min</span>(count || <span class="number">1</span>, len); i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> item = ary.<span class="title function_">shift</span>()</span><br><span class="line">      <span class="title function_">fn</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    timer = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(len === <span class="number">0</span>) &#123; <span class="comment">// 如果全部节点都创建好了，取消定时器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">start</span>()</span><br><span class="line">    &#125;, <span class="number">200</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ary = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  ary.<span class="title function_">push</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> renderList = <span class="title function_">timeChunk</span>(ary, <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">  div.<span class="property">innerHTML</span> = n</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div)</span><br><span class="line">&#125;, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">renderList</span>()</span><br></pre></td></tr></table></figure>


      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/设计模式/">设计模式</a>
    </span>
    

    </div>

    
  </div>
</article>

  









    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2024 chen qiyi
    
  </p>
</footer>
    
    
  </div>
</div>
<script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>
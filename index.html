<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>easycodesniper | blog by chen qiyi</title>

  
  <meta name="author" content="chen qiyi">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="easycodesniper"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="easycodesniper" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">easycodesniper</a>
    </h1>
    <p class="site-description">blog by chen qiyi</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/about">关于</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2024/04/12/读JS红宝书/"><span>读JS红宝书</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/04/12/读JS红宝书/" rel="bookmark">
        <time class="entry-date published" datetime="2024-04-12T12:55:53.000Z">
          2024-04-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="for-in-和-for-of"><a href="#for-in-和-for-of" class="headerlink" title="for-in 和 for-of"></a>for-in 和 for-of</h2><h3 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h3><p>for-in语句用于枚举对象中的非符号键属性，for-in语句<strong>不能保证返回对象属性的顺序</strong></p>
<p><strong>语法：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">const</span> key <span class="keyword">in</span> obj ) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用示例：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;cqy&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">11</span>,</span><br><span class="line">    <span class="attr">hobby</span>: [<span class="string">&#x27;play&#x27;</span>, <span class="string">&#x27;code&#x27;</span>, <span class="string">&#x27;sleep&#x27;</span>],</span><br><span class="line">    <span class="attr">family</span>: &#123;</span><br><span class="line">        <span class="attr">mom</span>: <span class="string">&#x27;mother&#x27;</span>,</span><br><span class="line">        <span class="attr">father</span>: <span class="string">&#x27;father&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">isMale</span>: <span class="literal">true</span>,</span><br><span class="line">    [<span class="title class_">Symbol</span>()]: <span class="string">&#x27;tag&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">const</span> key <span class="keyword">in</span> obj ) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( key );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// name</span></span><br><span class="line"><span class="comment">// age</span></span><br><span class="line"><span class="comment">// hobby</span></span><br><span class="line"><span class="comment">// family</span></span><br><span class="line"><span class="comment">// isMale</span></span><br></pre></td></tr></table></figure>

<h3 id="for-of"><a href="#for-of" class="headerlink" title="for-of"></a>for-of</h3><p>for-of语句用于遍历<strong>可迭代对象</strong>的属性，会按照可迭代对象的<code>next()</code>方法产生值的顺序迭代元素</p>
<p><strong>语法：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">const</span> key <span class="keyword">of</span> iterator ) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用示例：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">const</span> el <span class="keyword">of</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] ) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(el)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="执行上下文与作用域"><a href="#执行上下文与作用域" class="headerlink" title="执行上下文与作用域"></a>执行上下文与作用域</h2><p>变量或函数的上下文决定了它们可以访问哪些数据，每个上下文都有一个关联的<strong>变量对象</strong>，这个上下文中定义的所有变量和函数都存在于这个对象上。</p>
<p>上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数。</p>
<p><strong>上下文栈：</strong><br>每个函数调用都有自己的上下文。当代码执行流进入函数，函数的上下文被推到一个上下文栈上。在函数执行完后，上下文栈会弹出该函数上下文，将控制权还给之前的执行上下文。</p>
<p><strong>作用域链：</strong><br>上下文中的代码在执行时，会创建 变量对象 的一个 作用域链。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。</p>
<p>正在执行的上下文的 变量对象 始终位于作用域链的<strong>最前端（即最先被访问）</strong></p>
<p>代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索从作用域链的最前端开始，逐级往后，直到找到标识符。</p>
<h2 id="原始值包装类型"><a href="#原始值包装类型" class="headerlink" title="原始值包装类型"></a>原始值包装类型</h2><p>为了方便操作原始值，ES提供了3种特殊的引用类型：<code>Boolean</code>、<code>Number</code>、<code>String</code></p>
<p>每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;easy code sniper&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = name.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// [ &#x27;easy&#x27;, &#x27;code&#x27;, &#x27;sniper&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>在这里 name 是一个字符串类型的变量，是一个原始值。但却可以调用<code>split</code>方法。原始值本身不是对象，因此逻辑上不应该有方法。</p>
<p>name原始值能够调用<code>split</code>方法，是后台进行了许多处理。在以读模式（读取变量保存的值）访问字符串值的任何时候：</p>
<ul>
<li>后台会创建一个String类型的实例</li>
<li>调用实例上的特定方法</li>
<li>销毁实例</li>
</ul>
<p>可以将上述3步想象成执行了如下3行代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;easy code sniper&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> arr = name.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">name = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>这种行为可以让我们在原始值上调用对象的方法。对于布尔值和数值，也是执行以上步骤，只不过使用的是<code>Boolean</code>和<code>Number</code>包装类型而已。</p>
<p>这种自动创建的原始值包装对象只存在于访问它的那行代码执行期间，这意味着不能在运行时给原始值添加属性和方法</p>
<h2 id="Array-from-和-Array-of"><a href="#Array-from-和-Array-of" class="headerlink" title="Array.from 和 Array.of"></a>Array.from 和 Array.of</h2><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h3><p><code>Array.from</code>用于将 类数组结构 转换为 数组。第一个参数是一个类数组对象（任何可迭代的结构），或者有一个length属性和可索引元素的结构</p>
<p>使用场景：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符串会被拆分为单字符数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="string">&#x27;cqy&#x27;</span>)); <span class="comment">// [ &#x27;c&#x27;, &#x27;q&#x27;, &#x27;y&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对现有数组进行浅拷贝</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, &#123; <span class="attr">name</span>: <span class="string">&#x27;cqy&#x27;</span> &#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(arr1)</span><br><span class="line"></span><br><span class="line">arr2[<span class="number">2</span>].<span class="property">name</span> = <span class="string">&#x27;easy code sniper&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">// [ 1, 2, &#123; name: &#x27;easy code sniper&#x27; &#125; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将arguments转化为数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment">// [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<p><code>Array.from()</code>还接受 第二个可选的映射函数参数，新数组的每一项都会调用这个映射函数，并将每一项作为参数传入映射函数。<br>还可以接受 第三个可选参数 ，用于指定映射函数中this的值（<strong>箭头函数中不适用</strong>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="title class_">Array</span>.<span class="title function_">from</span>(arr, <span class="keyword">function</span>(<span class="params">x</span>) &#123; <span class="keyword">return</span> x * <span class="variable language_">this</span>.<span class="property">num</span> &#125;, &#123; <span class="attr">num</span>: <span class="number">2</span> &#125;) <span class="comment">// [ 2, 4, 6, 8 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of"></a>Array.of</h3><p><code>Array.of</code>用于将一组参数转换为数组实例</p>
<h2 id="数组迭代方法"><a href="#数组迭代方法" class="headerlink" title="数组迭代方法"></a>数组迭代方法</h2><p>ES为数组定义了5个迭代方法。每个方法接收两个参数：</p>
<ul>
<li>以每一项为参数运行的函数，该函数接收3个参数：数组元素、索引、数组本身</li>
<li>可选的 作为函数运行上下文的作用域对象（影响函数中的this的值）</li>
</ul>
<p>5个迭代方法如下：</p>
<ul>
<li><code>every</code>：对数组的每一项都运行传入的函数，如果每一项函数都返回true，则这个方法返回true</li>
<li><code>filter</code>：对数组每一项都运行传入的函数，函数返回true的项会组成数组之后返回</li>
<li><code>forEach</code>：对数组每一项都运行传入的函数，没有返回值</li>
<li><code>map</code>：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组</li>
<li><code>some</code>：对数组每一项都运行传入的函数，如果有一项函数返回true，则这个方法返回true</li>
</ul>
<h2 id="数组归并方法"><a href="#数组归并方法" class="headerlink" title="数组归并方法"></a>数组归并方法</h2><p>ES为数组定义了2个归并方法：<code>reduce()</code> 和 <code>reduceRight()</code>。这两个方法都会迭代数组的所有项，并在此基础上构建一个最终返回值。</p>
<p><code>reduce()</code>方法从数组第一项开始遍历到最后一项，而<code>reduceRight()</code>从最后一项开始遍历到第一项</p>
<p>这两个方法都接收两个参数：</p>
<ul>
<li>对每一项都会运行的 归并函数<ul>
<li>归并函数接收4个参数：上一个归并值、当前项、当前项索引、数组本身</li>
<li>归并函数的返回值会作为下一次调用本归并函数的第一个参数（如果没有给这两个方法传入可选的第二个参数(作为归并起点值)，则第一次迭代将从数组的第二项开始，因此传给归并函数的 第一个参数是数组的第一项 ，第二个参数是数组的第二项）</li>
</ul>
</li>
<li>可选的 以之为归并起点的初始值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, current, index, array</span>) =&gt;</span> prev + current)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>循环是迭代机制的基础，它可以指定迭代的次数，以及每次迭代要执行什么操作。</p>
<p>但循环又不适用于所有的数据结构。首先数组可以通过<code>[]</code>操作符取得特定索引位置上的项，这并不适用于所有数据结构；其次通过递增索引来访问数据是特定于数组的方式，并不适用于其他具有隐式顺序的数据结构</p>
<p><code>Array.prototype.forEach</code>方法向通用迭代需求迈进了一步，解决了单独记录索引和通过数组对象取得值的问题。但是无法标识迭代何时终止，且回调结构也比较笨拙</p>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p><strong>迭代器模式</strong>把有些结构称为「可迭代对象（iterable）」，因为它们实现了正式的<code>Iterable</code>接口，而且可以通过迭代器<code>Iterator</code>消费</p>
<p><strong>可迭代对象</strong>是抽象的说法，可以将它理解成数组、集合类型的对象 或者 具有类似数组行为的其他数据结构。它们包含的元素都是有限的，而且都具有无歧义的遍历顺序。</p>
<p><strong>迭代器（iterator）</strong>是按需创建的一次性对象，每个迭代器都会关联一个可迭代对象，并且迭代器会暴露用于迭代 可迭代对象 的API。迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值</p>
<p>可迭代对象必须暴露一个属性作为「默认迭代器」，这个属性使用特殊的<code>Symbol.iterator</code>作为键。这个默认迭代器属性引用一个迭代器工厂函数，调用这个工厂函数返回一个新迭代器</p>
<p>很多内置类型都实现了<code>Iterable</code>接口：</p>
<ul>
<li>字符串</li>
<li>数组</li>
<li>映射</li>
<li>集合</li>
<li>arguments对象</li>
<li>NodeList等DOM集合类型</li>
</ul>
<p>检查是否存在默认迭代器属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有实现迭代器工厂函数</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num[<span class="title class_">Symbol</span>.<span class="property">iterable</span>]) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现了迭代器工厂函数</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;cqy&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// [Function: [Symbol.iterator]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用这个工厂函数会生成一个迭代器</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;cqy&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// Object [String Iterator] &#123;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在实际开发中，不需要显式调用这个工厂函数来生成迭代器，一些原生语言结构会在后台调用可迭代对象的工厂函数</p>
<ul>
<li>for-of循环</li>
<li>数组解构</li>
<li>扩展操作符</li>
<li>Array.from()</li>
<li>创建集合、映射</li>
<li><code>Promise.all()</code>和<code>Promise.race()</code></li>
<li>yield*操作符</li>
</ul>
<p>迭代器API使用<code>next()</code>方法在可迭代对象中遍历数据，每次成功调用<code>next()</code>，都会返回一个<code>IteratorResult</code>对象，其中包括：迭代器返回的下一个值<code>value</code> 和 <code>done</code>状态（<code>done</code>为true 表示「耗尽」，即没有下一个值了）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; value: &#x27;aa&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; value: &#x27;bb&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; value: &#x27;cc&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>每个迭代器都表示对可迭代对象的一次性有序遍历。不同迭代器的实例相互之间没有联系，只会单独的遍历可迭代对象</p>
<h3 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h3><p>任何实现Iterator接口的对象都可以作为迭代器使用，下面的例子中的Counter类只能被迭代一定的次数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">limit</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">limit</span> = limit <span class="comment">// 限制迭代的次数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">count</span> &lt;= <span class="variable language_">this</span>.<span class="property">limit</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">count</span>++ &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; <span class="comment">// 返回实例，实例中定义了next方法用于迭代</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当使用for-of循环counter时，后台会去查找counter身上是否有 [Symbol.iterator]() 工厂函数，并调用它， </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 1  2  3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类实现了Iterator接口，但是它的每个实例只能被迭代一次。第二次迭代没有输出的原因是，第一次迭代已经使<code>count === limit</code>，所以第二次迭代不会返回任何内容</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 1  2  3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);  <span class="comment">// 没有输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要实现可以创建多个迭代器，必须美创建一个迭代器就对应一个新计数器。基于此需求，可以把计数器变量放到闭包中，通过闭包返回迭代器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">limit</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">limit</span> = limit</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">let</span> limit = <span class="variable language_">this</span>.<span class="property">limit</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(count &lt;= limit) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 1  2  3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 1  2  3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>提前终止迭代器</strong></p>
<p>提前终止迭代也是一个常见的需求，for-of循环可以通过break、continue、return或者throw提前退出，在退出时会寻找实现Iterator接口的对象上是否有<code>return()</code>方法。如果对象上有这个方法，在退出时就会调用这个方法</p>
<p><code>return()</code>方法必须返回一个有效的<code>IteratorResult</code>对象，可以只简单的返回<code>&#123; done: true &#125;</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">limit</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">limit</span> = limit</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">let</span> limit = <span class="variable language_">this</span>.<span class="property">limit</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(count &lt;= limit) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>() &#123; <span class="comment">// 自定义提前退出迭代方法</span></span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Exiting iter&#x27;</span>);</span><br><span class="line">              <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// Exiting iter</span></span><br></pre></td></tr></table></figure>

<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器是 ES6 新增的结构，可以让函数拥有在函数块内暂停和恢复代码执行的能力</p>
<p>生成器的形式是一个函数，函数名称前面加一个星号（ * ）表示它是一个生成器，标识生成器函数的星号（ * ）不受两侧空格的影响：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> *<span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generatorFn = <span class="keyword">function</span>* () &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorFn); <span class="comment">// [GeneratorFunction: generatorFn]</span></span><br></pre></td></tr></table></figure>

<p>调用生成器函数会产生一个<strong>生成器对象</strong>，生成器对象一开始处于暂停执行的状态。</p>
<p>生成器对象也实现了Iterator接口，因此具有<code>next()</code>方法，调用这个方法会让生成器开始或恢复执行</p>
<p><code>next()</code>方法的返回值类似于迭代器，有一个<code>done</code>属性和一个<code>value</code>属性。函数体为空的生成器函数中间不会停留，调用一次<code>next()</code>就会让生成器到达<code>done: true</code>状态</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generatorFn</span>()); <span class="comment">// Object [Generator] &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generatorFn</span>().<span class="property">next</span>); <span class="comment">// [Function: next]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generatorFn</span>().<span class="title function_">next</span>()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p><code>value</code>属性是生成器函数的返回值，默认是undefined，可以通过生成器函数的返回值来指定</p>
<p>生成器函数只会在初次调用<code>next()</code>方法后开始执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;easy code sniper&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generatorFn</span>()); <span class="comment">// 不会打印 easy code sniper</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generatorFn</span>().<span class="title function_">next</span>()); <span class="comment">// &#123; value: &#x27;easy code sniper&#x27;, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="yield中断执行"><a href="#yield中断执行" class="headerlink" title="yield中断执行"></a>yield中断执行</h3><p>yield关键字可以让生成器停止和开始执行，也是生成器最有用的地方。生成器函数在遇到 yield 关键字之前会正常执行。遇到这个关键字后，执行会停止，函数作用域的状态会被保留。停止执行的生成器函数只能通过在生成器对象上调用<code>next()</code>方法来恢复执行</p>
<p>yield关键字有点像函数的中间返回语句，它生成的值会出现在<code>next()</code>方法返回的对象中</p>
<p><strong>与 return 的区别：</strong>通过yield关键字退出的生成器函数处于<code>done: false</code>状态；通过return关键字退出的生成器函数处于<code>done: true</code>状态</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;cqy&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;kyrie&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;easy code sniper&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generatorObj = <span class="title function_">generatorFn</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObj.<span class="title function_">next</span>()); <span class="comment">// &#123; value: &#x27;cqy&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObj.<span class="title function_">next</span>()); <span class="comment">// &#123; value: &#x27;kyrie&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObj.<span class="title function_">next</span>()); <span class="comment">// &#123; value: &#x27;easy code sniper&#x27;, done: true &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>显式的调用<code>next()</code>方法用处不大，但是可以在需要自定义迭代对象时，把生成器对象当作可迭代对象使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;cqy&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;kyrie&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;easy code sniper&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">of</span> <span class="title function_">generatorFn</span>()) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cqy</span></span><br><span class="line"><span class="comment">// kyrie</span></span><br><span class="line"><span class="comment">// easy code sniper</span></span><br></pre></td></tr></table></figure>

<h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><p>JS使用一些内部特性来描述对象的属性的特征，对象的属性分两种：数据属性 和 访问器属性</p>
<p><strong>数据属性</strong>包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。数据属性有4个特性描述它们的行为：</p>
<ul>
<li><code>[[Configurable]]</code>：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认是 true</li>
<li><code>[[Enumerable]]</code>：表示属性是否可以通过 for-in 循环返回。默认情况下是 true</li>
<li><code>[[Writable]]</code>：表示属性的值是否可以被修改。默认情况下是 true</li>
<li><code>[[Value]]</code>：属性实际的值。默认是 undefined</li>
</ul>
<p>使用<code>Object.defineProperty()</code>方法可以修改属性的默认特性。</p>
<p>该方法接收3个参数；要给其添加属性的对象、属性名称 和 一个描述符对象（描述符对象上的属性可以包含：configurable、enumerable、writable、value）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 obj 创建一个 name 属性，并配置为不可修改</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;easy code sniper&#x27;</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// easy code sniper</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;cqy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// easy code sniper</span></span><br></pre></td></tr></table></figure>

<p><strong>访问器属性</strong>不包含数据值。它包含一个获取函数（getter）和一个设置函数（setter）。在读取访问器属性时，会调用getter，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用setter函数并传入新值，这个函数必须对数据做出修改</p>
<p>访问器属性有4个特性描述它们的行为：</p>
<ul>
<li><code>[[Configurable]]</code>：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认是 true</li>
<li><code>[[Enumerable]]</code>：表示属性是否可以通过 for-in 循环返回。默认情况下是 true</li>
<li><code>[[Get]]</code>：获取函数</li>
<li><code>[[Set]]</code>：设置函数</li>
</ul>
<p>使用<code>Object.defineProperty()</code>方法可以定义访问器属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 _name 为 伪私有变量，通过 name 属性去访问和设置 _name 属性</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">_name</span>: <span class="string">&#x27;easy code sniper&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_name</span> = newValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// easy code sniper</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;cqy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">//cqy</span></span><br></pre></td></tr></table></figure>

<h2 id="理解原型"><a href="#理解原型" class="headerlink" title="理解原型"></a>理解原型</h2><p><strong>构造函数 和 原型对象</strong></p>
<p>只要创建一个函数，就会按照规则为该函数创建一个<code>prototype</code>属性，该属性指向原型对象</p>
<p>所有的原型对象自动获得一个名为<code>constructor</code>属性，指回与之关联的构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     constructor: f Person(),</span></span><br><span class="line"><span class="comment">//     __proto__: Object</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>); <span class="comment">// f Person()</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>实例 和 原型对象</strong></p>
<p>每次调用构造函数创建一个实例，实例内部的<code>[[Prototype]]</code>就会被赋值为 构造函数的原型对象</p>
<p>实例通过<code>__proto__</code>属性可以访问到构造函数的原型</p>
<p><strong>关键在于理解：</strong>实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">__proto__</span>.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>isPrototypeOf()</code>可以确定两个对象之间的关系。本质上，<code>isPrototypeOf()</code>会在传入参数的<code>[[Prototype]]</code>指向调用它的对象时返回 true</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(person)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Object.getPrototypeOf()</code>方法可以返回参数的内部特性<code>[[Prototype]]</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person) == <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Object.setPrototypeOf(obj, prototype)</code>方法可以向实例的私有特性<code>[[Prototype]]</code>写入一个新值，即重写原型</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Pig</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(person, <span class="title class_">Pig</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person)); <span class="comment">// [Function: Pig]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>in 操作符<br>in 操作符会在可以通过对象访问指定属性时返回 true，无论该属性是在实例上还是在原型上</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;cqy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;name&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/JavaScript/">JavaScript</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/04/09/classnames源码阅读/"><span>classnames源码阅读</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/04/09/classnames源码阅读/" rel="bookmark">
        <time class="entry-date published" datetime="2024-04-09T14:27:15.000Z">
          2024-04-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong><code>classnames</code></strong> 是一个JavaScript工具库，用于 有条件地 将不同的class类名组合在一起</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">classNames</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); <span class="comment">// =&gt; &#x27;foo bar&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">classNames</span>(<span class="string">&#x27;foo&#x27;</span>, &#123; <span class="attr">bar</span>: <span class="literal">true</span> &#125;); <span class="comment">// =&gt; &#x27;foo bar&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">classNames</span>(&#123; <span class="string">&#x27;foo-bar&#x27;</span>: <span class="literal">true</span> &#125;); <span class="comment">// =&gt; &#x27;foo-bar&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">classNames</span>(&#123; <span class="string">&#x27;foo-bar&#x27;</span>: <span class="literal">false</span> &#125;); <span class="comment">// =&gt; &#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">classNames</span>(&#123; <span class="attr">foo</span>: <span class="literal">true</span> &#125;, &#123; <span class="attr">bar</span>: <span class="literal">true</span> &#125;); <span class="comment">// =&gt; &#x27;foo bar&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">classNames</span>(&#123; <span class="attr">foo</span>: <span class="literal">true</span>, <span class="attr">bar</span>: <span class="literal">true</span> &#125;); <span class="comment">// =&gt; &#x27;foo bar&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多种不同类型的参数</span></span><br><span class="line"><span class="title function_">classNames</span>(<span class="string">&#x27;foo&#x27;</span>, &#123; <span class="attr">bar</span>: <span class="literal">true</span>, <span class="attr">duck</span>: <span class="literal">false</span> &#125;, <span class="string">&#x27;baz&#x27;</span>, &#123; <span class="attr">quux</span>: <span class="literal">true</span> &#125;); <span class="comment">// =&gt; &#x27;foo bar baz quux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假值对应的类名都会被忽略</span></span><br><span class="line"><span class="title function_">classNames</span>(<span class="literal">null</span>, <span class="literal">false</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="literal">undefined</span>, <span class="number">0</span>, &#123; <span class="attr">baz</span>: <span class="literal">null</span> &#125;, <span class="string">&#x27;&#x27;</span>); <span class="comment">// =&gt; &#x27;bar&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持动态类名</span></span><br><span class="line"><span class="keyword">let</span> buttonType = <span class="string">&#x27;primary&#x27;</span>;</span><br><span class="line"><span class="title function_">classNames</span>(&#123; [<span class="string">`btn-<span class="subst">$&#123;buttonType&#125;</span>`</span>]: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在React中的使用：将classNames赋值给元素的className属性即可</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;classNames(...)&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取对象的hasOwnProperty方法，该方法用于判断某个属性是否是对象本身的，而不是继承自原型链</span></span><br><span class="line"><span class="keyword">const</span> hasOwn = &#123;&#125;.<span class="property">hasOwnProperty</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">classNames</span> () &#123;</span><br><span class="line">	<span class="keyword">let</span> classes = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">const</span> arg = <span class="variable language_">arguments</span>[i];</span><br><span class="line">		<span class="keyword">if</span> (arg) &#123;</span><br><span class="line">			classes = <span class="title function_">appendClass</span>(classes, <span class="title function_">parseValue</span>(arg));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> classes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">parseValue</span> (arg) &#123;</span><br><span class="line">	<span class="comment">// 如果是字符串，直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> arg === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> arg;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果既不是字符串，也不是对象和数组，就返回空字符串</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果是数组，调用classNames来返回一个组合好的结果字符串</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arg)) &#123;</span><br><span class="line">		<span class="keyword">return</span> classNames.<span class="title function_">apply</span>(<span class="literal">null</span>, arg);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// arg.toString !== Object.prototype.toString 表示arg的toString方法不是继承自Object上</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *   !arg.toString.toString().includes(&#x27;[native code]&#x27;)</span></span><br><span class="line"><span class="comment">	 *   如果arg有toString方法，进一步检查这个方法是否是原生的</span></span><br><span class="line"><span class="comment">	 *   方法是将 arg.toString 方法转换成字符串，然后检查它是否包含字符串 &#x27;[native code]&#x27;。如果一个函数的字符串表示中包含 &#x27;[native code]&#x27;，这通常意味着函数是原生提供的，而不是用户定义的。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (arg.<span class="property">toString</span> !== <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> &amp;&amp; !arg.<span class="property">toString</span>.<span class="title function_">toString</span>().<span class="title function_">includes</span>(<span class="string">&#x27;[native code]&#x27;</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> arg.<span class="title function_">toString</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> classes = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果arg是对象</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> arg) &#123;</span><br><span class="line">		<span class="comment">// hasOwn 判断key是否是arg对象本身的属性，而不是继承自原型链的属性</span></span><br><span class="line">		<span class="comment">// arg[key] 判断key对应的值是否存在，且不为false</span></span><br><span class="line">		<span class="keyword">if</span> (hasOwn.<span class="title function_">call</span>(arg, key) &amp;&amp; arg[key]) &#123;</span><br><span class="line">			classes = <span class="title function_">appendClass</span>(classes, key);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> classes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">appendClass</span> (value, newClass) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!newClass) &#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> value ? (value + <span class="string">&#x27; &#x27;</span> + newClass) : newClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/工具库-CSS/">工具库 CSS</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/03/29/react-use源码阅读/"><span>react-use源码阅读</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/03/29/react-use源码阅读/" rel="bookmark">
        <time class="entry-date published" datetime="2024-03-29T13:07:05.000Z">
          2024-03-29
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>React的开发离不开hooks，在社区中也有各种的hooks工具库。本篇阅读的就是<a target="_blank" rel="noopener" href="https://github.com/streamich/react-use">react-use</a>工具库</p>
<p>希望通过阅读源码，加深自己对于React Hook的理解。</p>
<h2 id="useCustomCompareEffect"><a href="#useCustomCompareEffect" class="headerlink" title="useCustomCompareEffect"></a>useCustomCompareEffect</h2><p>React的<code>useEffect</code>比较依赖项的规则是<code>Object.is()</code>，它大部分情况下和<code>===</code>的效果是相同的<br><code>useCustomCompareEffect</code>Hook 用于当依赖项是对象或者数组时自定义依赖项比较方法，定义更加复杂的比较逻辑</p>
<p>使用示例:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> useCustomCompareEffect <span class="keyword">from</span> <span class="string">&quot;./hooks/useCustomCompareEffect&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [obj, setObj] = <span class="title function_">useState</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;kyrie&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">21</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 自定义比较函数，只有当name值发生变化是重新渲染</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">depsEqual</span> = (<span class="params">newDeps, prevDeps</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (prevDeps[<span class="number">0</span>]?.<span class="property">name</span> === newDeps[<span class="number">0</span>]?.<span class="property">name</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useCustomCompareEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;🚀~~ useCustomCompareEffect working !&#x27;</span>);</span><br><span class="line">  &#125;, depsEqual, [obj])</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>name: &#123; obj.name &#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>age: &#123; obj.age &#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setObj(&#123; ...obj, name: &#x27;easy code sniper&#x27; &#125;)&#125;&gt;修改name<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setObj(&#123; ...obj, age: 30 &#125;)&#125;&gt;修改age<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<p>源码及解析如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">DependencyList</span>, <span class="title class_">EffectCallback</span>, useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是基本类型值，是基本类型就返回true</span></span><br><span class="line"><span class="comment">// Object()：给Object()函数传递一个值，如果是对象或者数组，则返回该值的引用；如果是基本类型值，则把该基本类型值包装成为对应的对象类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isPrimitive</span> = (<span class="params">val: any</span>) =&gt; val !== <span class="title class_">Object</span>(val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义比较函数有两个参数：旧的deps 和 新的deps ，该函数需要返回一个bool值来表示依赖是否发生变化</span></span><br><span class="line">type <span class="title class_">DepsEqualFnType</span>&lt;<span class="title class_">TDeps</span> <span class="keyword">extends</span> <span class="title class_">DependencyList</span>&gt; = <span class="function">(<span class="params">prevDeps: TDeps, nextDeps: TDeps</span>) =&gt;</span> boolean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接受三个参数</span></span><br><span class="line"><span class="comment"> * effect：副作用函数</span></span><br><span class="line"><span class="comment"> * deps：依赖项</span></span><br><span class="line"><span class="comment"> * depsEqual：自定义比较函数，该函数有两个参数，前一个依赖项 和 当前依赖项，要求返回一个boolean来表示依赖项是否发生了变化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> useCustomCompareEffect = &lt;<span class="title class_">TDeps</span> <span class="keyword">extends</span> <span class="title class_">DependencyList</span>&gt;<span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  effect: EffectCallback,</span></span></span><br><span class="line"><span class="params"><span class="function">  deps: TDeps,</span></span></span><br><span class="line"><span class="params"><span class="function">  depsEqual: DepsEqualFnType&lt;TDeps&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 生产环境下的一些警告提示，可以忽略</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// deps依赖必须有</span></span><br><span class="line">    <span class="keyword">if</span> (!(deps <span class="keyword">instanceof</span> <span class="title class_">Array</span>) || !deps.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">&#x27;`useCustomCompareEffect` should not be used with no dependencies. Use React.useEffect instead.&#x27;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果每一项依赖都是基本类型，那使用useEffect即可</span></span><br><span class="line">    <span class="keyword">if</span> (deps.<span class="title function_">every</span>(isPrimitive)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">&#x27;`useCustomCompareEffect` should not be used with dependencies that are all primitive values. Use React.useEffect instead.&#x27;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// depsEqual 必须是一个函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> depsEqual !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">&#x27;`useCustomCompareEffect` should be used with depsEqual callback for comparing deps list&#x27;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//定义一个ref来存储依赖项</span></span><br><span class="line">  <span class="keyword">const</span> ref = useRef&lt;<span class="title class_">TDeps</span> | <span class="literal">undefined</span>&gt;(<span class="literal">undefined</span>); </span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  !ref.current 表示初次渲染</span></span><br><span class="line"><span class="comment">  *  !depsEqual(deps, ref.current) 根据自定义的比较函数来判断依赖是否发生变化</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (!ref.<span class="property">current</span> || !<span class="title function_">depsEqual</span>(deps, ref.<span class="property">current</span>)) &#123; </span><br><span class="line">    ref.<span class="property">current</span> = deps; <span class="comment">// 当初次渲染时，或者依赖项发生变化时，ref存储新的依赖</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// useEffect依赖的并不是deps，实际依赖的是ref.current </span></span><br><span class="line">  <span class="comment">// 只有在depsEqual函数判断依赖项发生了变化，并更新ref.current之后，useEffect才会重新执行effect</span></span><br><span class="line">  <span class="title function_">useEffect</span>(effect, ref.<span class="property">current</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useCustomCompareEffect;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="useShallowCompareEffect"><a href="#useShallowCompareEffect" class="headerlink" title="useShallowCompareEffect"></a>useShallowCompareEffect</h2><p>React的<code>useEffect</code>比较依赖项的规则是<code>Object.is()</code>，它大部分情况下和<code>===</code>的效果是相同的<br><code>useShallowCompareEffect</code>Hook 会对每个依赖项进行浅比较，而不是引用相等</p>
<blockquote>
<p>浅比较<br>通常是检查对象的顶层属性是否具有相同的值和相同的引用，对于嵌套对象不进行深入比较</p>
</blockquote>
<p>源码及解析如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">DependencyList</span>, <span class="title class_">EffectCallback</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; equal <span class="keyword">as</span> isShallowEqual &#125; <span class="keyword">from</span> <span class="string">&#x27;fast-shallow-equal&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> useCustomCompareEffect <span class="keyword">from</span> <span class="string">&#x27;./useCustomCompareEffect&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是基本类型值</span></span><br><span class="line"><span class="comment">// 给Object()函数传递一个值，如果是对象或者数组，则返回该值的引用；如果是基本类型值，则把该基本类型值包装成为对应的对象类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isPrimitive</span> = (<span class="params">val: any</span>) =&gt; val !== <span class="title class_">Object</span>(val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用第三方库，实现依赖项的浅比较</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">shallowEqualDepsList</span> = (<span class="params">prevDeps: DependencyList, nextDeps: DependencyList</span>) =&gt;</span><br><span class="line">  prevDeps.<span class="title function_">every</span>(<span class="function">(<span class="params">dep, index</span>) =&gt;</span> <span class="title function_">isShallowEqual</span>(dep, nextDeps[index]));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接受两个参数</span></span><br><span class="line"><span class="comment"> * effect：副作用函数</span></span><br><span class="line"><span class="comment"> * deps：依赖项</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useShallowCompareEffect</span> = (<span class="params">effect: EffectCallback, deps: DependencyList</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 生产环境下的一些警告提示，可以忽略</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(deps <span class="keyword">instanceof</span> <span class="title class_">Array</span>) || !deps.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">&#x27;`useShallowCompareEffect` should not be used with no dependencies. Use React.useEffect instead.&#x27;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (deps.<span class="title function_">every</span>(isPrimitive)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">&#x27;`useShallowCompareEffect` should not be used with dependencies that are all primitive values. Use React.useEffect instead.&#x27;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 调用 useCustomCompareEffect , 将shallowEqualDepsList作为自定义比较方法</span></span><br><span class="line">  <span class="comment">// 实际上就是对 useCustomCompareEffect 的又一层封装</span></span><br><span class="line">  <span class="title function_">useCustomCompareEffect</span>(effect, deps, shallowEqualDepsList);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useShallowCompareEffect;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="useEvent"><a href="#useEvent" class="headerlink" title="useEvent"></a>useEvent</h2><p>用于在特定的事件目标（如 window、document 或任何实现了特定事件监听器接口的对象）上添加和移除事件监听器，它旨在 在不同类型的事件目标上 提供一个统一的 API</p>
<p>源码及解析如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="comment">// isBrower 判断是否是浏览器环境</span></span><br><span class="line"><span class="comment">// on off 是封装好的浏览器事件监听器添加和移除方法</span></span><br><span class="line"><span class="keyword">import</span> &#123; isBrowser, off, on &#125; <span class="keyword">from</span> <span class="string">&#x27;./misc/util&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ListenerType1 和 ListenerType2 接口定义了两种不同的事件监听模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface <span class="title class_">ListenerType1</span> &#123;</span><br><span class="line">  <span class="title function_">addEventListener</span>(<span class="attr">name</span>: string, <span class="attr">handler</span>: <span class="function">(<span class="params">event?: any</span>) =&gt;</span> <span class="keyword">void</span>, ...<span class="attr">args</span>: any[]);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">removeEventListener</span>(<span class="attr">name</span>: string, <span class="attr">handler</span>: <span class="function">(<span class="params">event?: any</span>) =&gt;</span> <span class="keyword">void</span>, ...<span class="attr">args</span>: any[]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface <span class="title class_">ListenerType2</span> &#123;</span><br><span class="line">  <span class="title function_">on</span>(<span class="attr">name</span>: string, <span class="attr">handler</span>: <span class="function">(<span class="params">event?: any</span>) =&gt;</span> <span class="keyword">void</span>, ...<span class="attr">args</span>: any[]);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">off</span>(<span class="attr">name</span>: string, <span class="attr">handler</span>: <span class="function">(<span class="params">event?: any</span>) =&gt;</span> <span class="keyword">void</span>, ...<span class="attr">args</span>: any[]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">UseEventTarget</span> = <span class="title class_">ListenerType1</span> | <span class="title class_">ListenerType2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// isListenerType1 和 isListenerType2 用来判断目标事件对象是否有 addEventListener 或 on 属性来实现的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isListenerType1 = (<span class="attr">target</span>: any): target is <span class="title class_">ListenerType1</span> =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> !!target.<span class="property">addEventListener</span>; <span class="comment">// !! 任何真值都会被转化成true，假值都会被转化成false</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> isListenerType2 = (<span class="attr">target</span>: any): target is <span class="title class_">ListenerType2</span> =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> !!target.<span class="property">on</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultTarget = isBrowser ? <span class="variable language_">window</span> : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接受四个参数；</span></span><br><span class="line"><span class="comment"> * name：事件名称</span></span><br><span class="line"><span class="comment"> * handler：事件处理函数</span></span><br><span class="line"><span class="comment"> * target：事件监听器的目标对象，默认值是 defaultTarget</span></span><br><span class="line"><span class="comment"> * options：可选参数，用于传递给事件监听器的选项</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useEvent</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  name,</span></span><br><span class="line"><span class="params">  handler,</span></span><br><span class="line"><span class="params">  target,</span></span><br><span class="line"><span class="params">  options?</span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!handler || !target) &#123; <span class="comment">// 如果没有传入事件处理函数或者事件对象，不做任何处理直接返回</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isListenerType1</span>(target)) &#123; <span class="comment">//如果目标对象实现的是addEventListener模式，将它手动代理成on模式来添加监听器</span></span><br><span class="line">      <span class="title function_">on</span>(target, name, handler, options);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isListenerType2</span>(target)) &#123; <span class="comment">//如果目标对象实现的是on模式，直接用on模式添加监听器</span></span><br><span class="line">      target.<span class="title function_">on</span>(name, handler, options);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123; <span class="comment">// 在组件销毁时删除事件监听</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isListenerType1</span>(target)) &#123;</span><br><span class="line">        <span class="title function_">off</span>(target, name, handler, options);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isListenerType2</span>(target)) &#123;</span><br><span class="line">        target.<span class="title function_">off</span>(name, handler, options);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [name, handler, target, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(options)]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useEvent;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>on</code> 和 <code>off</code>函数的封装：</p>
<p>on函数接受一个可能为null的对象obj和一个参数列表args。参数列表可以是任何addEventListener方法接受的参数。函数内部会检查obj是否存在并且是否有addEventListener方法。如果条件满足，它会调用obj.addEventListener并传入args参数。<br>这个函数的主要作用是检查对象是否存在并且可以添加事件监听器，然后按照给定的参数调用addEventListener方法。这样做可以避免直接在组件内部调用addEventListener时可能遇到的null或undefined对象错误。</p>
<p>off函数同理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> on&lt;T <span class="keyword">extends</span> <span class="title class_">Window</span> | <span class="title class_">Document</span> | <span class="title class_">HTMLElement</span> | <span class="title class_">EventTarget</span>&gt;(</span><br><span class="line">  <span class="attr">obj</span>: T | <span class="literal">null</span>,</span><br><span class="line">  ...<span class="attr">args</span>: <span class="title class_">Parameters</span>&lt;T[<span class="string">&#x27;addEventListener&#x27;</span>]&gt; | [string, <span class="title class_">Function</span> | <span class="literal">null</span>, ...any]</span><br><span class="line">): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; obj.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">    obj.<span class="title function_">addEventListener</span>(...(args <span class="keyword">as</span> <span class="title class_">Parameters</span>&lt;<span class="title class_">HTMLElement</span>[<span class="string">&#x27;addEventListener&#x27;</span>]&gt;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> off&lt;T <span class="keyword">extends</span> <span class="title class_">Window</span> | <span class="title class_">Document</span> | <span class="title class_">HTMLElement</span> | <span class="title class_">EventTarget</span>&gt;(</span><br><span class="line">  <span class="attr">obj</span>: T | <span class="literal">null</span>,</span><br><span class="line">  ...<span class="attr">args</span>: <span class="title class_">Parameters</span>&lt;T[<span class="string">&#x27;removeEventListener&#x27;</span>]&gt; | [string, <span class="title class_">Function</span> | <span class="literal">null</span>, ...any]</span><br><span class="line">): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; obj.<span class="property">removeEventListener</span>) &#123;</span><br><span class="line">    obj.<span class="title function_">removeEventListener</span>(...(args <span class="keyword">as</span> <span class="title class_">Parameters</span>&lt;<span class="title class_">HTMLElement</span>[<span class="string">&#x27;removeEventListener&#x27;</span>]&gt;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="useGeolocation"><a href="#useGeolocation" class="headerlink" title="useGeolocation"></a>useGeolocation</h2><p>该hook用于获取和追踪用户的地理位置，基于浏览器内置对象<code>navigator</code>实现</p>
<p>使用示例:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> useGeolocation <span class="keyword">from</span> <span class="string">&quot;./hooks/useGeolocation&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> geolocation = <span class="title function_">useGeolocation</span>()</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(geolocation);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<p>源码及解析如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义获取位置错误的接口</span></span><br><span class="line"><span class="keyword">export</span> interface <span class="title class_">IGeolocationPositionError</span> &#123; </span><br><span class="line">  readonly <span class="attr">code</span>: number;</span><br><span class="line">  readonly <span class="attr">message</span>: string;</span><br><span class="line">  readonly <span class="attr">PERMISSION_DENIED</span>: number;</span><br><span class="line">  readonly <span class="attr">POSITION_UNAVAILABLE</span>: number;</span><br><span class="line">  readonly <span class="attr">TIMEOUT</span>: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义当前位置信息的接口</span></span><br><span class="line"><span class="keyword">export</span> interface <span class="title class_">GeoLocationSensorState</span> &#123; </span><br><span class="line">  <span class="attr">loading</span>: boolean; <span class="comment">//位置信息是否正在加载中</span></span><br><span class="line">  <span class="attr">accuracy</span>: number | <span class="literal">null</span>; <span class="comment">//获取的位置的精确度</span></span><br><span class="line">  <span class="attr">altitude</span>: number | <span class="literal">null</span>;  <span class="comment">//相对于海平面的高度</span></span><br><span class="line">  <span class="attr">altitudeAccuracy</span>: number | <span class="literal">null</span>; <span class="comment">//高度的精确度</span></span><br><span class="line">  <span class="attr">heading</span>: number | <span class="literal">null</span>; <span class="comment">//设备移动方向</span></span><br><span class="line">  <span class="attr">latitude</span>: number | <span class="literal">null</span>; <span class="comment">//纬度</span></span><br><span class="line">  <span class="attr">longitude</span>: number | <span class="literal">null</span>; <span class="comment">//经度</span></span><br><span class="line">  <span class="attr">speed</span>: number | <span class="literal">null</span>; <span class="comment">//速度</span></span><br><span class="line">  <span class="attr">timestamp</span>: number | <span class="literal">null</span>; <span class="comment">//这些位置数据的时间戳</span></span><br><span class="line">  error?: <span class="title class_">Error</span> | <span class="title class_">IGeolocationPositionError</span>; <span class="comment">//在获取地理位置信息时发生错误，这里会存储错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface <span class="title class_">PositionOptions</span> &#123;</span><br><span class="line">    enableHighAccuracy?: boolean; <span class="comment">// 是否需要高精度的位置信息</span></span><br><span class="line">    maximumAge?: number; <span class="comment">// 能接受多旧的位置信息</span></span><br><span class="line">    timeout?: number; <span class="comment">//获取位置信息的最长等待时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useGeolocation = (options?: <span class="title class_">PositionOptions</span>): <span class="function"><span class="params">GeoLocationSensorState</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState&lt;<span class="title class_">GeoLocationSensorState</span>&gt;(&#123;</span><br><span class="line">    <span class="attr">loading</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">accuracy</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">altitude</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">altitudeAccuracy</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">heading</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">latitude</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">longitude</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">speed</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">timestamp</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>(),</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">let</span> mounted = <span class="literal">true</span>; <span class="comment">// 表示组件是否挂载</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">watchId</span>: any; <span class="comment">// 调用navigator.geolocation.watchPosition返回的id，用于在组件卸载时清除监听</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 位置信息请求成功的回调函数，navigator.geolocation.getCurrentPosition会在成功时传给该函数一个Positon对象，包含了位置信息</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onEvent</span> = (<span class="params">event: any</span>) =&gt; &#123; </span><br><span class="line">    <span class="keyword">if</span> (mounted) &#123;</span><br><span class="line">      <span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">loading</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">accuracy</span>: event.<span class="property">coords</span>.<span class="property">accuracy</span>,</span><br><span class="line">        <span class="attr">altitude</span>: event.<span class="property">coords</span>.<span class="property">altitude</span>,</span><br><span class="line">        <span class="attr">altitudeAccuracy</span>: event.<span class="property">coords</span>.<span class="property">altitudeAccuracy</span>,</span><br><span class="line">        <span class="attr">heading</span>: event.<span class="property">coords</span>.<span class="property">heading</span>,</span><br><span class="line">        <span class="attr">latitude</span>: event.<span class="property">coords</span>.<span class="property">latitude</span>,</span><br><span class="line">        <span class="attr">longitude</span>: event.<span class="property">coords</span>.<span class="property">longitude</span>,</span><br><span class="line">        <span class="attr">speed</span>: event.<span class="property">coords</span>.<span class="property">speed</span>,</span><br><span class="line">        <span class="attr">timestamp</span>: event.<span class="property">timestamp</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 位置信息请求失败的回调函数，navigator.geolocation.getCurrentPosition会在失败时传给该函数一个error对象，包含了错误信息</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onEventError</span> = (<span class="params">error: IGeolocationPositionError</span>) =&gt;</span><br><span class="line">    mounted &amp;&amp; <span class="title function_">setState</span>(<span class="function">(<span class="params">oldState</span>) =&gt;</span> (&#123; ...oldState, <span class="attr">loading</span>: <span class="literal">false</span>, error &#125;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * navigator.geolocation.getCurrentPosition用于获取当前地理位置信息</span></span><br><span class="line"><span class="comment">   * 接受三个参数：成功的回调、错误时的回调（可选）、选项对象PositionOptions（可选）</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * navigator.geolocation.watchPosition用于注册一个监听器，在用户的设备地理位置发生变化时被调用。该方法返回一个id，用于取消监听</span></span><br><span class="line"><span class="comment">   * 接受三个参数：成功的回调、错误时的回调（可选）、选项对象PositionOptions（可选）</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * navigator.geolocation.clearWatch(watchId)用于取消监听，传入监听器id</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    navigator.<span class="property">geolocation</span>.<span class="title function_">getCurrentPosition</span>(onEvent, onEventError, options);</span><br><span class="line">    watchId = navigator.<span class="property">geolocation</span>.<span class="title function_">watchPosition</span>(onEvent, onEventError, options);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      mounted = <span class="literal">false</span>;</span><br><span class="line">      navigator.<span class="property">geolocation</span>.<span class="title function_">clearWatch</span>(watchId);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useGeolocation;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>navigator对象 是 浏览器内置对象，它提供了关于用户浏览器的信息</p>
</blockquote>
<img src="/2024/03/29/react-use%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/image-1.png" class title="This is an image">

<h2 id="useHover"><a href="#useHover" class="headerlink" title="useHover"></a>useHover</h2><p><code>useHover</code>提供一种简单的方式来跟踪鼠标悬停状态。这个钩子接受一个 React 元素或者一个返回 React 元素的函数，并返回一个数组，包含一个带有悬停事件处理的克隆元素以及一个表示悬停状态（true 或 false）的布尔值。</p>
<p><strong>使用示例：</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> useHover <span class="keyword">from</span> <span class="string">&quot;./hooks/useHover&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [ el, state ] = <span class="title function_">useHover</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">onMouseEnter</span>=<span class="string">&#123;()</span> =&gt;</span> console.log(&#x27;🚀~~ enter&#x27;)&#125;</span></span><br><span class="line"><span class="language-xml">      onMouseLeave=&#123;() =&gt; console.log(&#x27;🚀~~ leave&#x27;)&#125;</span></span><br><span class="line"><span class="language-xml">    &gt;我是一个div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;el&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;state &amp;&amp; <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hovered !<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<p>源码及解析如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// noop 不执行任何操作的空函数 () =&gt; &#123;&#125;</span></span><br><span class="line"><span class="keyword">import</span> &#123; noop &#125; <span class="keyword">from</span> <span class="string">&#x27;./misc/util&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; useState &#125; = <span class="title class_">React</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义Element接口，表示Element类型可以是一个React元素，也可以是一个函数，该函数接受一个boolean类型的参数，并返回React元素</span></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">Element</span> = (<span class="function">(<span class="params">state: boolean</span>) =&gt;</span> <span class="title class_">React</span>.<span class="property">ReactElement</span>&lt;any&gt;) | <span class="title class_">React</span>.<span class="property">ReactElement</span>&lt;any&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// useHover 接受一个Element类型的参数</span></span><br><span class="line"><span class="keyword">const</span> useHover = (<span class="attr">element</span>: <span class="title class_">Element</span>): [<span class="title class_">React</span>.<span class="property">ReactElement</span>&lt;any&gt;, boolean] =&gt; &#123;</span><br><span class="line">  <span class="comment">// state状态用于表示是否处于鼠标悬停状态</span></span><br><span class="line">  <span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接受一个原始事件处理函数，返回一个新的事件处理函数。</span></span><br><span class="line">  <span class="comment">// 新的事件处理函数首先调用传入的原始事件处理函数（如果没有提供，则调用 noop），然后通过 setState 更新悬停状态。</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onMouseEnter</span> = (<span class="params">originalOnMouseEnter?: any</span>) =&gt; <span class="function">(<span class="params">event: any</span>) =&gt;</span> &#123;</span><br><span class="line">    (originalOnMouseEnter || noop)(event);</span><br><span class="line">    <span class="title function_">setState</span>(<span class="literal">true</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onMouseLeave</span> = (<span class="params">originalOnMouseLeave?: any</span>) =&gt; <span class="function">(<span class="params">event: any</span>) =&gt;</span> &#123;</span><br><span class="line">    (originalOnMouseLeave || noop)(event);</span><br><span class="line">    <span class="title function_">setState</span>(<span class="literal">false</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 传入的element是一个函数，则将代表是否hover的状态state传入来返回对应的React元素</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> element === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    element = <span class="title function_">element</span>(state);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// element.props.onMouseEnter 和 element.props.onMouseLeave 是原始元素上可能存在的鼠标悬停和离开函数</span></span><br><span class="line">  <span class="keyword">const</span> el = <span class="title class_">React</span>.<span class="title function_">cloneElement</span>(element, &#123;</span><br><span class="line">    <span class="attr">onMouseEnter</span>: <span class="title function_">onMouseEnter</span>(element.<span class="property">props</span>.<span class="property">onMouseEnter</span>),</span><br><span class="line">    <span class="attr">onMouseLeave</span>: <span class="title function_">onMouseLeave</span>(element.<span class="property">props</span>.<span class="property">onMouseLeave</span>),</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回克隆的React元素 以及 表示悬浮状态的state</span></span><br><span class="line">  <span class="keyword">return</span> [el, state];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useHover;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><code>React.cloneElement()</code></strong></p>
<p>它允许你克隆一个React元素，并且可以选择性的传入props、子元素以及key。它的作用是基于已有的React元素创建一个新的元素，默认保留原有元素的props、内部状态和行为</p>
<blockquote>
<p>默认保留原有元素的props、内部状态和行为<br>因为在默认情况下，React只是浅克隆了原有元素，并传入新的props。在不改变key的情况下，React会视这两个组件为同一个实例，这就意味着，即使属性可能有所改变，但由于组件类型和 key 没有变化，React的重用逻辑会保留组件实例及其内部状态。</p>
</blockquote>
<p>使用<code>React.cloneElement</code>可以很方便地扩展或修改组件的子元素，而不需要创建一个全新的组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">cloneElement</span>(</span><br><span class="line">  element, <span class="comment">// 想要克隆的React对象</span></span><br><span class="line">  props, <span class="comment">// 可选参数。传入一个对象，包含要添加或者覆盖的新属性</span></span><br><span class="line">  [...children] <span class="comment">// 可选参数。可以传入任意数量的子节点来替换被克隆元素的子节点</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>React.cloneElement</code> 使用示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ListItem</span> = (<span class="params">&#123; children, onClick &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">List</span> = (<span class="params">&#123; items &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;items.map((item, index) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">        // 克隆ListItem，并为每个item添加特定的onClick处理器</span></span><br><span class="line"><span class="language-xml">        return React.cloneElement(<span class="tag">&lt;<span class="name">ListItem</span>&gt;</span>&#123;item.text&#125;<span class="tag">&lt;/<span class="name">ListItem</span>&gt;</span>, &#123;</span></span><br><span class="line"><span class="language-xml">          key: index, // 必须提供key，特别是在map循环中</span></span><br><span class="line"><span class="language-xml">          onClick: () =&gt; alert(`Item $&#123;index + 1&#125; clicked!`), // 绑定了一个弹窗事件</span></span><br><span class="line"><span class="language-xml">        &#125;);</span></span><br><span class="line"><span class="language-xml">      &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用List组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> items = [</span><br><span class="line">    &#123; <span class="attr">text</span>: <span class="string">&#x27;Item 1&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">text</span>: <span class="string">&#x27;Item 2&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">text</span>: <span class="string">&#x27;Item 3&#x27;</span> &#125;,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">List</span> <span class="attr">items</span>=<span class="string">&#123;items&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<h2 id="useHoverDirty"><a href="#useHoverDirty" class="headerlink" title="useHoverDirty"></a>useHoverDirty</h2><p><code>useHoverDirty</code>提供一种方式来检测用户是否悬浮在某个元素上</p>
<p><code>useHover</code>接受一个React元素或者一个函数，而<code>useHoverDirty</code>接受<code>React ref</code><br><code>useHover</code>通过设置React元素的<code>onMouseOver</code>和<code>onMouseOut</code>事件，而<code>useHoverDirty</code>通过设置DOM元素的<code>onMouseOver</code>和<code>onMouseOut</code>事件</p>
<p><strong>使用示例：</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> useHoverDirty <span class="keyword">from</span> <span class="string">&#x27;./useHoverDirty&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">HoverComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 创建一个ref来引用我们想要检测悬停的DOM元素</span></span><br><span class="line">  <span class="keyword">const</span> hoverRef = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="comment">// 使用我们的自定义Hook来获取悬停状态</span></span><br><span class="line">  <span class="keyword">const</span> isHovered = <span class="title function_">useHoverDirty</span>(hoverRef);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据悬停状态动态设置样式</span></span><br><span class="line">  <span class="keyword">const</span> style = &#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="string">&#x27;200px&#x27;</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="string">&#x27;200px&#x27;</span>,</span><br><span class="line">    <span class="attr">backgroundColor</span>: isHovered ? <span class="string">&#x27;blue&#x27;</span> : <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    <span class="comment">// 当鼠标悬停时背景色变蓝，否则为红色</span></span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">    <span class="attr">display</span>: <span class="string">&#x27;flex&#x27;</span>,</span><br><span class="line">    <span class="attr">alignItems</span>: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">    <span class="attr">justifyContent</span>: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">    <span class="attr">transition</span>: <span class="string">&#x27;background-color 0.3s&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;hoverRef&#125;</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;isHovered ? &#x27;Hovering&#x27; : &#x27;Not Hovering&#x27;&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">HoverComponent</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>源码及解析如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RefObject</span>, useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; off, on &#125; <span class="keyword">from</span> <span class="string">&#x27;./misc/util&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ref: 这是一个React ref对象，指向要监听悬浮事件的DOM元素。使用ref是因为我们需要直接操作DOM元素来绑定和解绑事件监听器。</span></span><br><span class="line"><span class="comment"> * enabled: 这是一个可选参数，默认为true。它允许使用者启用或禁用悬浮监听功能。这可以用来在某些条件下动态开启或关闭事件监听。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useHoverDirty</span> = (<span class="params">ref: RefObject&lt;Element&gt;, enabled: boolean = <span class="literal">true</span></span>) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开发模式下的警告，可以忽略</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> ref !== <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> ref.<span class="property">current</span> === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;useHoverDirty expects a single ref argument.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否处于悬浮状态的state</span></span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">onMouseOver</span> = (<span class="params"></span>) =&gt; <span class="title function_">setValue</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">onMouseOut</span> = (<span class="params"></span>) =&gt; <span class="title function_">setValue</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enabled &amp;&amp; ref &amp;&amp; ref.<span class="property">current</span>) &#123;</span><br><span class="line">      <span class="title function_">on</span>(ref.<span class="property">current</span>, <span class="string">&#x27;mouseover&#x27;</span>, onMouseOver);</span><br><span class="line">      <span class="title function_">on</span>(ref.<span class="property">current</span>, <span class="string">&#x27;mouseout&#x27;</span>, onMouseOut);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; current &#125; = ref;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (enabled &amp;&amp; current) &#123;</span><br><span class="line">        <span class="title function_">off</span>(current, <span class="string">&#x27;mouseover&#x27;</span>, onMouseOver);</span><br><span class="line">        <span class="title function_">off</span>(current, <span class="string">&#x27;mouseout&#x27;</span>, onMouseOut);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [enabled, ref]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useHoverDirty;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// on函数 和 off函数 的封装</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> on&lt;T <span class="keyword">extends</span> <span class="title class_">Window</span> | <span class="title class_">Document</span> | <span class="title class_">HTMLElement</span> | <span class="title class_">EventTarget</span>&gt;(</span><br><span class="line">  <span class="attr">obj</span>: T | <span class="literal">null</span>,</span><br><span class="line">  ...<span class="attr">args</span>: <span class="title class_">Parameters</span>&lt;T[<span class="string">&#x27;addEventListener&#x27;</span>]&gt; | [string, <span class="title class_">Function</span> | <span class="literal">null</span>, ...any]</span><br><span class="line">): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; obj.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">    obj.<span class="title function_">addEventListener</span>(...(args <span class="keyword">as</span> <span class="title class_">Parameters</span>&lt;<span class="title class_">HTMLElement</span>[<span class="string">&#x27;addEventListener&#x27;</span>]&gt;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> off&lt;T <span class="keyword">extends</span> <span class="title class_">Window</span> | <span class="title class_">Document</span> | <span class="title class_">HTMLElement</span> | <span class="title class_">EventTarget</span>&gt;(</span><br><span class="line">  <span class="attr">obj</span>: T | <span class="literal">null</span>,</span><br><span class="line">  ...<span class="attr">args</span>: <span class="title class_">Parameters</span>&lt;T[<span class="string">&#x27;removeEventListener&#x27;</span>]&gt; | [string, <span class="title class_">Function</span> | <span class="literal">null</span>, ...any]</span><br><span class="line">): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; obj.<span class="property">removeEventListener</span>) &#123;</span><br><span class="line">    obj.<span class="title function_">removeEventListener</span>(...(args <span class="keyword">as</span> <span class="title class_">Parameters</span>&lt;<span class="title class_">HTMLElement</span>[<span class="string">&#x27;removeEventListener&#x27;</span>]&gt;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="useIntersection"><a href="#useIntersection" class="headerlink" title="useIntersection"></a>useIntersection</h2><p><code>useIntersection</code>使用了浏览器的 Intersection Observer API 来异步地检测目标元素与其祖先元素或顶级文档视口的交叉状态的变化。</p>
<blockquote>
<p>Intersection Observer API 是一个浏览器API，它允许你异步观察一个元素与其祖先元素或全局视口的交集变化。能够高效得获取元素是否进入或离开视口的信息。</p>
</blockquote>
<p><strong>相关概念</strong></p>
<ul>
<li><code>root（根）</code>: 想要检查目标元素与之相交的容器元素，如果未指定或为null，默认为浏览器视口</li>
<li><code>rootMargin（根边界）</code>: 类似于CSS的margin属性。它允许你指定一个在根元素的外围形成的边框区域，用于增加或减少用于检查交集的区域大小</li>
<li><code>threshold（阈值）</code>: 一个数字或由多个数字组成的数组，指定了观察者的回调函数被执行的条件。例如，如果阈值是0.5，则目标元素有50%进入根元素时，观察者的回调函数将被执行</li>
</ul>
<p><strong><code>IntersectionObserver()</code>方法</strong>是一个构造函数，用于创建一个新的 IntersectionObserver 对象。<br>这个构造函数接受两个参数：一个回调函数和一个可选的配置对象。</p>
<ul>
<li><p>回调函数：当被观察的元素进入或退出交集区域时，回调函数会被执行。这个函数接受两个参数：</p>
<ul>
<li><code>entries</code>: 一个 IntersectionObserverEntry 对象数组，每个对象都描述了一个被观察元素的交集状态</li>
<li><code>observer</code>: 对应的 IntersectionObserver 实例，允许你访问观察者的属性或调用其方法，如 disconnect 或 unobserve</li>
</ul>
</li>
<li><p>配置对象：包含三个属性</p>
<ul>
<li>root</li>
<li>rootMargin</li>
<li>threshold</li>
</ul>
</li>
</ul>
<p><strong>Intersection Observer</strong></p>
<ul>
<li><code>root</code>: 想要检查目标元素与之相交的容器元素，如果未指定或为null，默认为浏览器视口</li>
<li><code>rootMargin</code>: 类似于CSS的margin属性。它允许你指定一个在根元素的外围形成的边框区域，用于增加或减少用于检查交集的区域大小</li>
<li><code>thresholds</code>: 一个数字或由多个数字组成的数组，指定了观察者的回调函数被执行的条件。例如，如果阈值是0.5，则目标元素有50%进入根元素时，观察者的回调函数将被执行</li>
<li><code>disconnect()</code>: 停止观察所有目标</li>
<li><code>observe(target)</code>: 开始观察一个目标元素</li>
<li><code>takeRecords</code>: 返回所有目标的<code>IntersectionObserverEntry</code>对象数组</li>
<li><code>unobserve(targrt)</code>: 停止观察一个目标元素</li>
</ul>
<p><strong>Intersection Observer Entry</strong></p>
<ul>
<li><code>boundingClientRect</code>: 返回目标元素的矩形信息，用于计算与视口的交集</li>
<li><code>intersectionRatio</code>: 目标元素<strong>可见部分</strong>占总体的比例</li>
<li><code>intersectionRect</code>: 目标元素与视口<strong>交叉部分</strong>的矩形信息</li>
<li><code>isIntersecting</code>: 目标元素是否与根元素相交</li>
<li><code>rootBounds</code>: 根元素的矩形信息</li>
<li><code>target</code>: 目标元素</li>
<li><code>time</code>: 观察到交叉状态变化时的时间戳</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>懒加载：当图片或其他资源进入视口时才加载它们，以此节省带宽和提高页面加载速度</li>
<li>无限滚动: 当用户滚动到页面底部时，自动加载更多内容</li>
</ul>
<p>源码及解析如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RefObject</span>, useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * useIntersection接受两个参数</span></span><br><span class="line"><span class="comment"> * ref： 一个ref引用对象，指向要观察的目标元素</span></span><br><span class="line"><span class="comment"> * options： 配置对象，用于初始化Intersection Observer的选项，比如 root、rootMargin 和 threshold</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> useIntersection = (</span><br><span class="line">  <span class="attr">ref</span>: <span class="title class_">RefObject</span>&lt;<span class="title class_">HTMLElement</span>&gt;,</span><br><span class="line">  <span class="attr">options</span>: <span class="title class_">IntersectionObserverInit</span></span><br><span class="line">): <span class="title class_">IntersectionObserverEntry</span> | <span class="function"><span class="params">null</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 创建 intersectionObserverEntry 状态，用于存储 intersectionObserverEntry 对象信息</span></span><br><span class="line">  <span class="keyword">const</span> [intersectionObserverEntry, setIntersectionObserverEntry] =</span><br><span class="line">    useState&lt;<span class="title class_">IntersectionObserverEntry</span> | <span class="literal">null</span>&gt;(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ref是否存在，浏览器是否支持IntersectionObserver</span></span><br><span class="line">    <span class="keyword">if</span> (ref.<span class="property">current</span> &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">IntersectionObserver</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// handle函数用于更新 intersectionObserverEntry 状态</span></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">handler</span> = (<span class="params">entries: IntersectionObserverEntry[]</span>) =&gt; &#123;</span><br><span class="line">        <span class="title function_">setIntersectionObserverEntry</span>(entries[<span class="number">0</span>]);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建一个监听器对象</span></span><br><span class="line">      <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(handler, options);</span><br><span class="line">      <span class="comment">// 监听目标元素</span></span><br><span class="line">      observer.<span class="title function_">observe</span>(ref.<span class="property">current</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 组件销毁时取消监听，并清空 intersectionObserverEntry 状态</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setIntersectionObserverEntry</span>(<span class="literal">null</span>);</span><br><span class="line">        observer.<span class="title function_">disconnect</span>();</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">  &#125;, [ref.<span class="property">current</span>, options.<span class="property">threshold</span>, options.<span class="property">root</span>, options.<span class="property">rootMargin</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> intersectionObserverEntry;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useIntersection;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>使用示例</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> useIntersection <span class="keyword">from</span> <span class="string">&quot;./hooks/useIntersection&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> intersectionRef = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> intersection = <span class="title function_">useIntersection</span>(intersectionRef, &#123;</span><br><span class="line">    <span class="attr">root</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">rootMargin</span>: <span class="string">&#x27;0px&#x27;</span>,</span><br><span class="line">    <span class="attr">threshold</span>: <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(intersection);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:</span> &#x27;<span class="attr">200px</span>&#x27;, <span class="attr">height:</span> &#x27;<span class="attr">200px</span>&#x27;, <span class="attr">backgroundColor:</span> &#x27;<span class="attr">yellow</span>&#x27;, <span class="attr">overflowY:</span> &#x27;<span class="attr">scroll</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:</span> &#x27;<span class="attr">100</span>%&#x27;, <span class="attr">height:</span> &#x27;<span class="attr">200px</span>&#x27; &#125;&#125; &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:</span> &#x27;<span class="attr">100px</span>&#x27;, <span class="attr">height:</span> &#x27;<span class="attr">50px</span>&#x27;, <span class="attr">backgroundColor:</span> &#x27;<span class="attr">skyblue</span>&#x27; &#125;&#125; <span class="attr">ref</span>=<span class="string">&#123;intersectionRef&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;</span></span><br><span class="line"><span class="language-xml">          intersection &amp;&amp; (intersection.intersectionRatio &lt; 1)</span></span><br><span class="line"><span class="language-xml">          ? &#x27;Obscured&#x27;</span></span><br><span class="line"><span class="language-xml">          : &#x27;Full in view&#x27;</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="useKey"><a href="#useKey" class="headerlink" title="useKey"></a>useKey</h2><p><code>useKey</code>用于设置监听键盘事件</p>
<p>使用示例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useKey&#125; <span class="keyword">from</span> <span class="string">&#x27;react-use&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Demo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, set] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; <span class="title function_">set</span>(<span class="function"><span class="params">count</span> =&gt;</span> ++count);</span><br><span class="line">  <span class="title function_">useKey</span>(<span class="string">&#x27;ArrowUp&#x27;</span>, increment);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      Press arrow up: &#123;count&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>源码及解析如下；</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">DependencyList</span>, useMemo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> useEvent, &#123; <span class="title class_">UseEventOptions</span>, <span class="title class_">UseEventTarget</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./useEvent&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; noop &#125; <span class="keyword">from</span> <span class="string">&#x27;./misc/util&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">KeyPredicate</span> = <span class="function">(<span class="params">event: KeyboardEvent</span>) =&gt;</span> boolean;</span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">KeyFilter</span> = <span class="literal">null</span> | <span class="literal">undefined</span> | string | (<span class="function">(<span class="params">event: KeyboardEvent</span>) =&gt;</span> boolean);</span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">Handler</span> = <span class="function">(<span class="params">event: KeyboardEvent</span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface <span class="title class_">UseKeyOptions</span>&lt;T <span class="keyword">extends</span> <span class="title class_">UseEventTarget</span>&gt; &#123;</span><br><span class="line">  event?: <span class="string">&#x27;keydown&#x27;</span> | <span class="string">&#x27;keypress&#x27;</span> | <span class="string">&#x27;keyup&#x27;</span>;</span><br><span class="line">  target?: T | <span class="literal">null</span>;</span><br><span class="line">  options?: <span class="title class_">UseEventOptions</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// createKeyPredicate接受一个参数keyFilter，该参数可以是一个判断函数（用于判断何时符合条件）、一个字符串（指定的keyboard） 或者 undefined/null</span></span><br><span class="line"><span class="comment">// 然后 createKeyPredicate 根据不同的参数来创建判断函数</span></span><br><span class="line"><span class="comment">// 如果传入的是函数，就返回这个函数</span></span><br><span class="line"><span class="comment">// 如果传入的是字符串（特定的keyboard），则将它包装成一个函数，当event.key === 字符串 时返回true，表示符合条件触发回调函数</span></span><br><span class="line"><span class="comment">// 如果传入的是undefined/null，则包装一个固定返回false的函数，表示不符合条件不触发回调函数</span></span><br><span class="line"><span class="keyword">const</span> createKeyPredicate = (<span class="attr">keyFilter</span>: <span class="title class_">KeyFilter</span>): <span class="function"><span class="params">KeyPredicate</span> =&gt;</span></span><br><span class="line">  <span class="keyword">typeof</span> keyFilter === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">    ? keyFilter</span><br><span class="line">    : <span class="keyword">typeof</span> keyFilter === <span class="string">&#x27;string&#x27;</span></span><br><span class="line">    ? <span class="function">(<span class="params">event: KeyboardEvent</span>) =&gt;</span> event.<span class="property">key</span> === keyFilter</span><br><span class="line">    : keyFilter</span><br><span class="line">    ? <span class="function">() =&gt;</span> <span class="literal">true</span></span><br><span class="line">    : <span class="function">() =&gt;</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定触发回调的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fn 要触发的回调函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> opts 配置选项</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> deps 依赖项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> useKey = &lt;T <span class="keyword">extends</span> <span class="title class_">UseEventTarget</span>&gt;<span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  key: KeyFilter,</span></span></span><br><span class="line"><span class="params"><span class="function">  fn: Handler = noop,</span></span></span><br><span class="line"><span class="params"><span class="function">  opts: UseKeyOptions&lt;T&gt; = &#123;&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">  deps: DependencyList = [key]</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// event 指定是哪种键盘事件（keydown，keyup，keypress）</span></span><br><span class="line">  <span class="comment">// target 绑定事件的目标对象</span></span><br><span class="line">  <span class="comment">// options 传递给useEvent的配置项</span></span><br><span class="line">  <span class="keyword">const</span> &#123; event = <span class="string">&#x27;keydown&#x27;</span>, target, options &#125; = opts;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 包装后的回调函数</span></span><br><span class="line">  <span class="keyword">const</span> useMemoHandler = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 根据传入的key值创建一个判断函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">predicate</span>: <span class="title class_">KeyPredicate</span> = <span class="title function_">createKeyPredicate</span>(key);</span><br><span class="line">    <span class="comment">// handlerEvent 是浏览器事件对象，当向监听器添加事件处理函数时，浏览器会自动传入事件对象作为参数</span></span><br><span class="line">    <span class="comment">// 我们可以通过event参数访问到事件的详细信息，如被按下的键是什么（event.key）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">handler</span>: <span class="title class_">Handler</span> = <span class="function">(<span class="params">handlerEvent</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 判断是否符合触发回调的条件</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">predicate</span>(handlerEvent)) &#123;</span><br><span class="line">        <span class="comment">// 如果符合，就执行用户传入的回调函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fn</span>(handlerEvent);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">  &#125;, deps);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用useEvent来为目标对象绑定事件</span></span><br><span class="line">  <span class="title function_">useEvent</span>(event, useMemoHandler, target, options);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useKey;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="useLongPress"><a href="#useLongPress" class="headerlink" title="useLongPress"></a>useLongPress</h2><p><code>useLongPress</code>用于设置长按之后触发的回调</p>
<p>源码及解析如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useCallback, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; off, on &#125; <span class="keyword">from</span> <span class="string">&#x27;./misc/util&#x27;</span>;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">Options</span> &#123;</span><br><span class="line">  isPreventDefault?: boolean;</span><br><span class="line">  delay?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isTouchEvent = (<span class="attr">ev</span>: <span class="title class_">Event</span>): ev is <span class="title class_">TouchEvent</span> =&gt; &#123;</span><br><span class="line">  <span class="comment">// 检查浏览器传入的事件对象中是否有touches属性，即是否触发了touches事件</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;touches&#x27;</span> <span class="keyword">in</span> ev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">preventDefault</span> = (<span class="params">ev: Event</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isTouchEvent</span>(ev)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当触摸点个数小于2个时，阻止默认事件</span></span><br><span class="line">  <span class="keyword">if</span> (ev.<span class="property">touches</span>.<span class="property">length</span> &lt; <span class="number">2</span> &amp;&amp; ev.<span class="property">preventDefault</span>) &#123;</span><br><span class="line">    ev.<span class="title function_">preventDefault</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callback 长按之后的回调函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> options 配置项对象（可选），其中包括是否阻止默认事件，延迟时间等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useLongPress</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  callback: (e: TouchEvent | MouseEvent) =&gt; <span class="keyword">void</span>,</span></span><br><span class="line"><span class="params">  &#123; isPreventDefault = <span class="literal">true</span>, delay = <span class="number">300</span> &#125;: Options = &#123;&#125;</span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 用于缓存 定时器id 和 目标对象</span></span><br><span class="line">  <span class="keyword">const</span> timeout = useRef&lt;<span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> <span class="built_in">setTimeout</span>&gt;&gt;();</span><br><span class="line">  <span class="keyword">const</span> target = useRef&lt;<span class="title class_">EventTarget</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装监听触摸事件的函数</span></span><br><span class="line">  <span class="keyword">const</span> start = <span class="title function_">useCallback</span>(</span><br><span class="line">    <span class="function">(<span class="params">event: TouchEvent | MouseEvent</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 绑定触摸事件，并缓存目标对象</span></span><br><span class="line">      <span class="keyword">if</span> (isPreventDefault &amp;&amp; event.<span class="property">target</span>) &#123;</span><br><span class="line">        <span class="title function_">on</span>(event.<span class="property">target</span>, <span class="string">&#x27;touchend&#x27;</span>, preventDefault, &#123; <span class="attr">passive</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">        target.<span class="property">current</span> = event.<span class="property">target</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 缓存定时器id</span></span><br><span class="line">      timeout.<span class="property">current</span> = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">callback</span>(event), delay);</span><br><span class="line">    &#125;,</span><br><span class="line">    [callback, delay, isPreventDefault]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装解除监听事件的函数</span></span><br><span class="line">  <span class="keyword">const</span> clear = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    timeout.<span class="property">current</span> &amp;&amp; <span class="built_in">clearTimeout</span>(timeout.<span class="property">current</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isPreventDefault &amp;&amp; target.<span class="property">current</span>) &#123;</span><br><span class="line">      <span class="title function_">off</span>(target.<span class="property">current</span>, <span class="string">&#x27;touchend&#x27;</span>, preventDefault);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [isPreventDefault]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回的对象可以直接解构赋值给目标元素</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">onMouseDown</span>: <span class="function">(<span class="params">e: any</span>) =&gt;</span> <span class="title function_">start</span>(e),</span><br><span class="line">    <span class="attr">onTouchStart</span>: <span class="function">(<span class="params">e: any</span>) =&gt;</span> <span class="title function_">start</span>(e),</span><br><span class="line">    <span class="attr">onMouseUp</span>: clear,</span><br><span class="line">    <span class="attr">onMouseLeave</span>: clear,</span><br><span class="line">    <span class="attr">onTouchEnd</span>: clear,</span><br><span class="line">  &#125; <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useLongPress;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>使用示例</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useLongPress &#125; <span class="keyword">from</span> <span class="string">&#x27;./useLongPress&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Demo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onLongPress</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;calls callback after long pressing 300ms&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> defaultOptions = &#123;</span><br><span class="line">    <span class="attr">isPreventDefault</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">delay</span>: <span class="number">300</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> longPressEvent = <span class="title function_">useLongPress</span>(onLongPress, defaultOptions);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直接解构赋值给元素</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> &#123;<span class="attr">...longPressEvent</span>&#125;&gt;</span>useLongPress<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="useMeasure"><a href="#useMeasure" class="headerlink" title="useMeasure"></a>useMeasure</h2><p><code>useMeasure</code>用于测量一个DOM元素的尺寸和位置，并在尺寸或位置变化时更新这些信息。这个Hook依赖于<code>ResizeObserver API</code>，它允许你监听一个元素的大小变化。</p>
<blockquote>
<p><code>ResizeObserver</code>是一个强大的Web API，允许开发者监听HTML元素的尺寸变化。</p>
</blockquote>
<p><strong>基本用法</strong></p>
<p>使用<code>ResizeObserver</code>创建一个observer实例，并给它提供一个回调函数，该函数会在被观察元素的尺寸位置发生变化时被调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resizeObserver = <span class="keyword">new</span> <span class="title class_">ResizeObserver</span>(<span class="function"><span class="params">entries</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> entries) &#123;</span><br><span class="line">    <span class="comment">// 从 entry.contentRect 中获取元素的尺寸位置信息</span></span><br><span class="line">    <span class="keyword">const</span> &#123; width, height &#125; = entry.<span class="property">contentRect</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Element:&#x27;</span>, entry.<span class="property">target</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Element size: <span class="subst">$&#123;width&#125;</span>px x <span class="subst">$&#123;height&#125;</span>px`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设有一个元素是这样的：&lt;div id=&quot;myElement&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">const</span> myElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myElement&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始观察myElement元素</span></span><br><span class="line">resizeObserver.<span class="title function_">observe</span>(myElement);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止观察某一个元素</span></span><br><span class="line">resizeObserver.<span class="title function_">unobserve</span>(myElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止观察所有元素并释放资源</span></span><br><span class="line">resizeObserver.<span class="title function_">disconnect</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>源码及解析如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useMemo, useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; isBrowser, noop &#125; <span class="keyword">from</span> <span class="string">&#x27;./misc/util&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">UseMeasureRect</span> = <span class="title class_">Pick</span>&lt;</span><br><span class="line">  <span class="title class_">DOMRectReadOnly</span>,</span><br><span class="line">  <span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span> | <span class="string">&#x27;top&#x27;</span> | <span class="string">&#x27;left&#x27;</span> | <span class="string">&#x27;right&#x27;</span> | <span class="string">&#x27;bottom&#x27;</span> | <span class="string">&#x27;height&#x27;</span> | <span class="string">&#x27;width&#x27;</span></span><br><span class="line">&gt;;</span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">UseMeasureRef</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Element</span> = <span class="title class_">Element</span>&gt; = <span class="function">(<span class="params">element: E</span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">UseMeasureResult</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Element</span> = <span class="title class_">Element</span>&gt; = [<span class="title class_">UseMeasureRef</span>&lt;E&gt;, <span class="title class_">UseMeasureRect</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义默认设置</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">defaultState</span>: <span class="title class_">UseMeasureRect</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">width</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">top</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">left</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">bottom</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">right</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> useMeasure&lt;E <span class="keyword">extends</span> <span class="title class_">Element</span> = <span class="title class_">Element</span>&gt;(): <span class="title class_">UseMeasureResult</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="comment">// element用于存储对DOM元素的引用</span></span><br><span class="line">  <span class="keyword">const</span> [element, ref] = useState&lt;E | <span class="literal">null</span>&gt;(<span class="literal">null</span>);</span><br><span class="line">  <span class="comment">// rect用于存储测量的结果</span></span><br><span class="line">  <span class="keyword">const</span> [rect, setRect] = useState&lt;<span class="title class_">UseMeasureRect</span>&gt;(defaultState);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个监听器函数，当被监听元素尺寸位置发生变化时，设置并返回新的位置尺寸信息</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="title function_">useMemo</span>(</span><br><span class="line">    <span class="function">() =&gt;</span></span><br><span class="line">      <span class="keyword">new</span> (<span class="variable language_">window</span> <span class="keyword">as</span> any).<span class="title class_">ResizeObserver</span>(<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (entries[<span class="number">0</span>]) &#123;</span><br><span class="line">          <span class="keyword">const</span> &#123; x, y, width, height, top, left, bottom, right &#125; = entries[<span class="number">0</span>].<span class="property">contentRect</span>;</span><br><span class="line">          <span class="title function_">setRect</span>(&#123; x, y, width, height, top, left, bottom, right &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;),</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!element) <span class="keyword">return</span>;</span><br><span class="line">    observer.<span class="title function_">observe</span>(element);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      observer.<span class="title function_">disconnect</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [element]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回ref回调函数 可以将它绑定到元素的ref属性上，React会在组件挂载时将DOM元素作为参数传递给该ref回调函数</span></span><br><span class="line">  <span class="comment">// 以及 rect对象（包含了元素的尺寸和位置信息）</span></span><br><span class="line">  <span class="keyword">return</span> [ref, rect];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浏览器兼容性处理</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> isBrowser &amp;&amp; <span class="keyword">typeof</span> (<span class="variable language_">window</span> <span class="keyword">as</span> any).<span class="property">ResizeObserver</span> !== <span class="string">&#x27;undefined&#x27;</span></span><br><span class="line">  ? useMeasure</span><br><span class="line">  : ((<span class="function">() =&gt;</span> [noop, defaultState]) <span class="keyword">as</span> <span class="keyword">typeof</span> useMeasure);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="useMouse"><a href="#useMouse" class="headerlink" title="useMouse"></a>useMouse</h2><p><code>useMouse</code>用于动态跟踪鼠标的位置</p>
<p>源码及解析如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RefObject</span>, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> useRafState <span class="keyword">from</span> <span class="string">&#x27;./useRafState&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; off, on &#125; <span class="keyword">from</span> <span class="string">&#x27;./misc/util&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface <span class="title class_">State</span> &#123;</span><br><span class="line">  <span class="attr">docX</span>: number; <span class="comment">// 鼠标的X坐标相对于整个文档（document）的位置</span></span><br><span class="line">  <span class="attr">docY</span>: number; <span class="comment">// 鼠标的Y坐标相对于整个文档的位置</span></span><br><span class="line">  <span class="attr">posX</span>: number; <span class="comment">// 目标元素的X坐标相对于其定位上下文（positioning context）的位置</span></span><br><span class="line">  <span class="attr">posY</span>: number; <span class="comment">// 目标元素的Y坐标相对于其定位上下文的位置</span></span><br><span class="line">  <span class="attr">elX</span>: number; <span class="comment">// 鼠标的X坐标相对于目标元素（offset parent）的位置</span></span><br><span class="line">  <span class="attr">elY</span>: number; <span class="comment">// 鼠标的Y坐标相对于目标元素（offset parent）的位置</span></span><br><span class="line">  <span class="attr">elH</span>: number; <span class="comment">// 目标元素自身的高度</span></span><br><span class="line">  <span class="attr">elW</span>: number; <span class="comment">// 目标元素自身的宽度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useMouse = (<span class="attr">ref</span>: <span class="title class_">RefObject</span>&lt;<span class="title class_">Element</span>&gt;): <span class="function"><span class="params">State</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useRafState&lt;<span class="title class_">State</span>&gt;(&#123;</span><br><span class="line">    <span class="attr">docX</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">docY</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">posX</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">posY</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">elX</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">elY</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">elH</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">elW</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">moveHandler</span> = (<span class="params">event: MouseEvent</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 如果已经绑定了元素的ref属性</span></span><br><span class="line">      <span class="keyword">if</span> (ref &amp;&amp; ref.<span class="property">current</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; left, top, <span class="attr">width</span>: elW, <span class="attr">height</span>: elH &#125; = ref.<span class="property">current</span>.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line">        <span class="comment">// window.pageXOffset 表示当前文档水平滚动的距离</span></span><br><span class="line">        <span class="keyword">const</span> posX = left + <span class="variable language_">window</span>.<span class="property">pageXOffset</span>;</span><br><span class="line">        <span class="keyword">const</span> posY = top + <span class="variable language_">window</span>.<span class="property">pageYOffset</span>;</span><br><span class="line">        <span class="keyword">const</span> elX = event.<span class="property">pageX</span> - posX;</span><br><span class="line">        <span class="keyword">const</span> elY = event.<span class="property">pageY</span> - posY;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">setState</span>(&#123;</span><br><span class="line">          <span class="attr">docX</span>: event.<span class="property">pageX</span>,</span><br><span class="line">          <span class="attr">docY</span>: event.<span class="property">pageY</span>,</span><br><span class="line">          posX,</span><br><span class="line">          posY,</span><br><span class="line">          elX,</span><br><span class="line">          elY,</span><br><span class="line">          elH,</span><br><span class="line">          elW,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">on</span>(<span class="variable language_">document</span>, <span class="string">&#x27;mousemove&#x27;</span>, moveHandler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">off</span>(<span class="variable language_">document</span>, <span class="string">&#x27;mousemove&#x27;</span>, moveHandler);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [ref]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useMouse;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="usePageLeave"><a href="#usePageLeave" class="headerlink" title="usePageLeave"></a>usePageLeave</h2><p><code>usePageLeave</code> 用于当鼠标离开页面时触发一个回调</p>
<blockquote>
<p><code>event.relatedTarget</code> 和 <code>event.toElement</code></p>
</blockquote>
<p>浏览器默认事件对象中的属性，<code>relatedTarget</code>属性是一个事件属性，它在某些特定的事件中提供了关于事件的额外上下文。这个属性特别用于鼠标事件，比如mouseover和mouseout，以及焦点事件，比如focusin和focusout。</p>
<p>relatedTarget属性引用了与事件相关的一个DOM元素</p>
<p>对于<strong>鼠标事件</strong>：</p>
<ul>
<li>在mouseover事件中，<code>relatedTarget</code>属性引用的是鼠标刚刚离开的那个元素，即鼠标指针之前所在的元素。</li>
<li>在mouseout事件中，<code>relatedTarget</code>属性引用的是鼠标即将移动到的那个元素，即鼠标指针即将进入的元素。</li>
</ul>
<p>对于<strong>焦点事件</strong>：</p>
<p>在focusin（或focus）事件中，<code>relatedTarget</code>属性引用的是失去焦点的元素，即焦点从哪个元素移开。<br>在focusout（或blur）事件中，<code>relatedTarget</code>属性引用的是即将获得焦点的元素，即焦点将要移到哪个元素上。</p>
<p><code>toElement</code>的作用与<code>relatedTarget</code>相似，特别是在mouseover和mouseout事件上，用于兼容旧版本浏览器</p>
<p>源码及解析如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; off, on &#125; <span class="keyword">from</span> <span class="string">&#x27;./misc/util&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">usePageLeave</span> = (<span class="params">onPageLeave, args = []</span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!onPageLeave) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handler</span> = (<span class="params">event</span>) =&gt; &#123;</span><br><span class="line">      event = event ? event : (<span class="variable language_">window</span>.<span class="property">event</span> <span class="keyword">as</span> any);</span><br><span class="line">      <span class="comment">// from 保存了鼠标即将移动到的元素</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">from</span> = event.<span class="property">relatedTarget</span> || event.<span class="property">toElement</span>;</span><br><span class="line">      <span class="comment">// 鼠标是否离开浏览器文档页面时触发回调</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">from</span> || (<span class="keyword">from</span> <span class="keyword">as</span> any).<span class="property">nodeName</span> === <span class="string">&#x27;HTML&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">onPageLeave</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">on</span>(<span class="variable language_">document</span>, <span class="string">&#x27;mouseout&#x27;</span>, handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">off</span>(<span class="variable language_">document</span>, <span class="string">&#x27;mouseout&#x27;</span>, handler);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, args);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> usePageLeave;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="useClickAway"><a href="#useClickAway" class="headerlink" title="useClickAway"></a>useClickAway</h2><p><code>useClickAway</code>用于当用户在目标元素外部单击时触发回调</p>
<p>源码及解析如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RefObject</span>, useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; off, on &#125; <span class="keyword">from</span> <span class="string">&#x27;./misc/util&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultEvents = [<span class="string">&#x27;mousedown&#x27;</span>, <span class="string">&#x27;touchstart&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ref：目标对象的ref引用</span></span><br><span class="line"><span class="comment"> * onClickAway：传入的回调函数</span></span><br><span class="line"><span class="comment"> * events：需要绑定的事件类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> useClickAway = &lt;E <span class="keyword">extends</span> <span class="title class_">Event</span> = <span class="title class_">Event</span>&gt;<span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  ref: RefObject&lt;HTMLElement | <span class="literal">null</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  onClickAway: (event: E) =&gt; <span class="keyword">void</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  events: string[] = defaultEvents</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 缓存传入的回调函数</span></span><br><span class="line">  <span class="keyword">const</span> savedCallback = <span class="title function_">useRef</span>(onClickAway);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    savedCallback.<span class="property">current</span> = onClickAway;</span><br><span class="line">  &#125;, [onClickAway]);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handler</span> = (<span class="params">event</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">current</span>: el &#125; = ref;</span><br><span class="line">      <span class="comment">// el 是对DOM元素的引用</span></span><br><span class="line">      <span class="comment">// 如果 el存在 并且 当前触发事件的元素不是el及其子孙节点 则 执行传入的回调函数</span></span><br><span class="line">      <span class="comment">// contains 方法是用来测试一个节点是否是另一个节点的后代。如果目标元素在 el 之外，contains 方法会返回 false，取反后为 true</span></span><br><span class="line">      el &amp;&amp; !el.<span class="title function_">contains</span>(event.<span class="property">target</span>) &amp;&amp; savedCallback.<span class="title function_">current</span>(event);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 绑定用户传入的所有事件类型</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> eventName <span class="keyword">of</span> events) &#123;</span><br><span class="line">      <span class="title function_">on</span>(<span class="variable language_">document</span>, eventName, handler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> eventName <span class="keyword">of</span> events) &#123;</span><br><span class="line">        <span class="title function_">off</span>(<span class="variable language_">document</span>, eventName, handler);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [events, ref]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useClickAway;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/React-Hooks/">React Hooks</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/03/29/useContext/"><span>useContext</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/03/29/useContext/" rel="bookmark">
        <time class="entry-date published" datetime="2024-03-29T12:59:23.000Z">
          2024-03-29
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="context"><a href="#context" class="headerlink" title="context"></a><code>context</code></h2><p>在开发中，父组件可能需要通过多层中间组件将 props 传递给某个子孙组件，这个传递 props 的过程就会变得十分冗长</p>
<p><code>context</code>可以在组件树中<strong>不需要</strong>props 传递数据，而是将数据<strong>直达</strong>所需的组件</p>
<p><code>context</code>可以让父组件为其<strong>内部的整个组件树人</strong>提供数据</p>
<h2 id="使用context"><a href="#使用context" class="headerlink" title="使用context"></a>使用<code>context</code></h2><p>使用<code>context</code>需要三个步骤：</p>
<ul>
<li>创建一个<code>context</code></li>
<li>在需要数据的组件中使用创建的<code>context</code></li>
<li>在指定数据的组件中提供<code>context</code></li>
</ul>
<h3 id="创建一个context"><a href="#创建一个context" class="headerlink" title="创建一个context"></a>创建一个<code>context</code></h3><p>新建一个 js 文件，在其中创建<code>constext</code>并导出他</p>
<p>使用<code>createContext()</code>来创建一个 context，需要给他传入一个默认值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title function_">createContext</span>(<span class="number">1</span>); <span class="comment">// 创建并导出一个context</span></span><br></pre></td></tr></table></figure>

<h3 id="使用context-1"><a href="#使用context-1" class="headerlink" title="使用context"></a>使用<code>context</code></h3><p>在需要用到数据的组件中，引入<code>useContext</code>Hook 以及 创建的<code>context</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">MyContext</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./MyContext.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>) [</span><br><span class="line">  <span class="keyword">const</span> context = <span class="title function_">useContext</span>(<span class="title class_">MyContext</span>) <span class="comment">// useContext 告诉 React 想要读取 myContext</span></span><br><span class="line">  <span class="comment">// 现在，得到的context就是myContext的默认值</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="提供context"><a href="#提供context" class="headerlink" title="提供context"></a>提供<code>context</code></h3><p>在父组件中使用<code>context provider</code>将子组件包裹起来，就可以提供<code>context</code>给他们</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">MyContext</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./MyContext.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> [ name, setName ] = <span class="title function_">useState</span>(<span class="string">&#x27;easy code sniper&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;MyContext.Provider value=&#123;name&#125;&gt;</span><br><span class="line">      &lt;MyContext.Provider&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这告诉 React：“如果在<code>Parent</code>组件中的任何子组件请求<code>MyContext</code>，给他们这个<code>name</code>。”<br>组件会使用 UI 树中在它上层最近的那个<code>MyContext.Provider</code>传递过来的值。</p>
<h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a><code>useContext</code></h2><p><strong>语法：</strong><code>const value = useContext(SomeContext)</code></p>
<ul>
<li><code>SomeContext</code>就是先前用<code>createContext</code>创建的 context，context 本身不包含信息，它只代表你可以提供或从组件中读取的信息类型。</li>
</ul>
<p><strong>返回值</strong></p>
<p><code>useContext</code>为调用它的组件返回 context 的值。它的返回值被确定为传递给树中调用组件上方最近的<code>SmeContext.Provider</code>的<code>value</code>。<br>如果没有这样的 provider，那么返回值将会是为创建该 context 传递给<code>createContext</code>的<code>defaultValue</code>。返回的值始终是最新的，如果 context 发生变化，React 会自动重新渲染读取 context 的组件。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/React-Hooks/">React Hooks</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/03/26/设计模式浅谈/"><span>设计模式浅谈</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/03/26/设计模式浅谈/" rel="bookmark">
        <time class="entry-date published" datetime="2024-03-26T13:01:25.000Z">
          2024-03-26
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态的含义是：同一操作作用于不同对象上，可以产生不同的解释和不同的执行结果。也就是说，给不同的对象发送同一个消息，对象会做出不同的反馈</p>
<p>下面的代码就体现着多态性，当我们分别向程序员和老师发出工作的消息时，他们根据此作出了不同的反应</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> work = <span class="keyword">function</span> (<span class="params">person</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(person <span class="keyword">instanceof</span> <span class="title class_">Coder</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;coding&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (person <span class="keyword">instanceof</span> <span class="title class_">Teacher</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;teaching&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Coder</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Teacher</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">work</span>(<span class="keyword">new</span> <span class="title class_">Coder</span>()) <span class="comment">// coding</span></span><br><span class="line"><span class="title function_">work</span>(<span class="keyword">new</span> <span class="title class_">Teacher</span>()) <span class="comment">// teaching</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但这样的多态性无法令人满意，如果现在要新增一个司机类型，那我们就需要修改work函数的代码。修改的代码越多，就存在越多的危险，并且work函数也会随着类型的变多成为一个巨大的函数</p>
<p>多态背后的思想是：将<strong>做什么</strong>与<strong>谁去做怎么做</strong>分离开来。<br>在上面的例子中，人都会工作，但是不同的人怎么工作是不同的。把不变的部分隔离出来，把可变的部分封装起来，这就给予了我们扩展程序的能力。</p>
<p>通过下面的改动，将不变的部分隔离出来，那就是所有人都会工作。然后把可变的部分各自封装起来</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> work = <span class="keyword">function</span> (<span class="params">person</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(person.<span class="property">work</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span>) &#123;</span><br><span class="line">    person.<span class="title function_">work</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Coder</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">Coder</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">work</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;coding&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Teacher</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">Teacher</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">work</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;teaching&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">work</span>(<span class="keyword">new</span> <span class="title class_">Coder</span>())</span><br><span class="line"><span class="title function_">work</span>(<span class="keyword">new</span> <span class="title class_">Teacher</span>())</span><br></pre></td></tr></table></figure>

<p>与静态语言类型不同的是，JavaScript的变量类型在运行期是可变的。一个JavaScript对象，既可以是<code>Coder</code>类型，也可以是<code>Teacher</code>类型。这就意味着<strong>JavaScript对象的多态性是与生俱来的</strong></p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装的目的是将信息隐藏，封装可以是<strong>对任何形式内容的封装</strong>。也就是说，封装不仅仅是隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型等</p>
<p>封装使得对象内部的变化对其他对象而言是透明的，其他对象也不关心它的内部实现。</p>
<p><strong>封装变化</strong></p>
<p>通过封装变化的方式，把系统中稳定不变的部分和易于变化的部分隔离开来，我们只需要替换易于变化的部分。这可以很大程度上保证程序的稳定性和可扩展性</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>在以类为中心的面向对象编程语言中，对象总是从类中创建出来的。而在原型编程的思想中，类不是必须的，对象也未必需要从类中创建出来。一个对象是通过克隆另一个对象所得到的。</p>
<p>原型模式的关键在于<strong>通过克隆来创建对象</strong>，即语言本身是否提供了clone方法。在ES5中提供了<code>Object.create</code>方法来克隆对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;easy code sniper&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clonePerson = <span class="title class_">Object</span>.<span class="title function_">create</span>( person )</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(clonePerson) <span class="comment">// &#123; name: &#x27;easy code sniper&#x27;, age: 22 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="JavaScript中的原型继承"><a href="#JavaScript中的原型继承" class="headerlink" title="JavaScript中的原型继承"></a>JavaScript中的原型继承</h3><p>JavaScript遵循原型编程的基本规则：</p>
<ul>
<li>所有的数据都是对象</li>
<li>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它</li>
<li>对象会记住它的原型</li>
<li>如果对象无法响应某个请求，它会把这个请求委托给自己的原型</li>
</ul>
<p><strong>1.所有的数据都是对象</strong></p>
<p>JavaScript有两种类型机制：基本类型 和 对象类型</p>
<p>基于一切都应该是对象的本意（除了undefined之外），基本类型数据可以通过包装类的方式变成对象类型数据</p>
<p>JavaScript中的根对象是<code>Object.prototype</code>对象，<code>Object.prototype</code>对象是一个空的对象。在JS中遇到的每个对象，实际都是从<code>Object.prototype</code>对象克隆而来的</p>
<p><strong>2.要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它</strong></p>
<p>在JavaScript中我们不需要关心克隆的细节，只是显式地调用<code>let obj = new Object()</code>或<code>let obj = &#123;&#125;</code>，引擎内部会从<code>Object.prototype</code>上面克隆一个对象出来</p>
<p>JavaScript的函数集可以作为普通函数被调用，也可以作为构造器被调用。当使用<code>new</code>运算符来调用函数时，此时的函数就是一个构造器。用<code>new</code>运算符来创建对象的过程，实际上也只是先克隆<code>Object.prototype</code>对象，再进行一些其他额外操作的过程</p>
<p>模拟<code>new</code>创建对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> objectFactory = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>() <span class="comment">// 先克隆一个空对象</span></span><br><span class="line">    <span class="title class_">Constructor</span> = [].<span class="property">shift</span>.<span class="title function_">call</span>( <span class="variable language_">arguments</span> ) <span class="comment">// 取出参数中的第一项，即外部传入的构造器</span></span><br><span class="line">    obj.<span class="property">__proto__</span> = <span class="title class_">Constructor</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// 指向正常的原型</span></span><br><span class="line">    <span class="keyword">let</span> ret = <span class="title class_">Constructor</span>.<span class="title function_">apply</span>(obj, <span class="variable language_">arguments</span>) <span class="comment">// 基于剩余的arguments给obj设置属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">&#x27;object&#x27;</span> ? ret : obj <span class="comment">// 确保构造器总是返回一个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="title function_">objectFactory</span>(<span class="title class_">Person</span>, <span class="string">&#x27;easy code sniper&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a.<span class="property">name</span> ); <span class="comment">// easy code sniper</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a.<span class="title function_">getName</span>() ); <span class="comment">// easy code sniper</span></span><br></pre></td></tr></table></figure>

<p><strong>3.对象会记住它的原型</strong></p>
<p>JavaScript给对象提供一个<code>__proto__</code>属性，某个对象的<code>__proto__</code>属性默认会指向它的构造器的原型对象，即<code>Constructor.prototype</code></p>
<p><code>__proto__</code>就是 对象 和 对象构造器的原型 联系起来的纽带。这就是我们在<code>objectFactory</code>函数中需要手动给obj对象设置正确的<code>__proto__</code>指向</p>
<h2 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h2><p>this 的指向大致可以分为 4 种情况：</p>
<ul>
<li>作为对象的方法调用</li>
<li>作为普通函数调用</li>
<li>构造器调用</li>
<li><code>call</code> 和 <code>apply</code> 调用</li>
</ul>
<h3 id="作为对象的方法调用"><a href="#作为对象的方法调用" class="headerlink" title="作为对象的方法调用"></a>作为对象的方法调用</h3><p>当函数作为对象的方法被调用时，this 指向该对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;easy code sniper&quot;</span>,</span><br><span class="line">  <span class="attr">getName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === obj); <span class="comment">// true</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// easy code sniper</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">getName</span>();</span><br></pre></td></tr></table></figure>

<h3 id="作为普通函数调用"><a href="#作为普通函数调用" class="headerlink" title="作为普通函数调用"></a>作为普通函数调用</h3><p>当函数作为普通函数被调用时，this 指向全局对象。在浏览器中，全局对象就是 window；在 Node 环境中，全局对象就是 globalThis</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">globalThis.<span class="property">name</span> = <span class="string">&quot;easy code sniper&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>(); <span class="comment">// easy code sniper</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line">globalThis.<span class="property">name</span> = <span class="string">&quot;cqy&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;easy code sniper&quot;</span>,</span><br><span class="line">  <span class="attr">getName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === obj); <span class="comment">// false</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// cqy</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func = obj.<span class="property">getName</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>();</span><br></pre></td></tr></table></figure>

<h3 id="构造器调用"><a href="#构造器调用" class="headerlink" title="构造器调用"></a>构造器调用</h3><p>除了一些内置函数，大部分 JS 函数都可以当作构造器使用。当使用 new 运算符调用函数时，该函数总是返回一个对象，通常情况下，构造器里的 this 就<strong>指向返回的对象</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Func</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;easy code sniper&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Func</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// easy code sniper</span></span><br></pre></td></tr></table></figure>

<p>如果构造器显式的返回一个对象，那么返回的将会是这个对象，this也会指向这个对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Func</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;easy code sniper&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;cqy&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Func</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// cqy</span></span><br></pre></td></tr></table></figure>


<h2 id="call-和-apply"><a href="#call-和-apply" class="headerlink" title="call 和 apply"></a>call 和 apply</h2><p><code>Function.prototype.call</code>和<code>Function.prototype.apply</code>是定义在Function的原型上的两个方法，用于动态的改变this指向</p>
<p>call和apply的作用一模一样，区别仅在于传入参数的形式不同：</p>
<ul>
<li>apply接受两个参数，第一个参数指定函数体内this的指向，第二个参数会作为参数传递给被调用的函数，类型为数组或类数组</li>
<li>call传入参数数量不固定，第一个参数指定函数体内this的指向，从第二个参数开始往后，每个参数被依次传入函数</li>
</ul>
<p>当使用call或者apply的时候，如果传入的第一个参数为null，函数体内的this会指向默认的宿主对象，在浏览器中则是window</p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p><strong>1.改变this指向</strong></p>
<p>call和apply最常见的用途是改变函数内部的this指向</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;easy code sniper&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;cqy&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getName = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getName</span>() <span class="comment">// window</span></span><br><span class="line">getName.<span class="title function_">call</span>(obj1) <span class="comment">// easy code sniper</span></span><br><span class="line">getName.<span class="title function_">call</span>(obj2) <span class="comment">// cqy</span></span><br></pre></td></tr></table></figure>

<p><strong>2.Function.prototype.bind</strong></p>
<p>大部分高级浏览器都实现了内置的<code>Function.prototype.bind</code>，用来指定函数内部的this指向，即使没有原生的<code>Function.prototype.bind</code>实现，也可以使用call或者apply模拟</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span> <span class="comment">// 保存调用bind的原函数</span></span><br><span class="line">  context = [].<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>) <span class="comment">// 借用数组的shift方法拿到arguments的第一项，即需要指向的this</span></span><br><span class="line">  args = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>) <span class="comment">// 将剩余参数转化为数组</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 指定this为之前传入的context</span></span><br><span class="line">    <span class="comment">// 合并两次传入的参数，作为新函数的参数</span></span><br><span class="line">    <span class="keyword">return</span> self.<span class="title function_">apply</span>(context, [].<span class="property">concat</span>.<span class="title function_">call</span>(args, [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;cqy&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func = <span class="keyword">function</span>(<span class="params">a,b,c,d</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>([a,b,c,d])</span><br><span class="line">&#125;.<span class="title function_">bind</span>(obj, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 输出：cqy [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p><strong>3.借用其他对象的方法</strong></p>
<p>借用方法较为常见的就是：<br>函数的参数列表arguments是一个类数组对象，它并非真正的数组，所以不能像数组一样，进行排序操作或者往集合里添加一个新的元素。我们常常会借用<code>Array.prototype</code>对象上的方法</p>
<p>比如想往arguments中添加一个新的元素，通常借用<code>Array.prototype.push</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure>

<p>在操作arguments的时候，我们经常非常频繁地找<code>Array.prototype</code>对象借用方法。<br>想把arguments转成真正的数组的时候，可以借用<code>Array.prototype.slice</code>方法;想截去arguments列表中的头一个元素时，又可以借用<code>Array.prototype.shift</code>方法。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><strong>变量的作用域</strong></p>
<p>在JS中，函数可以用来创造函数作用域。函数就像一层半透明的玻璃，在函数里面可以看到外面的便利，而在函数外面则无法看到函数里面的变量。</p>
<p>这是因为当在函数中搜索一个变量的时候，如果该函数内并没有声明这个变量，那么此次搜索的过程会随着代码执行环境创建的作用域链往外层逐层搜索，一直搜索到全局对象为止。变量的搜索是<strong>从内到外</strong>的。</p>
<p><strong>变量的生存周期</strong></p>
<p>对于全局变量来说，生存周期是永久的，除非主动销毁这个全局变量</p>
<p>对于函数内的局部变量来说，当退出函数时，这些局部变量就失去了他们价值，随着函数调用的结束而销毁</p>
<p>退出函数后局部变量a将被销毁</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>

<p>再看看下面这段代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    a++</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="title function_">func</span>()</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，退出函数之后，局部变量a并没有消失。当执行<code>let f = func()</code>时，f拿到一个匿名函数的引用，它可以访问到func被调用时产生的环境，而局部变量a一直处在这个环境里。</p>
<p>既然局部变量所在的环境还能被外界访问，这个局部变量就有了不被销毁的理由。在这里产生了一个闭包结构，局部变量的生命看起来被延续了。</p>
<h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><p><strong>封装变量</strong></p>
<p>闭包可以帮助把一些不需要暴露在全局的变量封装成‘私有变量’，例如下面有一个计算参数乘积的简单函数，并使用全局的cache变量缓存结果来提高性能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cache = &#123;&#125; <span class="comment">// 缓存结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mult = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">join</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="string">&#x27;,&#x27;</span>) <span class="comment">// 将参数拼接成字符串，作为cache中的属性名</span></span><br><span class="line">  <span class="keyword">if</span>( cache[args] ) &#123; <span class="comment">// 如果命中缓存就返回结果</span></span><br><span class="line">    <span class="keyword">return</span> cache[args]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++ ) &#123;</span><br><span class="line">    a *= <span class="variable language_">arguments</span>[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cache[args] = a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cache变量仅在mult函数中被使用，与其让他暴露在全局作用域下，不如将它封闭在mult函数内部</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mult = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> cache = &#123;&#125; <span class="comment">// 将cache封装在mult里面</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">join</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="string">&#x27;,&#x27;</span>) <span class="comment">// 将参数拼接成字符串，作为cache中的属性名</span></span><br><span class="line">    <span class="keyword">if</span>( cache[args] ) &#123; <span class="comment">// 如果命中缓存就返回结果</span></span><br><span class="line">      <span class="keyword">return</span> cache[args]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++ ) &#123;</span><br><span class="line">      a *= <span class="variable language_">arguments</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[args] = a</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数是指至少满足下列条件之一的函数：</p>
<ul>
<li>函数可以作为参数被传递</li>
<li>函数可以作为返回值输出</li>
</ul>
<h3 id="函数作为参数传递"><a href="#函数作为参数传递" class="headerlink" title="函数作为参数传递"></a>函数作为参数传递</h3><p>将函数作为参数进行传递，一个很重要的应用场景就是回调函数。这代表我们将容易变化的业务逻辑抽离出来，把这部分业务逻辑放在函数参数中，这样一来可以分离业务代码中变化与不变的部分</p>
<p>比如我们想在页面中创建一个div节点，然后给这个节点设置一些样式，下面是一种编写代码的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> appendDiv = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">  div.<span class="property">innerHTML</span> = <span class="string">&#x27;我是一个div&#x27;</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div)</span><br><span class="line">  div.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span> <span class="comment">// 设置样式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把<code>div.style.display = &#39;none&#39;</code>的逻辑硬编码在appendDiv里显然不太合理，这使得appendDiv有点太个性化里，成为了一个难以敷用的函数。</p>
<p>如果把<code>div.style.display = &#39;none&#39;</code>的逻辑抽离出来，用回调函数的形式传入appendDiv，这样appendDiv只要专注于创建节点就行了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> appendDiv = <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">  div.<span class="property">innerHTML</span> = <span class="string">&#x27;我是一个div&#x27;</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div)</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>)   &#123;</span><br><span class="line">    <span class="title function_">callback</span>(div)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">appendDiv</span>(<span class="keyword">function</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  node.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>除此之外，<code>Array.prototype.sort</code>方法接受一个函数作为参数，这个函数里面封装了数组元素的排序规则。排序规则是可变的，把可变的封装在函数参数里。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>].<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1, 3, 5</span></span><br></pre></td></tr></table></figure>

<h3 id="函数作为返回值输出"><a href="#函数作为返回值输出" class="headerlink" title="函数作为返回值输出"></a>函数作为返回值输出</h3><p>让函数返回一个可执行的函数，意味着运算过程是可延续的，更能体现函数式编程的巧妙</p>
<p><strong>1.判断数据的类型</strong></p>
<p>要判断数据类型，更好的方法是用<code>Object.prototype.toString</code>来计算，<code>Object.prototype.toString.call(obj)</code>返回一个字符串</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isString = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object String]&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isArray = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object Array]&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isNumber = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object Number]&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isObject = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object Object]&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些函数的发部分实现都是相同的，不同的是判断部分。为了避免多余的代码，我们可以把这些代表数据类型的字符串作为参数提前传入<code>isType</code>函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isType = <span class="keyword">function</span>(<span class="params">type</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isString = <span class="title function_">isType</span>(<span class="string">&#x27;String&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> isArray = <span class="title function_">isType</span>(<span class="string">&#x27;Array&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> isNumber = <span class="title function_">isType</span>(<span class="string">&#x27;Number&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> isObject = <span class="title function_">isType</span>(<span class="string">&#x27;Object&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="高阶函数的其他应用"><a href="#高阶函数的其他应用" class="headerlink" title="高阶函数的其他应用"></a>高阶函数的其他应用</h3><p><strong>1.函数柯里化（currying）</strong></p>
<p>一个currying的函数首先会接受一些参数，接受了这些参数后，该函数不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数真正需要求值的时候，之前传入的所有参数都会被一次性用于求值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于将函数进行柯里化</span></span><br><span class="line"><span class="comment"> * 接受一个参数：即将要被currying的函数 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> currying = <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [].<span class="property">push</span>.<span class="title function_">apply</span>(args, <span class="variable language_">arguments</span>)</span><br><span class="line">        <span class="comment">// arguments.callee 是一个在函数内部可用的属性，它指向当前正在执行的函数。这在匿名函数中特别有用，因为它允许你引用函数本身，而不需要知道函数的名字。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">arguments</span>.<span class="property">callee</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      res += <span class="variable language_">arguments</span>[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将sum函数进行柯里化</span></span><br><span class="line"><span class="keyword">let</span> curryingSum = <span class="title function_">currying</span>(sum)</span><br><span class="line"></span><br><span class="line"><span class="title function_">curryingSum</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">curryingSum</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">curryingSum</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curryingSum</span>()); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p><strong>2.函数节流</strong></p>
<p>函数有可能被非常频繁地调用，而造成大的性能问题。函数节流的原理：将即将要被执行的函数用setTimeout延迟一段时间执行。如果该次延迟执行还没有完成，则忽略接下来调用该函数的请求</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流函数</span></span><br><span class="line"><span class="comment"> * fn：需要被延迟执行的函数</span></span><br><span class="line"><span class="comment"> * interval：延迟执行的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> throttle = <span class="keyword">function</span>(<span class="params">fn, interval</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> _self = fn <span class="comment">// 保存被延迟执行的函数引用</span></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span> <span class="comment">// 定时器</span></span><br><span class="line">  <span class="keyword">let</span> firstTime = <span class="literal">true</span> <span class="comment">// 是否是第一次调用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="variable language_">arguments</span></span><br><span class="line">    <span class="keyword">let</span> _me = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(firstTime) &#123; <span class="comment">// 如果是第一次调用，不需要延迟执行</span></span><br><span class="line">      _self.<span class="title function_">apply</span>(_me, args)</span><br><span class="line">      <span class="keyword">return</span> firstTime = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(timer) &#123; <span class="comment">// 前一次延迟执行还没有完成，忽略此次请求</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 延迟一段时间执行</span></span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">      timer = <span class="literal">null</span></span><br><span class="line">      _self.<span class="title function_">apply</span>(_me, args)</span><br><span class="line">    &#125;, interval || <span class="number">500</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例：监听浏览器尺寸变化</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onresize</span> = <span class="title function_">throttle</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br></pre></td></tr></table></figure>

<p><strong>3.分时函数</strong></p>
<p>某些函数是用户主动调用的，但因为一些客观原因，这些函数会严重影响页面性能</p>
<p>例如我们要在页面上渲染1000个div节点，在短时间内往页面中大量添加DOM节点会导致浏览器卡顿甚至假死</p>
<p>解决方案之一就是将创建节点的工作分批进行。比如把1秒创建1000个节点，改为每隔200毫秒创建8个节点</p>
<p>设计一个<code>timeChunk</code>函数来分批创建节点，函数接受3个参数：</p>
<ul>
<li>ary：创建节点时需要用到的原始数据</li>
<li>fn：封装了创建节点逻辑的函数</li>
<li>count：每一批创建的节点数量</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timeChunk = <span class="keyword">function</span>(<span class="params">ary, fn, count</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> obj, timer</span><br><span class="line">  <span class="keyword">let</span> len = ary.<span class="property">length</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> start = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="title class_">Math</span>.<span class="title function_">min</span>(count || <span class="number">1</span>, len); i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> item = ary.<span class="title function_">shift</span>()</span><br><span class="line">      <span class="title function_">fn</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    timer = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(len === <span class="number">0</span>) &#123; <span class="comment">// 如果全部节点都创建好了，取消定时器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">start</span>()</span><br><span class="line">    &#125;, <span class="number">200</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ary = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  ary.<span class="title function_">push</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> renderList = <span class="title function_">timeChunk</span>(ary, <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">  div.<span class="property">innerHTML</span> = n</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div)</span><br><span class="line">&#125;, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">renderList</span>()</span><br></pre></td></tr></table></figure>


      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/设计模式/">设计模式</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/03/26/useMemo和useCallback/"><span>useMemo &amp; useCallback</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/03/26/useMemo和useCallback/" rel="bookmark">
        <time class="entry-date published" datetime="2024-03-26T12:59:28.000Z">
          2024-03-26
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a><code>useMemo</code></h1><p><code>useMemo</code>用于缓存每次重新渲染都需要计算的结果</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><strong><code>useMemo(calculateValue,dependencies)</code></strong></p>
<ul>
<li><code>calculateValue</code>: 缓存计算值的函数，它应该是一个没有参数的纯函数。React将在首次渲染时调用该函数，在之后的渲染中，如果依赖项（<code>dependencies</code>）没有发生变化，React将不会调用该函数，而是直接返回缓存的值</li>
<li><code>dependencies</code>: 依赖项</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>在初次渲染时，返回<code>calculateValue</code>函数的返回值</li>
<li>在之后的渲染中，如果依赖项没有变化，则返回缓存的值；如果依赖项发生了变化，将重新调用<code>calculateValue</code>函数并计算出新的返回值</li>
</ul>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p><code>useMemo</code>主要的用法有两种：</p>
<ul>
<li>通过缓存数据，来跳过代价昂贵的计算</li>
<li>跳过组件的重新渲染</li>
</ul>
<p><strong>跳过代价昂贵的计算</strong></p>
<p>例如，我们有一个todos的大数组，需要根据tab来筛选出某些数组项。在初次渲染之后，只有当todos数组或者tab发生改变了才会重新执行过滤数组的方法。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TodoList</span>(<span class="params">&#123; todos, tab, theme &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> visibleTodos = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">filterTodos</span>(todos, tab), [todos, tab]);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>跳过组件的重新渲染</strong></p>
<p>例如，<code>ParentComp</code>组件接受一个<code>theme</code>的props，用于改变组件内部样式，<strong>默认情况下，一个组件重新渲染时，React会递归重新渲染它的所有子组建</strong>。也就是，当<code>theme</code>重新渲染时，会导致<code>SonComp</code>组件的重新渲染，但其实<code>SonComp</code>组件并不需要重新渲染。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ParentComp</span>(<span class="params">&#123; theme &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> visibleTodos = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">filterTodos</span>(todos, tab), [todos, tab]);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;theme&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">SonComp</span> <span class="attr">items</span>=<span class="string">&#123;visibleTodos&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过将组件用<code>memo</code>包裹起来，这样当它的props和上次传入的相同时，就不会触发重新渲染</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; memo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">SonComp</span> = <span class="title function_">memo</span>(<span class="keyword">function</span> <span class="title function_">SonComp</span>(<span class="params">&#123; items &#125;</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>引出<code>usecallback</code></strong></p>
<p>现在，<code>SonComp</code>组件被包裹在<code>memo</code>中，接收一个函数作为props。每次<code>ParentComp</code>组件重新渲染，都会导致<code>handleClick</code>函数的重新创建，即产生不同的<code>handleClick</code>，这就会导致<code>SonComp</code>组件的重新渲染</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ParentComp</span>(<span class="params">&#123; theme &#125;</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">SonComp</span> <span class="attr">handleClick</span>=<span class="string">&#123;handleClick&#125;/</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">SonComp</span> = <span class="title function_">memo</span>(<span class="keyword">function</span> <span class="title function_">SonComp</span>(<span class="params">&#123; handleClick &#125;</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>

<p>我们很容易想到使用<code>useMemo</code>来缓存handleClick函数，如下所示：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleClick = <span class="title function_">useMeme</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123; <span class="comment">// 原来handleClick的逻辑</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,[xxx])</span><br></pre></td></tr></table></figure>
<p>这样看上去就很冗余了，在React中有另外一个Hook用于缓存函数。</p>
<h1 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a><code>useCallback</code></h1><p><code>useCallback</code>允许你在多次渲染中缓存函数</p>
<h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><p><strong><code>useCallback(fn, dependencies)</code></strong></p>
<ul>
<li><code>fn</code>: 想要缓存函数，它可以传入任何参数并且返回任何值。React将在首次渲染时<strong>返回</strong>（不是调用）该函数，在之后的渲染中，如果依赖项（<code>dependencies</code>）没有发生变化，React将返回相同的函数。<strong>在任何渲染中，React都不会调用该函数，而是返回该函数</strong></li>
<li><code>dependencies</code>: 依赖项</li>
</ul>
<p><strong>返回值</strong></p>
<p>在初次渲染时，<code>useCallback</code>返回你已经传入的<code>fn</code>函数</p>
<p>在之后的渲染中, 如果依赖没有改变，<code>useCallback</code>返回上一次渲染中缓存的<code>fn</code>函数；否则返回这一次渲染传入的<code>fn</code>。</p>
<h2 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h2><p>接着上面的例子对<code>handleClick</code>进行改造，使它也被缓存起来</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleClick = <span class="title function_">useCallback</span>(<span class="function">(<span class="params">args</span>) =&gt;</span> &#123; <span class="comment">//和普通函数一样使用</span></span><br><span class="line">    <span class="comment">// 直接在此处书写逻辑代码</span></span><br><span class="line">&#125;,[xxx])</span><br></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/React-HookS/">React HookS</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/03/24/useRef/"><span>useRef</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/03/24/useRef/" rel="bookmark">
        <time class="entry-date published" datetime="2024-03-24T13:50:54.000Z">
          2024-03-24
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><code>useRef</code>可以用于引用一个不需要渲染的值</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><strong><code>useRef(initialValue)</code></strong></p>
<ul>
<li><code>initialValue</code>: ref对象的<code>current</code>属性的初始值，只在初次渲染的时候有效</li>
</ul>
<p><strong>返回值</strong></p>
<p><code>useRef</code>返回一个只有<code>current</code>属性的对象。<code>current</code>初始值为传递的<code>initialValue</code>，之后可以将其设置为其他值</p>
<p>如果将ref对象作为一个JSX节点的<code>ref</code>属性，React会为它设置<code>current</code>属性</p>
<p><strong>注意</strong></p>
<ul>
<li><code>ref.current</code>属性可以修改，它是可变的，这与<code>state</code>不同</li>
<li>改变<code>ref.current</code>属性，<strong>不会重新渲染组件</strong></li>
<li>除了进行初始化操作，不要在渲染期间写入或读取<code>ref.current</code></li>
</ul>
<blockquote>
<p>不要在渲染期间写入或者读取<code>ref.current</code>，如果不得不在渲染期间读取或写入，应该使用<code>state</code></p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  myRef.<span class="property">current</span> = <span class="number">123</span> <span class="comment">// ❌ 不要再渲染期间写入 ref</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;myRef.current&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> <span class="comment">// ❌ 不要再渲染期间读取 ref</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>事件处理程序或者Effect</strong>中读取或写入<code>ref</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    myRef.<span class="property">current</span> = <span class="number">123</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><code>useRef</code>的使用场景主要有两种：</p>
<ul>
<li>引用或存储一些不影响视图的信息。（因为改变ref不会触发重新渲染）</li>
<li>通过ref对象赋值给DOM的<code>ref</code>属性来获取或操作DOM</li>
</ul>
<h3 id="引用或存储一个值"><a href="#引用或存储一个值" class="headerlink" title="引用或存储一个值"></a>引用或存储一个值</h3><p>示例：保存定时器的id</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timerRef = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleStartClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 业务逻辑</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    timerRef.<span class="property">current</span> = timer <span class="comment">// 保存定时器id</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleStopClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timerRef.<span class="property">current</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      // ....</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过ref操作DOM"><a href="#通过ref操作DOM" class="headerlink" title="通过ref操作DOM"></a>通过ref操作DOM</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = <span class="title function_">useRef</span>(<span class="literal">null</span>) <span class="comment">// 声明一个初始值为 null 的ref对象</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    inputRef.<span class="property">current</span>.<span class="title function_">focus</span>() <span class="comment">//inputRef.current获取到DOm节点，并调用input节点上的focus方法</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span> <span class="comment">// 将DOM节点的ref对象赋值给ref</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无法获取自定义组件的ref"><a href="#无法获取自定义组件的ref" class="headerlink" title="无法获取自定义组件的ref"></a>无法获取自定义组件的ref</h3><p>默认情况下，自定义组件不会暴露他们内部DOM节点的ref</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useRef &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComp</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [x, setX] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;x&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> myRef = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(myRef.<span class="property">current</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">MyComp</span> <span class="attr">ref</span>=<span class="string">&#123;myRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>获取ref<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>控制台警告，无法获取到ref</p>
<img src="/2024/03/24/useRef/image.png" class title="This is an image">

<p>为了解决这个问题，可以使用<code>forwardRef</code>包裹子组件，这样父组件就能得到它的ref</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useState, useRef, forwardRef &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyComp</span> = <span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;  <span class="comment">//forwardRef包裹组件，函数的第二个参数就是ref对象</span></span><br><span class="line">  <span class="keyword">const</span> [x, setX] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span>&gt;</span>&#123;x&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> myRef = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(myRef.<span class="property">current</span>); <span class="comment">//可以获取到子组件的ref</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">MyComp</span> <span class="attr">ref</span>=<span class="string">&#123;myRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>获取ref<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/React-Hooks/">React Hooks</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/03/24/useState/"><span>useState</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/03/24/useState/" rel="bookmark">
        <time class="entry-date published" datetime="2024-03-24T03:29:45.000Z">
          2024-03-24
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><strong>作为一个React Hook</strong>，它只能在组件的顶层调用</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><strong><code>useState(initialState)</code></strong></p>
<ul>
<li><code>initialState</code>：state的初始值。当传递函数作为initialState时，它将被视为<strong>初始化函数</strong>，它应该是一个<strong>纯函数</strong>，不应该传入任何参数，并且应该返回一个值来作为初始值。<strong>此参数只有在初始化渲染时使用，在之后将被忽略</strong></li>
</ul>
<p><code>useState</code>返回一个数组：状态变量 和 状态设置（set）函数</p>
<p>按照惯例，使用解构赋值的方法来命名状态和状态设置函数，例如<code>const [x, setX] = useState(0)</code></p>
<p><strong><code>set</code>函数</strong></p>
<p>通过调用<code>set</code>函数来更新状态变量的值，你可以：</p>
<ul>
<li>传入一个不同的新值，例如: <code>setName(&#39;cqy&#39;)</code></li>
<li>基于待定的<code>state</code>来计算新的状态（<strong>更新函数</strong>），例如: <code>setAge(a =&gt; a + 1)</code></li>
</ul>
<blockquote>
<p>当将函数作为参数传递给<code>set</code>函数时，它被视为<strong>更新函数</strong>。它必须是纯函数，唯一的参数是待定的<code>state</code>，并应该返回下一个状态</p>
</blockquote>
<p><strong>注意事项</strong></p>
<p><code>set</code>函数<strong>仅更新 下一次 渲染的状态变量</strong>，如果在调用<code>set</code>函数后立刻读取状态便了，<strong>得到的仍然是渲染在屏幕上的旧值</strong>。</p>
<p><strong>待定的<code>state</code></strong></p>
<p>下面的例子中，我们希望在点击之后将count增加3，但结果是count只会增加1。<br>原因就在于，前一个<code>set</code>函数执行完后，后一个<code>set</code>函数读取的仍然是旧的状态，React会批量处理状态更新，在所有事件处理函数运行并调用其<code>set</code>函数后更新屏幕。所以<strong>在页面重新渲染前</strong>，获取到的仍然是<strong>旧值</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      You pressed me &#123;count&#125; times</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，可以给<code>set</code>函数传递一个<strong>更新函数</strong>，它可以根据**最新的<code>state</code>**（即待定的<code>state</code>，可以理解为若没有后续改变state的操作，该state将会在下一次渲染时被使用）状态来计算更新下一个<code>state</code>状态</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">setCount</span>(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>); <span class="comment">// setCount(0 =&gt; 1)</span></span><br><span class="line">  <span class="title function_">setCount</span>(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>); <span class="comment">// setCount(1 =&gt; 2)</span></span><br><span class="line">  <span class="title function_">setCount</span>(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>); <span class="comment">// setCount(2 =&gt; 3)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// c =&gt; c + 1 是更新函数，它获取 待定状态 并根据此计算下一个状态</span></span><br></pre></td></tr></table></figure>

<h2 id="更新状态中的对象和数组"><a href="#更新状态中的对象和数组" class="headerlink" title="更新状态中的对象和数组"></a>更新状态中的对象和数组</h2><p>当把对象和数组作为状态变量时，你应该替换它而不应该单纯的改变对象中的某个属性或者数组中的某项</p>
<p>示例代码：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [obj, setObj] = <span class="title function_">useState</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;easycodesniper&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">22</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;xxx&#x27;</span>  <span class="comment">//❌ 错误的修改方法</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">setObj</span>(&#123; <span class="comment">// 正确的修改方法</span></span><br><span class="line">  ...obj,  </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="避免重复创建初始状态"><a href="#避免重复创建初始状态" class="headerlink" title="避免重复创建初始状态"></a>避免重复创建初始状态</h2><p>React只在初次渲染时保存初始状态，后续渲染都会忽略</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [ x, setX ] = <span class="title function_">useState</span>(<span class="title function_">createInitialX</span>()) <span class="comment">//不好的实践</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管<code>createInitialX()</code>的结果仅用于初次渲染，但是每次重新渲染时都要调用此函数，如果它的执行需要昂贵的计算，会导致资源浪费<br>为了解决这个问题，你应该把函数本身作为初始化函数传递给<code>useState</code>，而不是调用该函数</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [ x, setX ] = <span class="title function_">useState</span>(createInitialX) <span class="comment">//合理的实践</span></span><br></pre></td></tr></table></figure>

<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/React-Hooks/">React Hooks</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/03/23/useEffect/"><span>useEffect</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/03/23/useEffect/" rel="bookmark">
        <time class="entry-date published" datetime="2024-03-23T09:07:57.000Z">
          2024-03-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><code>Effect</code>在React中被专门定义为：由渲染引起的副作用。它允许你指定由渲染本身，而不是特定事件引起的副作用</p>
<p><code>useEffect</code>被设计用于将组件和外部系统同步，例如数据获取、服务器的链接、设置订阅等不受React控制的系统</p>
<p><strong>作为一个React Hook</strong>，它只能在组件的顶层调用，如果你需要在循环或判断的逻辑中调用，可以将这部分逻辑抽离出去成为一个组件。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><strong><code>useEffect(setup, dependencies?)</code></strong></p>
<ul>
<li><code>setup</code>: 处理Effect的函数，可以选择性的返回一个清理（cleanup）函数。当 组件被添加到DOM时 和 每次依赖项发生变化重新渲染后，React会首先利用旧值运行<code>cleanup</code>函数（如果你设置了该函数），然后使用新值运行<code>setup</code>函数。在组件从DOM中移除后，React将最后一次运行<code>cleanup</code>函数</li>
<li><code>dependencies</code>（可选）: <code>setup</code>函数中引用的所有响应式值的列表。<ul>
<li>React会使用<code>Object.is</code>来比较每个依赖项和它先前的值，只要有依赖项和先前的值不同时，将会重新运行<code>setup</code>函数。</li>
<li>如果忽略此参数，则在每次重新渲染组件之后，将重新执行<code>setup</code>函数</li>
<li>如果此参数为空数组<code>[]</code>，则只在初次渲染组件的时候执行<code>setup</code>函数</li>
</ul>
</li>
</ul>
<p><code>useEffect</code>的运行过程：</p>
<ol>
<li>将组件挂载到页面时，将运行<code>setup</code>函数</li>
<li>重新渲染依赖项变更的组件后：</li>
</ol>
<ul>
<li>首先，使用旧值运行<code>cleanup</code>函数</li>
<li>然后，使用新值运行<code>setup</code>函数</li>
</ul>
<ol start="3">
<li>当组件从页面卸载后，<code>cleanup</code>函数将运行最后一次</li>
</ol>
<blockquote>
<p>在<strong>开发环境</strong>下，React在运行<code>setup</code>之前会额外运行一次<code>setup</code>和<code>cleanup</code>，这是一种压力测试，来验证Effect逻辑是否正确实现</p>
</blockquote>
<p>使用示例：模拟一个连接服务器的组件</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [serverUrl, setServerUrl] = <span class="title function_">useState</span>(<span class="string">&#x27;easycodesniper.top&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> connection = <span class="title function_">createConnection</span>(serverUrl) <span class="comment">//模拟连接服务器</span></span><br><span class="line">    connection.<span class="title function_">connect</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123; <span class="comment">//在销毁组件时断开连接</span></span><br><span class="line">      connection.<span class="title function_">disconnect</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [serverUrl]) <span class="comment">//依赖项，当服务器路径改变时重新执行setup</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>欢迎来到&#123;serverUrl&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<h2 id="useEffect执行时机"><a href="#useEffect执行时机" class="headerlink" title="useEffect执行时机"></a><code>useEffect</code>执行时机</h2><p>每当你的组件渲染时，React将更新视图，<strong>然后运行</strong><code>useEffect</code>中的代码。换句话说，**<code>useEffect</code>会把这段代码放到视图更新渲染之后执行**</p>
<h2 id="实践导向"><a href="#实践导向" class="headerlink" title="实践导向"></a>实践导向</h2><h3 id="在Effect中根据先前的state更新state"><a href="#在Effect中根据先前的state更新state" class="headerlink" title="在Effect中根据先前的state更新state"></a>在Effect中根据先前的state更新state</h3><p>当想在Effect中根据先前的state更新state时，会遇到问题：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [cnt, setCnt] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCnt</span>(cnt + <span class="number">1</span>) <span class="comment">//每秒将cnt加1</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">  &#125;, [cnt]) <span class="comment">//将cnt作为依赖项</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">spsn</span>&gt;</span>&#123;cnt&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为<code>cnt</code>是响应式数据，所以必须在依赖项列表中指定它，这就会导致Effect在每次cnt变化之后都要执行<code>cleanup</code>和<code>setup</code></p>
<p>解决方法：在<code>setCnt</code>中不是直接传入修改的值，而是传入<code>c =&gt; c + 1</code>状态更新器，这样做的目的是：<strong>将cnt从依赖项中移除</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [cnt, setCnt] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCnt</span>(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>) <span class="comment">//每秒将cnt加1</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">  &#125;, []) </span><br></pre></td></tr></table></figure>

<h3 id="Effect依赖于对象或函数"><a href="#Effect依赖于对象或函数" class="headerlink" title="Effect依赖于对象或函数"></a>Effect依赖于对象或函数</h3><p>如果你的Effect依赖于渲染期间创建的对象或函数，则它可能会频繁运行</p>
<p>示例代码：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">createOptions</span>(<span class="params">serverUrl</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      serverUrl,</span><br><span class="line">      <span class="comment">// ... others</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> options = <span class="title function_">createOptions</span>(<span class="string">&#x27;easycodesniper.top&#x27;</span>) <span class="comment">//在Effect中被使用</span></span><br><span class="line">    <span class="keyword">const</span> connection = <span class="title function_">createConnection</span>(options)</span><br><span class="line">    connection.<span class="title function_">connect</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123; </span><br><span class="line">      connection.<span class="title function_">disconnect</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [createOptions]) </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>欢迎来到&#123;serverUrl&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<p>对<code>createOptions</code>函数本身的封装并没有问题。</p>
<p>首先，对象或函数都是引用类型的值，判断他们是否相同是通过是否指向同一块内存地址</p>
<p>然后，每次组件重新渲染，都会从头创建一个<code>createOptions</code>函数，那这个函数的地址和之前的地址肯定不同，也就意味着这两者不是相同的（即依赖项发生了改变），会导致Effect在每次重新渲染之后再次重新执行</p>
<p>所以，<strong>避免使用在渲染期间创建的函数作为依赖项</strong>，<strong>请在<code>Effect</code>内部声明它</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [serverUrl, setServerUrl] = <span class="title function_">useState</span>(<span class="string">&#x27;easycodesniper.top&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在Effect内部创建它</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">createOptions</span>(<span class="params">serverUrl</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        serverUrl,</span><br><span class="line">        <span class="comment">// ... others</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> options = <span class="title function_">createOptions</span>(serverUrl) <span class="comment">//在Effect中被使用</span></span><br><span class="line">    <span class="keyword">const</span> connection = <span class="title function_">createConnection</span>(options)</span><br><span class="line">    connection.<span class="title function_">connect</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123; </span><br><span class="line">      connection.<span class="title function_">disconnect</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [serverUrl]) </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>欢迎来到&#123;serverUrl&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<p>通过在<code>Effect</code>内部定义<code>createOption</code>函数，这样<code>Effect</code>只依赖于<code>serverUrl</code>字符串，字符串作为基础类型值，除非你将它设置为其他值，否则它不会改变</p>
<h3 id="你不需要Effect"><a href="#你不需要Effect" class="headerlink" title="你不需要Effect"></a>你不需要<code>Effect</code></h3><p><code>Effect</code>是React范式中的一种脱围机制。它让你可以使组件和一些外部的系统同步。如果没有涉及到外部系统（例如只是像根据props或state的变化更新一个组件的state），你就不应该使用<code>Effect</code></p>
<p><strong>常见的情况：</strong></p>
<ol>
<li><strong>不必使用Effect来转换渲染所需的数据</strong>。例如，想在展示一个列表之前先做筛选，你可能会写一个当列表变化时更新state的<code>Effect</code>。然而，这是低效的。</li>
</ol>
<ul>
<li>当你更新state，React首先会调用组件来渲染视图</li>
<li>然后React会执行你的<code>Effect</code>，如果你的<code>Effect</code>也立即更新了这个state，将会重新执行整个组件</li>
</ul>
<p>所以，你应该在组件的顶层转换数据</p>
<ol start="2">
<li><strong>根据props或state来更新state</strong>。例如，你又一个包含了两个state变量的组件：<code>firstName</code> 和 <code>lastName</code>。你想通过他们计算出<code>fullName</code>。你可能会写一个当<code>firstName</code>或者<code>lastName</code>变化时更新<code>fullName</code>的<code>Effect</code></li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [firstName, setFirstName] = <span class="title function_">useState</span>(<span class="string">&#x27;easycode&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [lastName, setLastName] = <span class="title function_">useState</span>(<span class="string">&#x27;sniper&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [fullName, setFullName] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setFullName</span>(firstName + <span class="string">&#x27; &#x27;</span> + lastName);</span><br><span class="line">  &#125;, [firstName, lastName]);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做会导致：</p>
<ul>
<li>首先，React会调用组件，使用<code>fullName</code>的旧值执行整个渲染流程</li>
<li>然后，React会执行你的<code>Effect</code>，用更新后的值又重新渲染了一遍</li>
</ul>
<p>所以，你应该直接计算这个值<code>const fullName = firstName + &#39; &#39; + lastName</code></p>
<h3 id="初始化应用"><a href="#初始化应用" class="headerlink" title="初始化应用"></a>初始化应用</h3><p>有些逻辑只需要在应用加载时执行一次，你可能会将它放到一顶层组件的<code>Effect</code>中</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">loadFunction</span>() </span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这会遇到一些问题：在开发环境它会被执行两次，这可能会导致潜在的问题</p>
<p>解决方法：</p>
<p><strong>添加一个顶层变量来记录它是否已经执行过了</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> didInit = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!didInit) &#123;</span><br><span class="line">      didInit = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 只在每次应用加载时执行一次</span></span><br><span class="line">      <span class="title function_">loadFunction</span>() </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><p>很多场景都需要使用<code>Effect</code>来发起数据请求，例如：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SearchResults</span>(<span class="params">&#123; query &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [results, setResults] = <span class="title function_">useState</span>([]);</span><br><span class="line">  <span class="keyword">const</span> [page, setPage] = <span class="title function_">useState</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟发送数据请求</span></span><br><span class="line">    <span class="title function_">fetchResults</span>(query, page).<span class="title function_">then</span>(<span class="function"><span class="params">json</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setResults</span>(json);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, [query, page]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而上面的代码有一个问题，假如你快速的输入<code>hello</code>，那么query会从<code>h</code>变成<code>he</code>,<code>hel</code>,<code>hell</code>最后是<code>hello</code>，这会触发一连串不同的数据请求，但无法保证返回顺序。例如，<code>hell</code>的响应可能在<code>hello</code>的响应<strong>之后</strong>返回，这将会显示错误的搜索结果</p>
<p>为了修复这个问题，需要添加一个<strong>清理函数</strong>来忽略较早的返回结果</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SearchResults</span>(<span class="params">&#123; query &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [results, setResults] = <span class="title function_">useState</span>([]);</span><br><span class="line">  <span class="keyword">const</span> [page, setPage] = <span class="title function_">useState</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> ignore = <span class="literal">false</span>;</span><br><span class="line">    <span class="title function_">fetchResults</span>(query, page).<span class="title function_">then</span>(<span class="function"><span class="params">json</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!ignore) &#123;</span><br><span class="line">        <span class="title function_">setResults</span>(json);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      ignore = <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [query, page]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这可以确保在<code>Effect</code>中获取数据时，除了最后一次请求的所有返回结果都将被忽略</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/React-Hooks/">React Hooks</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/03/11/浅尝React/"><span>浅尝React</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/03/11/浅尝React/" rel="bookmark">
        <time class="entry-date published" datetime="2024-03-11T06:28:57.000Z">
          2024-03-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="胡子语法"><a href="#胡子语法" class="headerlink" title="胡子语法{}"></a>胡子语法<code>&#123;&#125;</code></h2><p>在<code>&#123;&#125;</code> 中可以嵌入JS表达式：</p>
<ol>
<li>变量&#x2F;值:  <code>&#123; text &#125;</code></li>
<li>数学运算</li>
<li>判断: 三元运算符、取反、与或非等逻辑判断</li>
<li>循环: 借助于数组的迭代方法处理，例如map、filter</li>
</ol>
<p>注意点：</p>
<ol>
<li>不支持渲染普通对象，但也有特殊情况：<ul>
<li>渲染JSX虚拟DOM对象</li>
<li>给元素设置style行内样式，要求必须写成一个对象格式，对象内的样式写成驼峰命名</li>
</ul>
</li>
<li>数组对象：把数组中的每一项都拿出来渲染，并不是变为字符串渲染，中间没有逗号</li>
<li>函数对象，不支持直接渲染，可以作为函数组件的形式渲染</li>
</ol>
<h2 id="JSX渲染机制"><a href="#JSX渲染机制" class="headerlink" title="JSX渲染机制"></a>JSX渲染机制</h2><p>第一步：将我们编写的JSX语法编译为virtualDOM对象（virtualDOM对象：框架自己内部构建的一套对象体系，基于对象的属性描述出所构建视图中的DOM节点的相关特征）</p>
<ul>
<li>基于 babel-preset-react-app 把JSX编译为 <code>React.createElement()</code>的格式</li>
<li><code>React.createElement(ele, props, ...children)</code><ul>
<li>ele: 元素标签名或组件名</li>
<li>props: 元素的属性集合，如果没有设置过任何属性，值为null</li>
<li>children: 从第三个及以后的参数，都是当前元素的子节点</li>
</ul>
</li>
<li>再把createElement方法执行，创建出virtualDOM</li>
<li>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">virtualDOM = &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="attr">$$typeof</span>: <span class="title class_">Symbol</span>(react.<span class="property">element</span>), </span><br><span class="line">  <span class="attr">ref</span>: <span class="literal">null</span>, </span><br><span class="line">  <span class="attr">key</span>: <span class="literal">null</span>, </span><br><span class="line">  <span class="attr">type</span>: 标签名, </span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    元素相关属性，</span><br><span class="line">    <span class="attr">children</span>: 子节点信息</span><br><span class="line">  &#125; || &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
第二步：把构建的virtualDOM渲染为真实DOM</li>
</ul>
<p>第一次渲染完毕后，会把创建的virtualDOM缓存起来</p>
<p>当我们经过某些操作，改变了视图中的数据，视图就需要更新</p>
<ul>
<li>按照最新的数据，把JSX重新编译为 全新的virtualDOM</li>
</ul>
<p>拿新的virtualDOM与之前缓存的virtualDOM使用diff算法进行对比，生成补丁包Patch，只重新渲染补丁包</p>
<h2 id="函数组件的渲染机制"><a href="#函数组件的渲染机制" class="headerlink" title="函数组件的渲染机制"></a>函数组件的渲染机制</h2><p>函数组件：创建一个函数，让函数返回JSX视图或者virtualDOM对象</p>
<p>调用函数组件时，可以设置各种属性</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Demo</span> title=<span class="string">&quot;我是标题&quot;</span> x=&#123;<span class="number">10</span>&#125; data=&#123;[<span class="number">100</span>, <span class="number">200</span>]&#125; className=<span class="string">&quot;box&quot;</span> style=&#123;&#123; <span class="attr">fontSize</span>: <span class="string">&#x27;20px&#x27;</span> &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>如果设置的属性值不是字符串格式，需要基于<code>&#123;&#125;</code>语法进行嵌套</p>
<p>渲染过程还是如上所述：</p>
<ol>
<li>基于 babel-preset-react-app 把JSX编译为 <code>React.createElement()</code>的格式</li>
<li>把createElement方法执行，创建出virtualDOM</li>
<li>把构建的virtualDOM渲染为真实DOM</li>
</ol>
<p>不同点在于，virtualDOM中的 type 值不再是一个字符串，而是一个函数，此时：</p>
<ul>
<li>把函数执行 -&gt; Demo()</li>
<li>把virtualDOM中的props，作为实参传递给函数 -&gt; Demo(props)</li>
<li>接收函数执行的返回结果，也就是virtualDOM对象</li>
<li>最后基于render将virtualDOM变为真实DOM，插入到#root容器中</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">DemoOne</span> <span class="keyword">from</span> <span class="string">&#x27;./view/DemoOne&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">DemoOne</span> <span class="attr">title</span>=<span class="string">&quot;我是标题&quot;</span> <span class="attr">x</span>=<span class="string">&#123;10&#125;</span> <span class="attr">data</span>=<span class="string">&#123;[100,</span> <span class="attr">200</span>]&#125; <span class="attr">className</span>=<span class="string">&quot;box&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">fontSize:</span> &#x27;<span class="attr">20px</span>&#x27; &#125;&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//DemoOne.jsx</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">DemoOne</span> = <span class="keyword">function</span> <span class="title function_">DemoOne</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(props);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;demo-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      我是demo-one</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">DemoOne</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<img src="/2024/03/11/%E6%B5%85%E5%B0%9DReact/image-3.png" class title="This is an image">

<p>如果函数组件基于双闭合标签调用的话，还可以传递子节点</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">DemoOne</span> <span class="keyword">from</span> <span class="string">&#x27;./view/DemoOne&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">DemoOne</span> <span class="attr">title</span>=<span class="string">&quot;我是标题&quot;</span> <span class="attr">x</span>=<span class="string">&#123;10&#125;</span> <span class="attr">data</span>=<span class="string">&#123;[100,</span> <span class="attr">200</span>]&#125; <span class="attr">className</span>=<span class="string">&quot;box&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">fontSize:</span> &#x27;<span class="attr">20px</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">DemoOne</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>
<img src="/2024/03/11/%E6%B5%85%E5%B0%9DReact/image-4.png" class title="This is an image">

<h2 id="props属性细节"><a href="#props属性细节" class="headerlink" title="props属性细节"></a>props属性细节</h2><p>props传递进来的属性是只读的，不能进行修改。但可以将props属性赋值给变量，然后对变量进行操作</p>
<blockquote>
<p>关于对象的规则设置</p>
<ul>
<li>冻结<br>冻结对象: Object.freeze(obj)   浅冻结，嵌套对象需要递归调用来完全冻结<br>判断是否冻结: Object.isFrozen(obj) &#x3D;&gt; true&#x2F;false<br>被冻结对象不能修改成员值，不能新增成员，不能删除成员，不能劫持成员</li>
<li>密封<br>密封对象: Object.seal(obj)<br>判断是否密封: Object.isSealed(obj) &#x3D;&gt; true&#x2F;false<br>被密封的对象可以修改成员值，但不能删除、新增和劫持成员</li>
<li>扩展<br>把对象设置为不可扩展: Object.preventExtensions(obj)<br>检测是否可扩展: Object.isExtensible(obj)</li>
</ul>
</blockquote>
<p><strong>给props设置默认值</strong><br>方法一：通过把函数当做对象，设置静态的私有属性方法，来给其设置属性的默认值</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">DemoOne</span> = <span class="keyword">function</span> <span class="title function_">DemoOne</span>(<span class="params">props</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;demo-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      我是demo-one</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">DemoOne</span>.<span class="property">defaultProps</span> = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;默认标题&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">DemoOne</span>;</span><br></pre></td></tr></table></figure>

<p>方法二（官方文档）：直接在参数后面写上默认值</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">DemoOne</span> = <span class="keyword">function</span> <span class="title function_">DemoOne</span>(<span class="params">&#123; title = <span class="string">&quot;默认标题&quot;</span> &#125;</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;demo-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      我是demo-one</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">DemoOne</span>;</span><br></pre></td></tr></table></figure>

<p><strong>给props进行属性校验</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 安装依赖</span><br><span class="line">npm i prop-types</span><br></pre></td></tr></table></figure>

<p>在组件中导入，并使用</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">DemoOne</span> = <span class="keyword">function</span> <span class="title function_">DemoOne</span>(<span class="params">props</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;demo-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      我是demo-one</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">DemoOne</span>.<span class="property">propTypes</span> = &#123; <span class="comment">//规则校验</span></span><br><span class="line">  <span class="attr">title</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">DemoOne</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>PropTypes.string</code> 表示类型是string<br><code>isRequired</code> 表示这个prop是必传的</p>
<p>详细校验规则的使用见<a target="_blank" rel="noopener" href="https://github.com/facebook/prop-types">官网</a></p>
<h2 id="对props-children的数量进行判断"><a href="#对props-children的数量进行判断" class="headerlink" title="对props.children的数量进行判断"></a>对props.children的数量进行判断</h2><p>children的不同情况：</p>
<ol>
<li>当没有children时，得到的是undefined</li>
<li>当只有一个children时，得到的是children对象</li>
<li>当有多个children时，得到的是一个数组</li>
</ol>
<p>可以使用React.Children对children进行数量判断，以及其他的一些操作</p>
<img src="/2024/03/11/%E6%B5%85%E5%B0%9DReact/image-2.png" class title="This is an image">

<ol>
<li>count函数可以返回children的数量</li>
<li>forEach和map会对children进行遍历（children为undefined也没关系）</li>
<li>toArray会将children转化成数组（children为undefined时转化成空数组）</li>
</ol>
<h2 id="静态组件"><a href="#静态组件" class="headerlink" title="静态组件"></a>静态组件</h2><p><strong>函数是静态组件</strong></p>
<p>第一次渲染组件时，会把函数执行</p>
<ul>
<li>产生一个私有的上下文</li>
<li>把解析出来的props传递进去</li>
<li>渲染函数返回的virtualDOM</li>
</ul>
<p>当我们修改上下文中的变量，变量的值会发生改变，但是视图<strong>不会更新</strong></p>
<p>也就是说，函数组件第一次渲染完毕后，组建的内容不会根据组件内的某些操作再进行更新，所以称他为<strong>静态组件</strong></p>
<p>除非再父组件中重新调用这个函数组件，那样就可以传递不同的信息</p>
<h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><h3 id="基于类组件构建动态组件"><a href="#基于类组件构建动态组件" class="headerlink" title="基于类组件构建动态组件"></a>基于类组件构建动态组件</h3><p>创建类组件</p>
<ul>
<li>创建一个构造函数，要求必须继承React.Component&#x2F;PureComponent这个类</li>
<li>必须给当前类设置一个render方法，在render方法中返回需要渲染的视图</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vote</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props) <span class="comment">//会把传递进来的属性挂载到this实例上</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">props</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      </span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Vote</span>; </span><br></pre></td></tr></table></figure>

<p>React的render函数在渲染的时候，如果type是：</p>
<ul>
<li>字符串：就创建一个标签</li>
<li>普通函数：把函数执行，并把props传递给函数</li>
<li>构造函数：把构造函数基于new执行（也就是创建以恶搞类的实例），把解析出来的props传递过去<ul>
<li>把在类组件中编写的render函数执行，把返回的JSX virtualDOM当作组件视图进行渲染</li>
</ul>
</li>
</ul>
<p>从<strong>第一次调用</strong>类组件开始，类组件内部发生的事情：</p>
<ol>
<li><strong>初始化属性 &amp;&amp; 规则校验</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="variable language_">super</span>(props) <span class="comment">//会把传递进来的属性挂载到this实例上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
即使我们不在constructor中处理（或者没写constructor），React内部也会把传递的props挂载到实例上</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//规则校验</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vote</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123; <span class="comment">//设置默认值</span></span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;我是默认title&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123; <span class="comment">//设置规则校验</span></span><br><span class="line">    <span class="attr">title</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props) <span class="comment">//会把传递进来的属性挂载到this实例上</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">props</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      </span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Vote</span>; </span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>初始化状态</strong></li>
</ol>
<p>修改状态，可以触发视图更新<br>需要手动初始化状态，如果没有手动初始化，默认会往实例上挂载一个state，初始值为<strong>null</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vote</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;我是默认title&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123; <span class="comment">//方法一：在constructor中初始化</span></span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; </span><br><span class="line">      <span class="attr">supNum</span>: <span class="number">10</span>,</span><br><span class="line">      <span class="attr">oppNum</span>: <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  state = &#123; <span class="comment">//方法二：给实例加私有属性初始化</span></span><br><span class="line">    <span class="attr">supNum</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">oppNum</span>: <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      </span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Vote</span>;</span><br></pre></td></tr></table></figure>

<img src="/2024/03/11/%E6%B5%85%E5%B0%9DReact/image-5.png" class title="This is an image">

<p><strong>修改状态，更新视图</strong></p>
<p>使用<code>this.state.属性 = xxx</code>这种操作仅仅只是修改了状态值，但无法让视图更新<br>想让视图更新，我们需要基于React.Component原型上的方法操作：</p>
<ol>
<li><code>this.setState(partialState)</code>方法，修改部分状态，只需要传入你想要修改的状态即可</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">  <span class="attr">xxx</span>: xxx</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>this.forceUpdate()</code>强制更新视图（可以，但不推荐）</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">oppNum</span>++ <span class="comment">//直接修改state中的属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">forceUpdate</span>() <span class="comment">//触发强制更新</span></span><br><span class="line">&#125;&#125;&gt; 按钮 &lt;/button&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>触发周期函数</strong></li>
</ol>
<p><code>componentWillMount</code>钩子函数：组件第一次渲染之前（此函数目前不安全，不建议使用）</p>
<p><code>render</code>钩子函数，进行视图渲染，这就和类组件中必须有一个render函数对应上了，渲染的就是类组件render中返回的virtualDOM</p>
<p><code>componentDidMount</code>钩子函数：第一次渲染完毕，已经把virtualDOM变为真实DOM了</p>
<h3 id="类组件的组件更新逻辑"><a href="#类组件的组件更新逻辑" class="headerlink" title="类组件的组件更新逻辑"></a>类组件的组件更新逻辑</h3><ol>
<li>组件更新会触发生命周期钩子，<code>shouldComponentUpdate()</code>周期函数，表示是否允许更新</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nextProps</span></span><br><span class="line"><span class="comment"> * nextState: 存储要修改的最新状态</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * return true/false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>) <span class="comment">//存储的还是修改前的状态</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//必须返回true或者false</span></span><br><span class="line">  <span class="comment">//返回true表示允许更新，返回false表示不允许更新</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>接着触发<code>componentWillUpdate()</code>周期函数：更新之前<br>此周期函数也是<strong>不安全</strong>的，在这个节点状态还没有被修改</p>
</li>
<li><p>修改状态值，按照最新的状态把返回的JSX编译成virtualDOM。和前一次渲染出来的virtualDOM进行对比，计算出补丁包Patch，触发render函数，把差异的部分进行渲染为真实DOM</p>
</li>
<li><p>最后触发<code>componentDidUpdate()</code>函数，表示组件更新完毕</p>
</li>
</ol>
<h3 id="类组件中-ref-的使用方法"><a href="#类组件中-ref-的使用方法" class="headerlink" title="类组件中 ref 的使用方法"></a>类组件中 ref 的使用方法</h3><p>ref可用于获取真实DOM元素和获取类组件实例</p>
<p>创建 ref 的方法：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法一（不推荐使用）</span></span><br><span class="line"><span class="comment"> * 使用this.refs.h1的方法拿到DOM元素和类组件实例</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">ref</span> = <span class="string">&quot;h1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span> = <span class="string">&quot;input1&quot;</span> /&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法二</span></span><br><span class="line"><span class="comment"> * 此处的x即当前DOM元素，将它赋值到实例上</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">ref</span> = <span class="string">&#123;</span> <span class="attr">x</span> =&gt;</span> this.h1 = x &#125;&gt;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法三</span></span><br><span class="line"><span class="comment"> * 使用React.createRef()创建一个容器，并通过this.h1.current获取到DOM元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ref</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    h1 = <span class="title class_">React</span>.<span class="title function_">createRef</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">ref</span> = <span class="string">&#123;</span> <span class="attr">this.h1</span> &#125;&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Hooks组件"><a href="#Hooks组件" class="headerlink" title="Hooks组件"></a>Hooks组件</h3><p>基于React中新提供的Hook函数，可以<strong>让函数组件动态化</strong></p>
<h2 id="Hook函数"><a href="#Hook函数" class="headerlink" title="Hook函数"></a>Hook函数</h2><p>函数组件（或者说Hooks组件）不是类组件，所以没有实例的概念，调用组件不再是创建类的实例，而是把函数执行，产生一个私有上下文。所以在函数组件中不涉及this的处理</p>
<p>函数组件的每一次渲染都是把函数重新执行，产生一个全新的私有上下文</p>
<h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><blockquote>
<p><strong>作用：</strong> 在函数组件中使用状态，修改状态值可让函数组件更新，类似于类组件的setState<br><strong>语法：</strong> <code>const [state, setState] = useState(initialState)</code><br>返回一个state，以及用于更新state的函数</p>
</blockquote>
<p>每一次组件更新都会把useState重新执行，但是只有第一次执行useState时，设置的初始值会生效；其余以后再执行，获取的状态都是<strong>最新的状态</strong>而不是初始值</p>
<p><code>useState</code>自带了性能优化的机制：<br>每一次修改状态值的时候，都会拿最新要修改的值和之前的状态值进行比较。如果发现两次的值是一样的，则不会修改状态，也不会让视图更新</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">DemoOne</span> = <span class="keyword">function</span> <span class="title function_">DemoOne</span>(<span class="params">props</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;React渲染&#x27;</span>); <span class="comment">//点击新增之后不会进行视图更新，所以不会打印此信息</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> [x, setx] = <span class="title function_">useState</span>(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handle</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setx</span>(<span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;demo-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>x: &#123; x &#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handle&#125;</span>&gt;</span>新增<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">DemoOne</span>;</span><br></pre></td></tr></table></figure>

<p>当我们想在一次点击操作中循环修改状态值（如下方代码所示），我们期望的时在点击“新增”按钮之后，x的值累加到20</p>
<p>但实际的运行结果确实：x&#x3D;11</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">DemoOne</span> = <span class="keyword">function</span> <span class="title function_">DemoOne</span>(<span class="params">props</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> [x, setx] = <span class="title function_">useState</span>(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handle</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="title function_">setx</span>(x+<span class="number">1</span>) <span class="comment">//想要循环x+1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;demo-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>x: &#123; x &#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handle&#125;</span>&gt;</span>新增<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">DemoOne</span>;</span><br></pre></td></tr></table></figure>

<p>就如React官方文档所述，React在调用函数组件时，会为特定的那一次渲染提供一张state快照，其中所有的值都是<strong>根据那一次渲染中state的值</strong>被计算出来的</p>
<p><strong>也就是说，state的值只会在下一次渲染中变更</strong></p>
<p><strong>一个state变量的值永远不会在一次渲染的内部变化</strong></p>
<p>当循环调用时，每一次的setx()都会进入异步队列，等这个队列全部执行完，才进行视图的更新。</p>
<p>也就是说，在异步队列执行完视图更新之前，访问到的state都是上一次渲染的state，即x始终是10，每一次操作都相当于<code>setx(10 + 1)</code></p>
<p>如果真的需要在下次渲染之前多次更新同一个state，可以使用<code>setx(prev =&gt; prev + 1)</code>这样传入一个根据队列中前一个state计算下一个state的<strong>函数</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handle</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="title function_">setx</span>(<span class="function"><span class="params">prev</span> =&gt;</span> prev + <span class="number">1</span>) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><blockquote>
<p><strong>作用:</strong> 在函数组件中使用生命周期函数<br><strong>语法:</strong> <code>useEffect(callback, dependencies)</code><br>callback代表处理Effect的函数，在组件第一次渲染完毕，以及在每一次更新完毕后执行<br>dependencies代表依赖项列表，<strong>可选</strong>，依赖项列表的元素数量必须是固定的，并且必须像<code>[dep1, dep2, dep3]</code>这样内联编写</p>
</blockquote>
<blockquote>
<p><strong>用法1:</strong> <code>useEffect(callback)</code> 不传入依赖项列表<br>第一次渲染完毕后执行callback，等价于componentDidMount<br>在组件每一次更新完毕后，也会执行callback，等价于componentDidUpdate</p>
</blockquote>
<blockquote>
<p><strong>用法2:</strong> <code>useEffect(callback, [])</code> 传入空的依赖项列表<br>只有在第一次渲染完毕后，才会执行callback；每一次视图更新后callback不再执行</p>
</blockquote>
<blockquote>
<p><strong>用法3:</strong> <code>useEffect(callback, [dep1])</code><br>在第一次渲染完毕后执行callback；每一次依赖项dep1更新时执行callback</p>
</blockquote>
<blockquote>
<p><strong>用法4:</strong><code>useEffect(() =&gt; &#123; return () =&gt; &#123;  &#125; &#125;)</code><br>在callback中再返回一个函数，该函数会在组件释放的时候执行；如果组件更新，会把上一次返回的这个函数执行（可以理解为上一次渲染的组件释放了）<br>callback中若有返回值，必须<strong>返回一个函数</strong></p>
</blockquote>
<p>现在模拟向服务器请求数据，然后在初次渲染时接收到</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">queryData</span> = (<span class="params"></span>) =&gt; &#123; <span class="comment">//模拟请求数据</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">res</span>([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>])</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">DemoOne</span> = <span class="keyword">function</span> <span class="title function_">DemoOne</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="keyword">async</span> () =&gt; &#123; <span class="comment">//在初次渲染时拿到数据</span></span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> <span class="title function_">queryData</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;demo-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">DemoOne</span>;</span><br></pre></td></tr></table></figure>
<img src="/2024/03/11/%E6%B5%85%E5%B0%9DReact/image-6.png" class title="This is an image">

<p>可以看到这种写法是不正确的，因为callback若有返回值，必须是一个函数；而 async 修饰的函数默认返回一个promise对象</p>
<p><strong>解决方法：</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方案一：不用async语法糖，采用then的写法</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">//在初次渲染时拿到数据</span></span><br><span class="line">    <span class="title function_">queryData</span>().<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方案二：在callback中再包一个函数，然后调用这个函数</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">//在初次渲染时拿到数据</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">next</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> data = <span class="keyword">await</span> <span class="title function_">queryData</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">  &#125;, [])</span><br></pre></td></tr></table></figure>

<h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p>在函数组件中想要使用ref：</p>
<ol>
<li>可以基于<code>ref = &#123; 函数 &#125;</code>的方式，将创建的DOM元素赋值给变量，但<strong>不推荐使用</strong></li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">DemoOne</span> = <span class="keyword">function</span> <span class="title function_">DemoOne</span>(<span class="params">props</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> box;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(box) <span class="comment">//可以获取到DOM元素</span></span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;demo-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">x</span> =&gt;</span> box = x &#125;&gt;111<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>可以基于<code>React.createRef()</code>创建ref对象来获取内容</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">DemoOne</span> = <span class="keyword">function</span> <span class="title function_">DemoOne</span>(<span class="params">props</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> box = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(box) <span class="comment">//可以获取到DOM元素</span></span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;demo-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">box</span> &#125;&gt;</span>111<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>基于<strong>useRef Hook函数</strong>，创建一个ref对象</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">DemoOne</span> = <span class="keyword">function</span> <span class="title function_">DemoOne</span>(<span class="params">props</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> box = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(box.<span class="property">current</span>); <span class="comment">//可以获取到DOM元素</span></span><br><span class="line">  &#125;, [])</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;demo-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">box</span> &#125;&gt;</span>1111<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p><code>useRef</code> 和 <code>createRef()</code> 的区别：在<strong>非严格模式</strong>下<br>在每一次组件更新时，再次执行useRef方法，不会创建新的Ref对象，获取到的还是第一次创建的那个对象（复用对象，内容还是发生了更新的）<br>createeRef()在每一次组件更新时，都会创建一个全新的Ref对象</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pre1, pre2;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">DemoOne</span> = <span class="keyword">function</span> <span class="title function_">DemoOne</span>(<span class="params">props</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> box1 = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">let</span> box2 = <span class="title class_">React</span>.<span class="title function_">createRef</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> [num, setNum] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!pre1) &#123; <span class="comment">//第一次执行，把创建的Ref对象赋值</span></span><br><span class="line">    pre1 = box1</span><br><span class="line">    pre2 = box2</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">//之后每次更新后执行，验证新创建的Ref对象和前一次的是否是同一个对象</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(pre1 === box1); <span class="comment">//true</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(box1.<span class="property">current</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(pre2 === box2); <span class="comment">//false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;box1&#x27;</span>, box1.<span class="property">current</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;box2&#x27;</span>, box2.<span class="property">current</span>);</span><br><span class="line">  &#125;, [])</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;demo-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">box1</span> &#125;&gt;</span>&#123; num &#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">box2</span> &#125;&gt;</span>222<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> () =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">        setNum(num+1)</span></span><br><span class="line"><span class="language-xml">      &#125; &#125;&gt;新增<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类子组件和函数子组件的ref使用"><a href="#类子组件和函数子组件的ref使用" class="headerlink" title="类子组件和函数子组件的ref使用"></a>类子组件和函数子组件的ref使用</h3><ol>
<li>子组件为类组件时</li>
</ol>
<p>可以通过useRef创建一个Ref对象，然后绑定到子组件标签上</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect, useRef, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123; <span class="comment">//子组件是类组件</span></span><br><span class="line">  state = &#123; <span class="attr">x</span>: <span class="number">100</span> &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;child-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; this.state.x &#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">DemoOne</span> = <span class="keyword">function</span> <span class="title function_">DemoOne</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> x = <span class="title function_">useRef</span>(<span class="literal">null</span>) <span class="comment">//创建Ref对象</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="property">current</span>);</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;demo-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">x</span> &#125;/&gt;</span>  </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">DemoOne</span>;</span><br></pre></td></tr></table></figure>

<img src="/2024/03/11/%E6%B5%85%E5%B0%9DReact/image.png" class title="This is an image">

<ol start="2">
<li>子组件为函数组件时</li>
</ol>
<p>当我们依旧使用上面的方法来获取ref时，</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;child-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">DemoOne</span> = <span class="keyword">function</span> <span class="title function_">DemoOne</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> x = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="property">current</span>);</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;demo-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">x</span> &#125;/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">DemoOne</span>;</span><br></pre></td></tr></table></figure>

<p>控制台会报错：<strong>不能直接给函数组件设置Ref属性</strong></p>
<img src="/2024/03/11/%E6%B5%85%E5%B0%9DReact/image-7.png" class title="This is an image">

<p>解决方法：使用<code>forwardRef()</code>将函数组件包起来，实现ref转发</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; forwardRef, useEffect, useRef, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">forwardRef</span>(<span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">props, ref</span>) &#123; <span class="comment">//此处的ref就是在父组件中调用子组件时传入的ref对象</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;child-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">ref</span> &#125;&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">DemoOne</span> = <span class="keyword">function</span> <span class="title function_">DemoOne</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> x = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="property">current</span>); <span class="comment">//可以获取到子组件</span></span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;demo-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">x</span> &#125;/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">DemoOne</span>;</span><br></pre></td></tr></table></figure>

<img src="/2024/03/11/%E6%B5%85%E5%B0%9DReact/image-8.png" class title="This is an image">


<p>使用<code>forwardRef()</code>可以通过ref转发获取到子组件内部的某个元素，但是<strong>无法拿到</strong>子组件中定义的状态或者方法</p>
<p>解决方法：配合另外一个Hook函数 <code>useImperativeHandle()</code>来获取到子组件中定义的状态和方法</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; forwardRef, useEffect, useImperativeHandle, useRef, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">forwardRef</span>(<span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">props, ref</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> [text, setText] = <span class="title function_">useState</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">submit</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useImperativeHandle</span>(ref, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里被返回的内容，都可以被父组件的Ref对象获取到</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      text,</span><br><span class="line">      setText,</span><br><span class="line">      submit</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;child-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">DemoOne</span> = <span class="keyword">function</span> <span class="title function_">DemoOne</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> x = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="property">current</span>);</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;demo-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">x</span> &#125;/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">DemoOne</span>;</span><br></pre></td></tr></table></figure>

<img src="/2024/03/11/%E6%B5%85%E5%B0%9DReact/image-9.png" class title="This is an image">


<h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><blockquote>
<p><strong>作用:</strong> 在每次重新渲染的时候能够缓存计算的结果，可以用于跳过代价昂贵的重新计算<br><strong>语法:</strong> <code>useMemo(callback, dependencies)</code><br>callback是一个缓存计算值的函数，在首次渲染时调用该函数；在之后的渲染中，只有dependencies中依赖的数据发生了改变，才会调用callback</p>
</blockquote>
<p>示例：一个简易投票器，并计算出支持率。当有人弃权时，不需要重新计算支持率</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">DemoOne</span> = <span class="keyword">function</span> <span class="title function_">DemoOne</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> [ supNum, setSupNum ] = <span class="title function_">useState</span>(<span class="number">10</span>)</span><br><span class="line">  <span class="keyword">let</span> [ oppNum, setOppNum ] = <span class="title function_">useState</span>(<span class="number">5</span>)</span><br><span class="line">  <span class="keyword">let</span> [ x, setX ] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> ratio = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">//计算支持率的代码段用useMemo包起来，并依赖supNum、oppNum；只有当这两者发生变化时才会重新调用函数计算ratio</span></span><br><span class="line">    <span class="keyword">let</span> total = supNum + oppNum</span><br><span class="line">    <span class="keyword">let</span> ratio;</span><br><span class="line">    <span class="keyword">if</span>(total &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      ratio = ( supNum / total * <span class="number">100</span> ).<span class="title function_">toFixed</span>(<span class="number">2</span>) + <span class="string">&#x27;%&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ratio</span><br><span class="line">  &#125;, [supNum, oppNum])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;demo-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>支持人数：&#123;supNum&#125;人<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>反对人数：&#123;oppNum&#125;人<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>支持比率： &#123; ratio &#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>弃权：&#123;x&#125;人<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setSupNum(supNum + 1)&#125;&gt;支持<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setOppNum(oppNum + 1)&#125;&gt;反对<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setX(x + 1)&#125;&gt;弃权<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">DemoOne</span>;</span><br></pre></td></tr></table></figure>

<h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><blockquote>
<p><strong>作用:</strong> 在多次渲染中缓存函数<br><strong>语法:</strong> <code>useCallback(fn, dependencies)</code><br>在初次渲染时，useCallback返回你已经传入的fn函数<br>在之后的渲染中，如果依赖没有改变，useCallback返回上一次渲染中缓存的fn；否则就重新创建fn函数</p>
</blockquote>
<p>示例： </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">DemoOne</span> = <span class="keyword">function</span> <span class="title function_">DemoOne</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> handle = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//函数逻辑</span></span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;demo-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      // ...</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">DemoOne</span>;</span><br></pre></td></tr></table></figure>

<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><h3 id="父子组件通信（类组件）"><a href="#父子组件通信（类组件）" class="headerlink" title="父子组件通信（类组件）"></a>父子组件通信（类组件）</h3><p>父子组件间通信主要是基于<code>props</code>属性：</p>
<ol>
<li>父亲把通过属性把信息传递给儿子</li>
<li>儿子想修改父亲的数据，父亲要把修改数据的方法基于属性传递给儿子，然后儿子调用方法</li>
<li>父亲可以通过给儿子设置Ref，以此来获取儿子的实例或者暴露的属性和方法</li>
</ol>
<p>示例：要做一个投票器案例，有一个Vote父组件，以及VoteMain和VoteFooter两个子组件</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vote.jsx  ---&gt;  父组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VoteFooter</span> <span class="keyword">from</span> <span class="string">&#x27;./VoteFooter&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VoteMain</span> <span class="keyword">from</span> <span class="string">&#x27;./VoteMain&#x27;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vote</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">supNum</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">oppNum</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  change = <span class="function">(<span class="params">type</span>) =&gt;</span> &#123; <span class="comment">//定义修改函数</span></span><br><span class="line">    <span class="keyword">let</span> &#123; supNum, oppNum &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">    <span class="keyword">if</span>(type === <span class="string">&#x27;sup&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">supNum</span>: supNum + <span class="number">1</span> &#125;)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type === <span class="string">&#x27;opp&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">oppNum</span>: oppNum + <span class="number">1</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; supNum, oppNum &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;vote-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">h2</span> <span class="attr">className</span>=<span class="string">&quot;title&quot;</span>&gt;</span>React是很棒的前端框架<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#x27;num&#x27;</span>&gt;</span>参与人数: &#123; this.state.supNum + this.state.oppNum &#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">VoteMain</span> <span class="attr">supNum</span>=<span class="string">&#123;supNum&#125;</span> <span class="attr">oppNum</span>=<span class="string">&#123;oppNum&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">VoteFooter</span> <span class="attr">change</span>=<span class="string">&#123;this.change&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Vote</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VoteMain ----&gt; 子组件1</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VoteMain</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params">props</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> &#123; supNum, oppNum &#125; = <span class="variable language_">this</span>.<span class="property">props</span> <span class="comment">//解构出要用到的属性</span></span><br><span class="line">    <span class="keyword">let</span> ratio = <span class="string">&#x27;--&#x27;</span></span><br><span class="line">    <span class="keyword">let</span> total = supNum + oppNum</span><br><span class="line">    <span class="keyword">if</span>(total &gt; <span class="number">0</span>) ratio = ( supNum / total * <span class="number">100</span> ).<span class="title function_">toFixed</span>(<span class="number">2</span>) + <span class="string">&#x27;%&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>支持人数: &#123;supNum&#125;人 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>反对人数: &#123;oppNum&#125;人<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>支持比率: &#123; ratio &#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">VoteMain</span></span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VoteFooter ----&gt; 子组件2</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VoteFooter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> &#123; change &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">change.bind</span>(<span class="attr">null</span>, &#x27;<span class="attr">sup</span>&#x27;) &#125;&gt;</span>支持<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">change.bind</span>(<span class="attr">null</span>, &#x27;<span class="attr">opp</span>&#x27;) &#125;&gt;</span>反对<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">VoteFooter</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Redux基础"><a href="#Redux基础" class="headerlink" title="Redux基础"></a>Redux基础</h2><p>Redux是用于存储和处理组件公共状态信息的工具库，类似于Vue中的Vuex<br><strong>Redux工作逻辑</strong></p>
<img src="/2024/03/11/%E6%B5%85%E5%B0%9DReact/image-10.png" class title="This is an image">


<p><strong>逻辑示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> initial = &#123;</span><br><span class="line">  <span class="attr">supNum</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">oppNum</span>: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> reducer = <span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state = initial, action</span>) &#123;</span><br><span class="line">  <span class="comment">//state存储容器中的公共状态</span></span><br><span class="line">  <span class="comment">//action是每一次基于dispatch派发的时候，传递进来的行为对象，要求必须具备type属性，存储派发的行为标识</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//为了接下来的操作中，我们操作state不会直接修改容器中的状态，要等到最后return的时候</span></span><br><span class="line">  state = &#123; ...state &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//需要基于派发的行为标识，修改store容器中的公共状态信息</span></span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;VOTE_SUP&#x27;</span>:</span><br><span class="line">      state.<span class="property">supNum</span>++</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;VOTE_OPP&#x27;</span>:</span><br><span class="line">      state.<span class="property">oppNum</span>++</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//return的内容会整体替换store中的内容</span></span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>

<p>第一次派发时state没有值，会把initial的值赋值给state（第一次派发是在redux内部派发的）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.<span class="title function_">dispatch</span>(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;VOTE_SUP&#x27;</span>,</span><br><span class="line">  <span class="attr">step</span>: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>第二次基于业务逻辑实现手动派发，于switch的第一项匹配，但是<strong>不会</strong>直接修改supNum的值。而是在内部先克隆一份state，然后对这个state进行修改，最后用这个新的state替换掉原来的state</p>
<h3 id="在组件中使用store"><a href="#在组件中使用store" class="headerlink" title="在组件中使用store"></a>在组件中使用store</h3><p>为了在各个组件中都可以获取到store，可以基于上下文的方法：</p>
<ol>
<li>在index.js中，基于ThemeContext.Provider把创建的store放在上下文中</li>
<li>因为所有组件最后都是在index.js中渲染，所有组件都可以理解为index.js的后代组件，后代组件基于上下文方案即可获取在上下文中存储的store了</li>
</ol>
<p><strong>创建一个上下文：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/ThemeContext.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">React</span>.<span class="title function_">createContext</span>() <span class="comment">//创建并导出一个上下文对象</span></span><br></pre></td></tr></table></figure>
<p><strong>在index.js中使用：</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span>; <span class="comment">//导入store</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ThemeContext</span> <span class="keyword">from</span> <span class="string">&#x27;./ThemeContext&#x27;</span> <span class="comment">//导入上下文</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(store);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line">  <span class="comment">// 使用ThemeContext.Provider将store放到上下文中</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">store</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ThemeContext.Provider</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>后代组件（函数组件）获取store：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useContext, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VoteFooter</span> <span class="keyword">from</span> <span class="string">&#x27;./VoteFooter&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VoteMain</span> <span class="keyword">from</span> <span class="string">&#x27;./VoteMain&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ThemeContext</span> <span class="keyword">from</span> <span class="string">&#x27;../ThemeContext&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Vote</span> = <span class="keyword">function</span> <span class="title function_">Vote</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用useContext Hook函数，并将创建的上下文传入</span></span><br><span class="line">  <span class="keyword">const</span> context = <span class="title function_">useContext</span>(<span class="title class_">ThemeContext</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(context);</span><br><span class="line">  <span class="keyword">const</span> &#123; store &#125; = context</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Vote</span>;</span><br></pre></td></tr></table></figure>

<img src="/2024/03/11/%E6%B5%85%E5%B0%9DReact/image-11.png" class title="This is an image">

<p>得到的store中：</p>
<ol>
<li><code>dispatch</code>用于行为派发</li>
<li><code>getState</code>用于获取公共状态信息</li>
<li><code>subscribe</code>用于将实现组件更新的方法放到store的事件池中</li>
</ol>
<p><strong>后代组件（类组件）获取store：</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ThemeContext</span> <span class="keyword">from</span> <span class="string">&quot;../ThemeContext&quot;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VoteMain</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> contextType = <span class="title class_">ThemeContext</span> <span class="comment">//获取上下文信息</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//完成上面的操作之后，会在this上挂载一个context属性，存放着上下文信息</span></span><br><span class="line">    <span class="keyword">const</span> &#123; store &#125; = <span class="variable language_">this</span>.<span class="property">context</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(store)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>支持人数<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>反对人数<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>组件获取公共状态信息：</strong></p>
<p>使用<code>store.getState()</code>方法来获取公共状态信息<br>当组件第一次渲染完毕后，需要把让组件更新的方法放到store的事件池中，这样在状态改变时，才会调用事件来更新视图</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ThemeContext</span> <span class="keyword">from</span> <span class="string">&quot;../ThemeContext&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">VoteMain</span> = <span class="keyword">function</span> <span class="title function_">VoteMain</span>(<span class="params">props</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; store &#125; = <span class="title function_">useContext</span>(<span class="title class_">ThemeContext</span>)</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(store.<span class="title function_">getState</span>()); <span class="comment">//打印结果如下图</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> &#123; supNum, oppNum &#125; = store.<span class="title function_">getState</span>() <span class="comment">//解构出状态</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件第一次渲染完毕，把让组件更新的方法放到store的事件池中</span></span><br><span class="line">  <span class="keyword">let</span> [ _, setNum ] = <span class="title function_">useState</span>(<span class="number">0</span>) <span class="comment">//设置状态变量</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 调用subscribe方法将让组件更新的方法放在store的事件池中</span></span><br><span class="line">    <span class="comment">// 返回unsubscribe方法，调用该方法，可以把刚才放入事件池中的方法移除</span></span><br><span class="line">    <span class="keyword">let</span> unsubscribe = store.<span class="title function_">subscribe</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setNum</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>())</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">unsubscribe</span>() <span class="comment">//在上一次组件释放的时候，销毁上一次放在事件池的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [num])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>支持人数: &#123;supNum&#125;人 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>反对人数: &#123;oppNum&#125;人<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>支持比率: --<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">VoteMain</span></span><br></pre></td></tr></table></figure>

<img src="/2024/03/11/%E6%B5%85%E5%B0%9DReact/image-12.png" class title="This is an image">

<p>类组件中的组件更新策略：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VoteMain</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> contextType = <span class="title class_">ThemeContext</span> <span class="comment">//获取上下文信息</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//完成上面的操作之后，会在this上挂载一个context属性，存放着上下文信息</span></span><br><span class="line">    <span class="keyword">const</span> &#123; store &#125; = <span class="variable language_">this</span>.<span class="property">context</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(store)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>支持人数<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>反对人数<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; store &#125; = <span class="variable language_">this</span>.<span class="property">context</span></span><br><span class="line">    store.<span class="title function_">subscribe</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">forceUpdate</span>() <span class="comment">//直接让组件强制更新</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>组件派发任务：</strong></p>
<p>在组件中调用<code>store.dispatch</code>进行任务派发，通知reducer执行传递的action行为对象</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ThemeContext</span> <span class="keyword">from</span> <span class="string">&quot;../ThemeContext&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">VoteFooter</span> = <span class="keyword">function</span> <span class="title function_">VoteFooter</span>(<span class="params">props</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; store &#125; = <span class="title function_">useContext</span>(<span class="title class_">ThemeContext</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> () =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">        store.dispatch(&#123;</span></span><br><span class="line"><span class="language-xml">          type: &#x27;VOTE_SUP&#x27;</span></span><br><span class="line"><span class="language-xml">        &#125;)</span></span><br><span class="line"><span class="language-xml">      &#125; &#125;&gt;支持<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> () =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">        store.dispatch(&#123;</span></span><br><span class="line"><span class="language-xml">          type: &#x27;VOTE_OPP&#x27;</span></span><br><span class="line"><span class="language-xml">        &#125;)</span></span><br><span class="line"><span class="language-xml">      &#125; &#125;&gt;反对<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">VoteFooter</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Redux工程化"><a href="#Redux工程化" class="headerlink" title="Redux工程化"></a>Redux工程化</h2><p>在项目开发中，要把reducer进行模块化管理，每个模块都有自己的reducer；最后还要把所有的reducer进行合并，合并成一个后赋值给创建的store容器</p>
<p><strong>示例：</strong>有两个模块，vote和personal都需要进行公共状态管理</p>
<p>创建对应的reducer文件和总的reducer文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件夹目录  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// src/store/reducers</span></span><br><span class="line"><span class="comment">// - index.js   ----  最后合成一个总的reducer</span></span><br><span class="line"><span class="comment">// - voteReducer.js  ----  vote模块的reducer</span></span><br><span class="line"><span class="comment">// - personalReducer.js  ----  personal模块的reducer</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后创建不同模块的reducer</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initial = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">VoteReducer</span>(<span class="params">state = initial, action</span>) &#123;</span><br><span class="line">  state = &#123; ...state &#125;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 reducers&#x2F;index.js 中进行reducer合并，调用redux中的<code>combineReducers()</code>方法，传入一个包含各个reducer的对象。</p>
<p>最后用<code>createStore()</code>方法，并传入合并好的reducer创建store容器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 合并各个模块的reducer */</span></span><br><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VoteReducer</span> <span class="keyword">from</span> <span class="string">&#x27;./VoteReducer&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PersonalReducer</span> <span class="keyword">from</span> <span class="string">&#x27;./personalReducer&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="title function_">combineReducers</span>(&#123;</span><br><span class="line">  <span class="attr">vote</span>: <span class="title class_">VoteReducer</span>,</span><br><span class="line">  <span class="attr">personal</span>: <span class="title class_">PersonalReducer</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> reducer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此时容器中的公共状态会按照设置的成员名字进行分模块化管理</span></span><br><span class="line"><span class="comment"> * 基于store.getState()获取到的状态如下：</span></span><br><span class="line"><span class="comment"> * state = &#123;</span></span><br><span class="line"><span class="comment"> *   vote: &#123;</span></span><br><span class="line"><span class="comment"> *     // vote模块中的状态</span></span><br><span class="line"><span class="comment"> *   &#125;,</span></span><br><span class="line"><span class="comment"> *   personal: &#123;</span></span><br><span class="line"><span class="comment"> *     // personal模块中的状态</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取公共状态信息的操作需要按模块获取了，例如<code>store.getState().vote</code>，就能拿到voteReducer中对应的状态<br>在行为派发方法中，<code>store.dispatch</code>会去每个模块中寻找匹配的type，把匹配上的逻辑<strong>都执行一遍</strong>。</p>
</blockquote>
<h3 id="基于宏管理派发标识"><a href="#基于宏管理派发标识" class="headerlink" title="基于宏管理派发标识"></a>基于宏管理派发标识</h3><p>在<code>/src/store</code>目录下新建<code>action-types.js</code>文件，将标识定义在这个文件中，并暴露出去。这样在同一个文件中定义标识，可以防止标识命名重复带来的问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统一管理需要派发的行为标识，保证不会发生命名冲突</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">VOTE_SUP</span> = <span class="string">&quot;VOTE_SUP&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">VOTE_OPP</span> = <span class="string">&quot;VOTE_OPP&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">PERSONAL_SUP</span> = <span class="string">&quot;PERSONAL_SUP&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="action行为对象的管理"><a href="#action行为对象的管理" class="headerlink" title="action行为对象的管理"></a>action行为对象的管理</h3><p>在调用<code>store.dispatch()</code>是需要传入一个行为对象，也可以通过模块化进行管理</p>
<p>在<code>src/store</code>下创建actions文件夹</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件夹目录  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// src/store/actions</span></span><br><span class="line"><span class="comment">// - index.js   ----  最后合成一个总的action</span></span><br><span class="line"><span class="comment">// - voteAction.js  ----  vote模块的action</span></span><br><span class="line"><span class="comment">// - personalAction.js  ----  personal模块的action</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后创建不同模块的action</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="variable constant_">TYPES</span> <span class="keyword">from</span> <span class="string">&#x27;../action-types&#x27;</span></span><br><span class="line"><span class="keyword">const</span> voteAction = &#123;</span><br><span class="line">  <span class="comment">//定义vote模块中需要派发的行为对象， 即调用store.dispatch()是传入的对象</span></span><br><span class="line">  <span class="title function_">support</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="comment">// 返回一个含type属性的派发对象</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="variable constant_">TYPES</span>.<span class="property">VOTE_SUP</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">oppose</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="variable constant_">TYPES</span>.<span class="property">VOTE_OPP</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> voteAction</span><br></pre></td></tr></table></figure>

<p>将各个模块的action文件导入到<code>actions/index.js</code>中合并成一个action</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//actions/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**把各个模块的action合并为一个action */</span></span><br><span class="line"><span class="keyword">import</span> voteAction <span class="keyword">from</span> <span class="string">&quot;./voteAction&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> personalAction <span class="keyword">from</span> <span class="string">&quot;./personalAction&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line">  <span class="attr">vote</span>: voteAction,</span><br><span class="line">  <span class="attr">personal</span>: personalAction</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> action</span><br></pre></td></tr></table></figure>

<p>之后在使用派发的时候，不需要手写派发对象了；只需要调用对应的函数即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.<span class="title function_">dispatch</span>(action.<span class="property">vote</span>.<span class="title function_">support</span>())</span><br></pre></td></tr></table></figure>

<p>最后的目录结构：</p>
<img src="/2024/03/11/%E6%B5%85%E5%B0%9DReact/image-13.png" class title="This is an image">

<h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><p>要在项目中使用redux还是有点复杂，<code>react-redux</code>的作用就是让redux的操作在项目中能简单一点</p>
<p>redux的工程化操作该怎么弄还是怎么弄，react-redux主要是让redux在组件中的应用更方便一些。</p>
<ol>
<li>react-redux内部自己创建了上下文对象，并且我们可以把store放在上下文中，在组件中使用时无需我们自己再获取上下文中的store了</li>
</ol>
<p>这样就不需要要单独创建一个上下文对象了，直接在项目的index.js中引入react-redux中提供的上下文对象，绑定store并使用</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span>; <span class="comment">//自己定义的公共状态容器</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span> <span class="comment">//导入上下文</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line">  &lt;!-- 使用<span class="title class_">Provider</span>，并绑定我们的store --&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;</span> <span class="attr">store</span> &#125;&gt;</span> </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>在组件中获取公共状态信息，无需自己基于上下文对象获取store，直接基于react-redux提供的<code>connect</code>函数处理即可；也不需要我们手动把让组件更新的方法放到事件池中，react-redux内部帮我们处理了</li>
</ol>
<blockquote>
<p><code>connect</code>语法：<code>connect(mapStateToProps, mapDispatchProps)(要渲染的组件)</code></p>
</blockquote>
<blockquote>
<p>mapStateToProps可以获取到redux中的公共状态，然后把状态作为<strong>props属性</strong>传递给组件</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mapStateToProps是一个函数</span></span><br><span class="line"><span class="title function_">connect</span>(<span class="function"><span class="params">state</span> =&gt;</span> &#123; <span class="comment">//state表示存储在redux容器中所有模块的公共状态信息</span></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="comment">//返回的内容就是要作为属性传递给组件的状态</span></span><br><span class="line">    <span class="attr">supNum</span>: state.<span class="property">vote</span>.<span class="property">supNum</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果要把某个redux模块所有状态都作为属性，那就直接返回那个模块</span></span><br><span class="line">  <span class="keyword">return</span> state.<span class="property">vote</span></span><br><span class="line"></span><br><span class="line">&#125;, mapDispatchProps)(组件)</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VoteFooter</span> <span class="keyword">from</span> <span class="string">&#x27;./VoteFooter&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VoteMain</span> <span class="keyword">from</span> <span class="string">&#x27;./VoteMain&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Vote</span> = <span class="keyword">function</span> <span class="title function_">Vote</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> &#123; supNum, oppNum &#125; = props <span class="comment">//在props中解构出状态</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;vote-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">className</span>=<span class="string">&quot;title&quot;</span>&gt;</span>React是很棒的前端框架<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#x27;num&#x27;</span>&gt;</span>参与人数: &#123; supNum + oppNum &#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">VoteMain</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">VoteFooter</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>(<span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">vote</span>)(<span class="title class_">Vote</span>); <span class="comment">//将vote模块的状态都作为属性</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>mapDispatchToProps可以把需要派发的任务当作属性传递给组件</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mapDispatchToProps</span></span><br><span class="line"><span class="comment">//标准、古老的写法</span></span><br><span class="line"><span class="title function_">connect</span>(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123; <span class="comment">//dispatch就是store.dispatch，派发任务的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">//返回的信息将作为属性传递给组件</span></span><br><span class="line">      <span class="title function_">support</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">dispatch</span>(action.<span class="property">vote</span>.<span class="title function_">support</span>())</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">oppose</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">dispatch</span>(action.<span class="property">vote</span>.<span class="title function_">oppose</span>())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//简单的写法</span></span><br><span class="line"><span class="title function_">connect</span>(</span><br><span class="line">  mapSateToProps,</span><br><span class="line">  action.<span class="property">vote</span> <span class="comment">//直接传入我们工程化定义好的模块就行</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<img src="/2024/03/11/%E6%B5%85%E5%B0%9DReact/image-14.png" class title="This is an image">

<p>示例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> action <span class="keyword">from</span> <span class="string">&quot;../store/actions&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">VoteFooter</span> = <span class="keyword">function</span> <span class="title function_">VoteFooter</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> () =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">        props.support() //调用派发的方法</span></span><br><span class="line"><span class="language-xml">      &#125; &#125;&gt;支持<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> () =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">       props.oppose()</span></span><br><span class="line"><span class="language-xml">      &#125; &#125;&gt;反对<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>(</span><br><span class="line">  <span class="literal">null</span>, </span><br><span class="line">  action.<span class="property">vote</span></span><br><span class="line">)(<span class="title class_">VoteFooter</span>);</span><br></pre></td></tr></table></figure>

<h2 id="redux中间件"><a href="#redux中间件" class="headerlink" title="redux中间件"></a>redux中间件</h2><p>redux提供<code>applyMiddleware</code>方法来加载中间件</p>
<p><strong>redux-logger中间件</strong></p>
<p>redux-logger可以记录redux容器的派发任务，以及每个派发对应的新旧状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 安装</span><br><span class="line">npm i redux-logger</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> action <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reduxLogger <span class="keyword">from</span> <span class="string">&#x27;redux-logger&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(</span><br><span class="line">  reducer,</span><br><span class="line">  <span class="title function_">applyMiddleware</span>(reduxLogger) <span class="comment">//使用applyMiddleware注册中间件</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>

<p>当组件触发了任务派发时，控制台就会打印日志：</p>
<img src="/2024/03/11/%E6%B5%85%E5%B0%9DReact/image-15.png" class title="This is an image">


<p><strong>redux-thunk</strong></p>
<p>在不使用任何中间件的情况下，mapDispatchToProps中返回的对象不支持异步操作，必须返回标准的action对象，而不能是一个promise实例</p>
<p>使用redux-thunk可以使其支持异步操作</p>
<p>安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i redux-thunk</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> action <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reduxLogger <span class="keyword">from</span> <span class="string">&#x27;redux-logger&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reduxThunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(</span><br><span class="line">  reducer,</span><br><span class="line">  <span class="title function_">applyMiddleware</span>(reduxLogger, reduxThunk)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br><span class="line"></span><br><span class="line"><span class="comment">// voteAction.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="variable constant_">TYPES</span> <span class="keyword">from</span> <span class="string">&#x27;../action-types&#x27;</span></span><br><span class="line"><span class="keyword">const</span> voteAction = &#123;</span><br><span class="line">  <span class="title function_">support</span>(<span class="params"></span>) &#123; <span class="comment">//定义vote模块中需要派发的行为对象， 即调用store.dispatch()是传入的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// redux-thunk语法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">async</span> (dispatch) =&gt; &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">delay</span>() <span class="comment">//模拟异步操作</span></span><br><span class="line">      <span class="title function_">dispatch</span>(&#123; <span class="comment">//在里面手动派发action对象</span></span><br><span class="line">        <span class="attr">type</span>: <span class="variable constant_">TYPES</span>.<span class="property">VOTE_SUP</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">oppose</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="variable constant_">TYPES</span>.<span class="property">VOTE_OPP</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> voteAction</span><br></pre></td></tr></table></figure>

<p>内部流程：</p>
<ol>
<li>首先support方法执行返回一个函数（也是对象），内部给函数自动<strong>设置一个type属性</strong>，不过该属性值不会和reducer中的任何type匹配，所以不会修改任何状态</li>
<li>接着把返回的函数执行，把派发函数dispatch作为参数传递给它；在函数中完成异步操作，然后手动基于dispatch进行派发</li>
</ol>
<p>所以总共是派发<strong>两次</strong>：</p>
<ul>
<li>第一次派发的是执行的函数，但不会修改任何状态</li>
<li>第二次派发的才会修改状态</li>
</ul>
<p><strong>redux-promise</strong></p>
<p>redux-promise也可以用于处理异步操作，使用起来<strong>更简洁</strong></p>
<p>安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i redux-promise</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> action <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reduxLogger <span class="keyword">from</span> <span class="string">&#x27;redux-logger&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reduxPromise <span class="keyword">from</span> <span class="string">&#x27;redux-promise&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(</span><br><span class="line">  reducer,</span><br><span class="line">  <span class="title function_">applyMiddleware</span>(reduxLogger, reduxPromise)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br><span class="line"></span><br><span class="line"><span class="comment">// voteAction.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="variable constant_">TYPES</span> <span class="keyword">from</span> <span class="string">&#x27;../action-types&#x27;</span></span><br><span class="line"><span class="keyword">const</span> voteAction = &#123;</span><br><span class="line">  <span class="title function_">support</span>(<span class="params"></span>) &#123; <span class="comment">//定义vote模块中需要派发的行为对象， 即调用store.dispatch()是传入的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// redux-promise语法，和正常用异步操作一样</span></span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">support</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">delay</span>()</span><br><span class="line">      <span class="keyword">return</span> &#123; </span><br><span class="line">        <span class="attr">type</span>: <span class="variable constant_">TYPES</span>.<span class="property">VOTE_SUP</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">oppose</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="variable constant_">TYPES</span>.<span class="property">VOTE_OPP</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> voteAction</span><br></pre></td></tr></table></figure>

<h2 id="React-router"><a href="#React-router" class="headerlink" title="React-router"></a>React-router</h2><h3 id="版本5"><a href="#版本5" class="headerlink" title="版本5"></a>版本5</h3><p>安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i react-router-dom@5</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<ol>
<li>导入<code>react-router-dom</code>包</li>
<li>在src&#x2F;index.js中引入<code>BrowserRouter</code>组件，并将它包裹在根组件外面（也可以使用<code>HashRouter</code>组件，两者在开发环境下并没有太大区别）</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BrowserRouter</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>使用Route组件来映射地址和组件，它有如下属性：</p>
<ol>
<li><code>path</code> 映射的url地址</li>
<li><code>component</code> 要挂载的组件</li>
<li><code>render</code> 和component一样用于挂载组件，render要求传递一个回调函数，回调函数的返回值会被挂载<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Route</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Comp1</span> <span class="keyword">from</span> <span class="string">&#x27;./components/comp1&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Comp2</span> <span class="keyword">from</span> <span class="string">&#x27;./components/comp2&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Comp1&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/comp2&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Comp2&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<img src="/2024/03/11/%E6%B5%85%E5%B0%9DReact/image-16.png" class title="This is an image">

<p>又上图可以看到，我们访问的是<code>/comp2</code>的路由，但是comp1也被渲染出来了，这是因为Route默认并<strong>不是严格匹配</strong>，只有url地址的头部和path一致，组件就会挂载</p>
<p>想要严格匹配，需要在Route组件上增加<code>exact</code>属性：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> exact path=<span class="string">&#x27;/comp2&#x27;</span> component=&#123;<span class="title class_">Comp2</span>&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p>通过<code>component</code>构建的组件，会自动传递参数，可以在组件中通过props属性接收到：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Comp2</span> = <span class="keyword">function</span> <span class="title function_">Comp2</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(props); <span class="comment">//打印传递的参数</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;comp1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是comp-2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Comp2</span></span><br></pre></td></tr></table></figure>
<img src="/2024/03/11/%E6%B5%85%E5%B0%9DReact/image-19.png" class title="This is an image">

<p>其中：</p>
<ol>
<li><code>match</code>表示匹配的信息</li>
<li><code>location</code>表示地址的信息</li>
<li><code>history</code>表示历史信息，一般用于控制路由跳转</li>
</ol>
<p>通过<code>render</code>挂载的组件获取不到上述属性，需要手动传入</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> exact path=<span class="string">&#x27;/comp2&#x27;</span> render=&#123;<span class="function">(<span class="params">routeProps</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(routeProps) <span class="comment">//获取到的routeProps就是上述的属性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Comp2</span> <span class="attr">route</span>=<span class="string">&#123;routeProps&#125;</span> /&gt;</span></span> <span class="comment">//通过props传入</span></span><br><span class="line">&#125;&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p><strong>Link 和 NavLink</strong></p>
<p>可以使用<code>Link</code>组件来创建常规链接，它的<code>to</code>属性表示映射的url地址</p>
<p><code>NavLink</code>组件和<code>Link</code>组件的使用方法类似，唯一的区别就是可以为<code>NavLink</code>设置激活的样式状态，通过设置<code>activeClassName</code>属性或者<code>activeStyle</code>属性实现</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Route</span>, <span class="title class_">Link</span>, <span class="title class_">NavLink</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Comp1</span> <span class="keyword">from</span> <span class="string">&#x27;./components/comp1&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Comp2</span> <span class="keyword">from</span> <span class="string">&#x27;./components/comp2&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Link</span> <span class="attr">exact</span> <span class="attr">to</span>=<span class="string">&#x27;/comp1&#x27;</span>&gt;</span>comp1<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">exact</span> <span class="attr">to</span>=<span class="string">&#x27;/comp2&#x27;</span> <span class="attr">activeClassName</span>=<span class="string">&#123;active&#125;</span>&gt;</span>comp2<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/comp1&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Comp1&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/comp2&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Comp2&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2024/03/11/%E6%B5%85%E5%B0%9DReact/image-17.png" class title="This is an image">
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/React/">React</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2024 chen qiyi
    
  </p>
</footer>
    
    
  </div>
</div>
<script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>
<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>easycodesniper | blog by chen qiyi</title>

  
  <meta name="author" content="chen qiyi">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="easycodesniper"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="easycodesniper" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">easycodesniper</a>
    </h1>
    <p class="site-description">blog by chen qiyi</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/about">关于</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2024/06/04/Prompt/"><span>Prompt</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/06/04/Prompt/" rel="bookmark">
        <time class="entry-date published" datetime="2024-06-04T14:05:55.000Z">
          2024-06-04
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有效地与大型语言模型交流已成为一种关键技能。在<a target="_blank" rel="noopener" href="https://platform.openai.com/docs/guides/prompt-engineering">openAI 的官方文档</a>中已经给出了最佳实践——如何精心构建问题（prompt engineering），以便从这些大模型中获得最准确、最相关的答案。正确认识并运用这些技巧。</p>
<p>在我的这篇文章中，将总结概括如何编写优秀的 prompt</p>
<h2 id="编写详细的指示-大模型不是你肚子里的蛔虫"><a href="#编写详细的指示-大模型不是你肚子里的蛔虫" class="headerlink" title="编写详细的指示 - 大模型不是你肚子里的蛔虫"></a>编写详细的指示 - 大模型不是你肚子里的蛔虫</h2><p>大模型无法读懂你的想法，它只能根据你给他的信息来返回结果。因此，你需要确保你的 prompt 包含足够的信息，以便大模型理解你的意图。</p>
<p>大模型不会嫌弃你啰嗦，你对问题描述的越详细，你越有可能得到想要的结果。</p>
<p>以下是一些编写 prompt 的策略：</p>
<h4 id="1-详细描述你的问题，才能得到更相关的回答"><a href="#1-详细描述你的问题，才能得到更相关的回答" class="headerlink" title="1. 详细描述你的问题，才能得到更相关的回答"></a>1. 详细描述你的问题，才能得到更相关的回答</h4><p>为了获得高度相关的回复，请确保请求提供了任何重要的细节或上下文。否则你就把它留给模型去猜你的意思了。</p>
<p><strong>Worse Prompt</strong>: 帮我编写一段代码来计算斐波那契数列</p>
<p>得到的回复：</p>
<img src="/2024/06/04/Prompt/image.png" class title="This is an image">

<p><strong>Better Prompt</strong>: 写一个 JavaScript 函数来正确高效地计算斐波那契数列，并在关键步骤处给出注释，以解释每个部分的作用以及为什么要这么写</p>
<p>得到的回复：</p>
<img src="/2024/06/04/Prompt/image-1.png" class title="This is an image">
<img src="/2024/06/04/Prompt/image-2.png" class title="This is an image">

<h4 id="2-给大模型一个人设，也给用户一个人设"><a href="#2-给大模型一个人设，也给用户一个人设" class="headerlink" title="2. 给大模型一个人设，也给用户一个人设"></a>2. 给大模型一个人设，也给用户一个人设</h4><p>可以指定大模型在回复时的人设，一个合适且恰当的人设能让大模型更好地响应你的问题。</p>
<p><strong>Worse Prompt</strong>: 向我解释一下计算机网络的 OSI 模型</p>
<p>得到的回复：</p>
<img src="/2024/06/04/Prompt/image-3.png" class title="This is an image">

<p><strong>Better Prompt（给大模型一个人设）</strong>: 你是一个网络工程师，向我解释一下计算机网络的 OSI 模型</p>
<p>得到的回复：</p>
<img src="/2024/06/04/Prompt/image-4.png" class title="This is an image">

<p><strong>Better Prompt（给用户一个人设）</strong>: 我是一个 10 岁的孩子，向我解释一下计算机网络的 OSI 模型</p>
<p>得到的回复：</p>
<img src="/2024/06/04/Prompt/image-5.png" class title="This is an image">

<h4 id="3-使用分隔符清楚的指示提问的不同部分"><a href="#3-使用分隔符清楚的指示提问的不同部分" class="headerlink" title="3. 使用分隔符清楚的指示提问的不同部分"></a>3. 使用分隔符清楚的指示提问的不同部分</h4><p>分隔符例如三引号、XML 标记、章节标题等，可以帮助区分文本的不同部分。</p>
<p><strong>Better Prompt</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1: 使用XML标记作为分隔符</span><br><span class="line"></span><br><span class="line">你将获得关于同一主题的两篇文章(用XML标记分隔)。首先总结每篇文章的论点。然后指出哪一个论点更站得住脚并解释原因。</span><br><span class="line"></span><br><span class="line">&lt;article&gt; insert first article here &lt;/article&gt;</span><br><span class="line">&lt;article&gt; insert second article here &lt;/article&gt;</span><br><span class="line"></span><br><span class="line">示例 2: 使用三引号作为分隔符</span><br><span class="line"></span><br><span class="line">总结用三引号分隔的文本</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;insert text here&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="4-指定完成任务所需的步骤"><a href="#4-指定完成任务所需的步骤" class="headerlink" title="4. 指定完成任务所需的步骤"></a>4. 指定完成任务所需的步骤</h4><p>指定完成任务所需的步骤，大模型会按照步骤执行，而不是直接给出最终答案。这可以确保大模型理解你的意图，并正确地执行任务。</p>
<p><strong>Worse Prompt</strong>: 请帮我写一篇关于 xxx 的热点新闻的解读</p>
<p><strong>Better Prompt</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请你按照下列步骤来给我撰写一篇关于xxx的热点新闻的解读</span><br><span class="line">Step 1: 检索关于xxx的新闻，选取热度较高的3篇新闻</span><br><span class="line">Step 2: 对3篇新闻进行摘要，并分析其核心观点和原因，先形成解读的目录框架</span><br><span class="line">Step 3: 根据目录框架，对3篇新闻进行详细解读，并解释其观点和原因</span><br></pre></td></tr></table></figure>

<h4 id="5-向大模型提供例子"><a href="#5-向大模型提供例子" class="headerlink" title="5. 向大模型提供例子"></a>5. 向大模型提供例子</h4><p><strong>Worse Prompt</strong>: 我是一个前端初学者，请给我推荐一篇关于 css 的文章</p>
<p>得到的回复：</p>
<img src="/2024/06/04/Prompt/image-6.png" class title="This is an image">

<p><strong>Better Prompt</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我是一个前端初学者，请给我推荐一篇关于css的文章，按照 四等号 中的示例回复我：</span><br><span class="line"></span><br><span class="line">====</span><br><span class="line">文章名称：xxx</span><br><span class="line">文章链接：xxx</span><br><span class="line">推荐理由：xxx</span><br><span class="line">====</span><br></pre></td></tr></table></figure>

<p>得到的回复：</p>
<img src="/2024/06/04/Prompt/image-7.png" class title="This is an image">

<h4 id="6-指定大模型返回的长度"><a href="#6-指定大模型返回的长度" class="headerlink" title="6. 指定大模型返回的长度"></a>6. 指定大模型返回的长度</h4><p>你可以要求模型生成具有给定目标长度的输出，目标输出长度可以根据单词、句子、段落、项目符号等的数量来指定。</p>
<p>但是请注意，指示模型生成特定数量的单词并不能达到高精度。模型可以更可靠地生成具有特定数量的段落或要点的输出。</p>
<p><strong>Better Prompt</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例 1: 用三引号分隔的文本在50个单词内进行总结。</span><br><span class="line">示例 2: 用两段话总结用三引号分隔的文本。</span><br><span class="line">示例 3: 用3个要点总结三引号分隔的文本。</span><br></pre></td></tr></table></figure>

<h2 id="向大模型提供参考文本"><a href="#向大模型提供参考文本" class="headerlink" title="向大模型提供参考文本"></a>向大模型提供参考文本</h2><p>大模型可以通过自由地发挥来回答你的提问，特别是当被问及深奥的话题或引用和 url 时，这就会导致大模型回复给用户了一个假答案</p>
<p>为大模型提供参考文本可以限制它的过度自由发挥，同时也减少得到假答案的可能性</p>
<p>如果我们可以为模型提供与当前查询相关的可信信息，那么我们可以指示模型使用提供的信息来组成它的答案。</p>
<p><strong>Better Prompt</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用三引号分隔的文章回答问题。如果在文章中找不到答案，就写“我找不到答案”。</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;insert article here&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">问题：xxx</span><br></pre></td></tr></table></figure>

<p>考虑到所有模型都有有限的上下文窗口，我们需要一些方法来动态查找与所问问题相关的信息 — 这就是需要用到 <strong>知识库</strong> 了</p>
<h2 id="将复杂的任务拆分为更简单的子任务"><a href="#将复杂的任务拆分为更简单的子任务" class="headerlink" title="将复杂的任务拆分为更简单的子任务"></a>将复杂的任务拆分为更简单的子任务</h2><p>正如将复杂系统分解为一组模块化组件是软件工程中的良好实践一样，提交给语言模型的任务也是如此。复杂任务往往比简单任务的错误率更高。</p>
<p>此外，复杂的任务通常可以重新定义为简单任务的工作流，其中早期任务的输出用于构造后续任务的输入。</p>
<p>对于需要大量独立指令来处理不同情况的任务，首先对查询类型进行分类，并使用该分类来确定需要执行哪些指令。还可以递归地应用此过程，将任务分解为一系列阶段。这可以通过定义固定类别和硬编码与处理给定类别中的任务相关的指令来实现。</p>
<p><strong>Better Prompt</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//  先对用户查询进行分类，类似于定义不同的功能分支</span><br><span class="line"></span><br><span class="line">您将获得客户服务查询。将每个查询划分为主要类别和次要类别。根据主要类别和次要类别给出你的回复。</span><br><span class="line">主要类别：前端 和 后端</span><br><span class="line">次要类别：</span><br><span class="line">  前端次要类别：ui设计 和 接口调用</span><br><span class="line">  后端次要类别：bug修复 和 接口开发</span><br><span class="line"></span><br><span class="line">//  根据分类，给出对应的回复</span><br><span class="line"></span><br><span class="line">当用户询问你的上下文涉及「ui设计」时，请按照以下步骤为用户提供帮助：</span><br><span class="line">- Step 1：询问用户 ui 的类型，例如：按钮、输入框、弹窗等</span><br><span class="line">- Step 2: 询问用户要设计的 ui 的大致样式，例如尺寸、颜色、字体等</span><br><span class="line">- Step 3: 根据用户要求给出ui设计的html 和 css代码，并询问用户是否对此满意</span><br><span class="line">- Step 4: 如果用户满意，则 接着询问用户该ui是否需要设计JS逻辑；否则，重复步骤 1 和 2</span><br><span class="line">- Step 5: 如果用户需要设计JS逻辑，则根据用户需求给出JS代码；如果用户不需要设计JS逻辑，则结束</span><br><span class="line"></span><br><span class="line">当用户询问你的上下文涉及「接口调用」时，请按照以下步骤为用户提供帮助：</span><br><span class="line">- Step 1: 询问用户接口类型、接口url 和 接口参数</span><br><span class="line">- Step 2: 询问用户是否指定某个工具库进行网络请求，如果用户未指定，则默认使用axios来编写请求</span><br><span class="line">- Step 3: 根据用户需求给出请求代码，并询问用户是否对此满意</span><br><span class="line">- Step 4: 如果用户满意，则 结束；否则，重复步骤 1 和 2</span><br><span class="line"></span><br><span class="line">当用户询问你的上下文涉及「bug修复」时，请按照以下步骤为用户提供帮助：</span><br><span class="line">- Step 1: 询问用户bug的位置、bug描述和bug截图</span><br><span class="line">- Step 2: 根据用户需求给出修复代码，并询问用户是否对此满意</span><br><span class="line">- Step 3: 如果用户满意，则 结束；否则，重复步骤 1 和 2</span><br><span class="line"></span><br><span class="line">当用户询问你的上下文涉及「接口开发」时，请按照以下步骤为用户提供帮助：</span><br><span class="line">- Step 1: 询问用户接口类型、接口url 和 接口参数</span><br><span class="line">- Step 2: 询问用户使用什么编程语言或者框架来编写接口代码，如果用户未指定，则默认使用Java</span><br><span class="line">- Step 3: 根据用户需求给出接口代码，并询问用户是否对此满意</span><br><span class="line">- Step 4: 如果用户满意，则 结束；否则，重复步骤 1 和 2</span><br><span class="line"></span><br><span class="line">如果你已经理解上述内容，请回复我「已理解」，我会在下一条问题中咨询你问题，请根据上述内容进行匹配和回答。</span><br></pre></td></tr></table></figure>

<p><strong>使用这种方法的好处就在于：</strong></p>
<p>通过发出特殊字符串来指示模型，以指示对话状态何时发生变化。这使我们能够将系统转换为状态机，其中状态决定注入哪些指令。通过跟踪状态，与该状态相关的指令，以及可选的允许从该状态转换的状态。</p>
<p>得到的回复：</p>
<img src="/2024/06/04/Prompt/image-8.png" class title="This is an image">
<img src="/2024/06/04/Prompt/image-9.png" class title="This is an image">
<img src="/2024/06/04/Prompt/image-10.png" class title="This is an image">
<img src="/2024/06/04/Prompt/image-11.png" class title="This is an image">

<h2 id="给模型时间去「思考」"><a href="#给模型时间去「思考」" class="headerlink" title="给模型时间去「思考」"></a>给模型时间去「思考」</h2><p>当试图立即回答问题时，模型会犯更多的推理错误，而不是花时间找出答案。在回答问题之前询问“思维链”可以帮助模型更可靠地推理出正确的答案。</p>
<h4 id="1-在匆忙得出结论之前，指示模型自己找出解决方案"><a href="#1-在匆忙得出结论之前，指示模型自己找出解决方案" class="headerlink" title="1. 在匆忙得出结论之前，指示模型自己找出解决方案"></a>1. 在匆忙得出结论之前，指示模型自己找出解决方案</h4><p>当我们明确地指示模型在得出结论之前从第一原则进行推理时，我们会得到更好的结果。例如，假设我们需要一个模型来评估学生对数学问题的解决方案。最明显的解决方法就是简单地询问模型学生的解决方案是否正确。</p>
<p>来看下面的例子：</p>
<p><strong>Worse Prompt</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">用户：</span><br><span class="line"></span><br><span class="line">判断学生的答案是否正确。</span><br><span class="line"></span><br><span class="line">问题陈述:我正在建造一个太阳能装置，我需要帮助来解决财务问题。</span><br><span class="line">-土地成本为每平方英尺100美元</span><br><span class="line">-我能以每平方英尺250美元的价格买到太阳能电池板</span><br><span class="line">-我谈了一份维护合同，每年要花我10万美元，每平方英尺还要额外花10美元</span><br><span class="line">第一年运营的总成本是多少作为平方英尺数的函数?</span><br><span class="line"></span><br><span class="line">学生解答:设x为装置面积，单位为平方英尺。</span><br><span class="line">1. 土地成本:100倍</span><br><span class="line">2. 太阳能电池板成本:250倍</span><br><span class="line">3. 维护费用:10万+ 100倍</span><br><span class="line">总成本:100x + 250x + 100000 + 100x = 450x + 100000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">大模型回复： 解决方案正确！</span><br></pre></td></tr></table></figure>

<p>但是这个学生的答案其实是<strong>不正确</strong>的!</p>
<p>在我们可以通过提示<strong>模型首先生成自己的解决方案</strong>来让模型成功地注意到这一点，即让模型先自己进行思考。</p>
<p><strong>Better Prompt</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">用户：</span><br><span class="line"></span><br><span class="line">首先想出你自己解决这个问题的办法。然后将你的解决方案与学生的解决方案进行比较，并评估学生的解决方案是否正确。在你自己做了这道题之前，不要判断这个学生的答案是否正确。</span><br><span class="line"></span><br><span class="line">问题陈述:我正在建造一个太阳能装置，我需要帮助来解决财务问题。</span><br><span class="line">-土地成本为每平方英尺100美元</span><br><span class="line">-我能以每平方英尺250美元的价格买到太阳能电池板</span><br><span class="line">-我谈了一份维护合同，每年要花我10万美元，每平方英尺还要额外花10美元</span><br><span class="line">第一年运营的总成本是多少作为平方英尺数的函数?</span><br><span class="line"></span><br><span class="line">学生解答:设x为装置面积，单位为平方英尺。</span><br><span class="line">1. 土地成本:100倍</span><br><span class="line">2. 太阳能电池板成本:250倍</span><br><span class="line">3. 维护费用:10万+ 100倍</span><br><span class="line">总成本:100x + 250x + 100000 + 100x = 450x + 100000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">大模型回复：</span><br><span class="line"></span><br><span class="line">设x为装置面积，单位为平方英尺。</span><br><span class="line">1. 土地成本:100倍</span><br><span class="line">2. 太阳能电池板成本:250倍</span><br><span class="line">3. 维护费用:10万+ 10倍</span><br><span class="line">总成本:100x + 250x + 100000 + 10x = 360x + 100000</span><br><span class="line"></span><br><span class="line">这个学生的答案不正确。他们在维修成本计算中犯了一个错误，用100倍代替10倍。第一年运营的正确总成本是360x + 100,000。</span><br></pre></td></tr></table></figure>

<h4 id="2-使用内心独白或查询序列来隐藏模型的推理过程"><a href="#2-使用内心独白或查询序列来隐藏模型的推理过程" class="headerlink" title="2. 使用内心独白或查询序列来隐藏模型的推理过程"></a>2. 使用内心独白或查询序列来隐藏模型的推理过程</h4><p>前面的策略表明，在回答特定问题之前，模型有时对问题进行详细的推理是很重要的。</p>
<p>对于某些应用程序，模型用于得出最终答案的推理过程可能不适合与用户共享。例如，在辅导应用程序中，我们可能希望鼓励学生自己找出答案，但模型对学生解决方案的推理过程可能会向学生揭示答案。</p>
<p>内心独白是一种可以用来缓解这种情况的策略。内心独白的思想是指示模型将对用户隐藏的部分输出放入结构化格式中，以便于解析它们。然后，在将输出呈现给用户之前，对输出进行解析，只显示想要给用户看到的部分。</p>
<p><strong>Better Prompt</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">你作为一个专业和资深数学老师，判断学生的答案是否正确。</span><br><span class="line"></span><br><span class="line">按照以下步骤回答用户查询，先不要输出任何三引号(&quot;&quot;&quot;)中的内容，等执行完所有步骤时再根据步骤的要求输出应该输出的内容。</span><br><span class="line"></span><br><span class="line">Step 1: 首先找出你自己解决问题的方法。不要依赖学生的答案，因为它可能是错误的。将此步骤的所有工作用三引号(&quot;&quot;&quot;)括起来。</span><br><span class="line"></span><br><span class="line">Step 2: 将你的解决方案与学生的解决方案进行比较，并评估学生的解决方案是否正确。将此步骤的所有工作用三引号(&quot;&quot;&quot;)括起来。</span><br><span class="line"></span><br><span class="line">Step 3: 如果学生犯了一个错误，确定你可以给学生什么提示而不泄露答案。将此步骤的所有工作用三引号(&quot;&quot;&quot;)括起来。</span><br><span class="line"></span><br><span class="line">Step 4: 如果学生犯了错误，只给学生提供上一步的提示，不要输出三引号中的内容。不要写“Step 4: .....”，而要写“提示: ...”。</span><br><span class="line"></span><br><span class="line">如果你已经理解上述内容，请回复我「已理解」，我会在下一条问题中给出数学问题 和 学生的解决方案，请根据上述内容进行匹配和回答。</span><br></pre></td></tr></table></figure>

<p>测试 Prompt：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">用户：</span><br><span class="line"></span><br><span class="line">问题陈述:我正在建造一个太阳能装置，我需要帮助来解决财务问题。</span><br><span class="line">-土地成本为每平方英尺100美元</span><br><span class="line">-我能以每平方英尺250美元的价格买到太阳能电池板</span><br><span class="line">-我谈了一份维护合同，每年要花我10万美元，每平方英尺还要额外花10美元</span><br><span class="line">第一年运营的总成本是多少作为平方英尺数的函数?</span><br><span class="line"></span><br><span class="line">学生解答:设x为装置面积，单位为平方英尺。</span><br><span class="line">1. 土地成本:100倍</span><br><span class="line">2. 太阳能电池板成本:250倍</span><br><span class="line">3. 维护费用:10万+ 100倍</span><br><span class="line">总成本:100x + 250x + 100000 + 100x = 450x + 100000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">大模型：</span><br><span class="line"></span><br><span class="line">提示: 请检查维护合同中变量成本的计算，确保每平方英尺的额外费用被正确计算。</span><br></pre></td></tr></table></figure>


      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/prompt-大模型/">prompt 大模型</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/05/06/React-query/"><span>React-query</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/05/06/React-query/" rel="bookmark">
        <time class="entry-date published" datetime="2024-05-06T13:35:58.000Z">
          2024-05-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="查询-queries"><a href="#查询-queries" class="headerlink" title="查询 queries"></a>查询 queries</h2><blockquote>
<p>对于query的定义，在官方文档中是这么说的：<br>“A query is a declarative dependency on an asynchronous source of data that is tied to a unique key” 翻译过来是：查询是对绑定到唯一键的异步数据源的声明性依赖项</p>
</blockquote>
<p>我对于query的理解是：将一个<strong>唯一的key（unique key）</strong> 与 一个<strong>获取数据的方法</strong> 进行绑定</p>
<p>你可以在组件中或者hook中，使用 <strong><code>useQuery</code></strong> 来订阅一个查询</p>
<p><code>useQuery</code> <strong>至少需要</strong>接受两个参数：</p>
<ul>
<li>key：该查询的唯一键值</li>
<li>fn：一个返回Promise的函数，能解析出数据或者抛出错误（即具体的请求数据的函数）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useQuery &#125; <span class="keyword">from</span> <span class="string">&#x27;@tanstack/react-query&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 具体获取数据的函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">getUserInfo</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">axios</span>(<span class="string">&#x27;/api/useInfo&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅一个查询</span></span><br><span class="line">    <span class="keyword">const</span> userInfo = <span class="title function_">useQuery</span>(&#123;</span><br><span class="line">        <span class="attr">queryKey</span>: [<span class="string">&#x27;useData&#x27;</span>],</span><br><span class="line">        <span class="attr">queryFn</span>: getUserInfo </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个唯一的<strong>key</strong>值，将在内部用于重新获取、缓存和在整个项目中共享该查询的信息</p>
</blockquote>
<p><code>useQuery</code>的返回结果包含了你需要用到的绝大部分信息，这也正是使用react-query的一个好处，可以提高开发效率</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  接上面例子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; isLoading, isError, isSuccess, data, error, status &#125; = <span class="title function_">useQuery</span>(&#123;</span><br><span class="line">    <span class="attr">queryKey</span>: [<span class="string">&#x27;useData&#x27;</span>],</span><br><span class="line">    <span class="attr">queryFn</span>: getUserInfo </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>首先是结果中会返回一些比较重要的状态：</p>
<ul>
<li>布尔值<code>isLoading</code> 或者 <code>status === &#39;loading&#39;</code> 表示查询暂时还没有数据</li>
<li>布尔值<code>isError</code> 或者 <code>status === &#39;error&#39;</code> 表示查询遇到了错误</li>
<li>布尔值<code>isSuccess</code> 或者 <code>status === &#39;success&#39;</code> 表示查询成功，数据可用</li>
</ul>
<blockquote>
<p>可以看出 status 和 isLoading、isError、isSuccess的作用是差不多的，关键在于你习惯于使用谁来进行判断</p>
</blockquote>
<p>然后是一些重要的信息：</p>
<ul>
<li><code>error</code> 如果查询处于<code>isError</code>状态,可以获取到错误的具体信息</li>
<li><code>data</code> 如果查询处于<code>isSuccess</code>状态，可以获取到请求的数据</li>
</ul>
<p>下面是一个简单的例子，来整体演示使用<code>useQuery</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useQuery &#125; <span class="keyword">from</span> <span class="string">&#x27;@tanstack/react-query&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 具体获取数据的函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">getUserInfo</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">axios</span>(<span class="string">&#x27;/api/useInfo&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅一个查询</span></span><br><span class="line">    <span class="keyword">const</span> &#123; isLoading, isError, isSuccess, data, error, status &#125; = <span class="title function_">useQuery</span>(&#123;</span><br><span class="line">        <span class="attr">queryKey</span>: [<span class="string">&#x27;useData&#x27;</span>],</span><br><span class="line">        <span class="attr">queryFn</span>: getUserInfo </span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status === <span class="string">&quot;loading&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status === <span class="string">&quot;error&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Error: &#123;error.message&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">div</span>&gt;</span>userName: &#123;data.userName&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">div</span>&gt;</span>age: &#123;data.age&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询键值-queryKey"><a href="#查询键值-queryKey" class="headerlink" title="查询键值 queryKey"></a>查询键值 queryKey</h3><p><strong>在react-query内部基于queryKey来管理查询缓存</strong></p>
<p>queryKey必须是一个<strong>数组</strong>，对数组内部的结构没有过多的限制，该数组可以简单的由一个或多个字符串构成，也可以是包含许多嵌套对象的数组。</p>
<ol>
<li>最简单的形式</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useQuery</span>(&#123; </span><br><span class="line">  <span class="attr">queryKey</span>: [<span class="string">&#x27;userData&#x27;</span>], </span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>复杂的形式</li>
</ol>
<p>当查询需要更多的信息来唯一的描述数据时，数组可以是 字符串 加上 任意数量的可序列化对象的形式 </p>
<p>常见的场景有：需要传递参数来进行查询</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 userId 查询数据</span></span><br><span class="line"><span class="keyword">let</span> userId = <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line"><span class="title function_">useQuery</span>(&#123; </span><br><span class="line">  <span class="attr">queryKey</span>: [<span class="string">&#x27;useInfo&#x27;</span>, userId], </span><br><span class="line">  ... </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询特定type的数据</span></span><br><span class="line"><span class="title function_">useQuery</span>(&#123; </span><br><span class="line">  <span class="attr">queryKey</span>: [<span class="string">&#x27;xxxx&#x27;</span>, &#123; <span class="attr">type</span>: <span class="string">&#x27;xxx&#x27;</span> &#125;] </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<p><strong>注意：</strong><br>queryKey的散列是确定的，即 <strong>顶层数组中</strong>各个<strong>key不同的排列顺序</strong>会被认为是<strong>不同的查询键值</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两个的查询键值不相等，因为顶层数组中各key的排列顺序不同</span></span><br><span class="line"><span class="title function_">useQuery</span>(&#123; <span class="attr">queryKey</span>: [<span class="string">&#x27;todos&#x27;</span>, status, page], ... &#125;)</span><br><span class="line"><span class="title function_">useQuery</span>(&#123; <span class="attr">queryKey</span>: [<span class="string">&#x27;todos&#x27;</span>, page, status], ...&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两个的查询键值是相等的，顶层数组中各key的排列顺序相同，嵌套对象中的排列顺序不影响</span></span><br><span class="line"><span class="title function_">useQuery</span>(&#123; <span class="attr">queryKey</span>: [<span class="string">&#x27;todos&#x27;</span>, &#123; status, page &#125;], ... &#125;)</span><br><span class="line"><span class="title function_">useQuery</span>(&#123; <span class="attr">queryKey</span>: [<span class="string">&#x27;todos&#x27;</span>, &#123; page, status &#125;], ...&#125;)</span><br></pre></td></tr></table></figure>


<h3 id="查询函数-queryFn"><a href="#查询函数-queryFn" class="headerlink" title="查询函数 queryFn"></a>查询函数 queryFn</h3><blockquote>
<p>官方文档对queryFn的定义：A query function can be literally any function that returns a promise. The promise that is returned should either resolve the data or throw an error.</p>
</blockquote>
<p>即：<strong>queryFn可以是任何形式的函数，必须返回一个promise，并且返回的promise应该 给出数据 或者 抛出错误</strong></p>
<ol>
<li>queryFn的参数</li>
</ol>
<p>queryFn默认接受一个<code>queryFunctionContext</code>参数，该参数是一个对象，主要包含以下属性：</p>
<ul>
<li>queryKey：即整个queryKey数组</li>
<li>pageParam：在 无限查询 中会使用到，包含查询当前页所使用的参数</li>
<li>signal：用作 查询取消</li>
<li>meta：可以填写任意关于该查询的额外信息</li>
</ul>
<p>由上可知，queryKey不仅可以用于唯一的标识查询，也可以作为参数传递给queryFn</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useQuery</span>(&#123;  </span><br><span class="line">  <span class="attr">queryKey</span>: [<span class="string">&#x27;useData&#x27;</span>, useId],</span><br><span class="line">  <span class="attr">queryFn</span>: getUserData     </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getUserData</span> = <span class="keyword">async</span> (<span class="params">&#123; queryKey &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [ _key, useId ] = queryKey</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/api/useData&#x27;</span> + useId)</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>抛出和处理错误</li>
</ol>
<p>为了使 React Query 确定查询错误，查询函数的错误必须抛出或返回rejected Promise。查询函数中引发的任何错误都将被持久化在查询的error状态中</p>
<h2 id="并行查询"><a href="#并行查询" class="headerlink" title="并行查询"></a>并行查询</h2><p>并行查询即并行的执行多个查询，或者说同时执行的查询</p>
<ol>
<li>如果需要并行查询的数量较少且固定，可以使用手动的并行查询</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span> () &#123;</span><br><span class="line">  <span class="comment">// 下面的查询将自动地并行执行</span></span><br><span class="line">  <span class="keyword">const</span> usersQuery = <span class="title function_">useQuery</span>(&#123; <span class="attr">queryKey</span>: [<span class="string">&#x27;users&#x27;</span>], <span class="attr">queryFn</span>: fetchUsers &#125;);</span><br><span class="line">  <span class="keyword">const</span> teamsQuery = <span class="title function_">useQuery</span>(&#123; <span class="attr">queryKey</span>: [<span class="string">&#x27;teams&#x27;</span>], <span class="attr">queryFn</span>: fetchTeams &#125;);</span><br><span class="line">  <span class="keyword">const</span> projectsQuery = <span class="title function_">useQuery</span>(&#123; <span class="attr">queryKey</span>: [<span class="string">&#x27;projects&#x27;</span>], <span class="attr">queryFn</span>: fetchProjects &#125;);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 React 的 suspense 模式下使用 React Query 时，这种并行模式不起作用。 因为第一个查询将在内部抛出 Promise，并且将在其他查询运行之前挂起组件。 此时建议使用 <code>useQueries</code> hook</p>
</blockquote>
<ol start="2">
<li>使用<code>useQueries</code>进行动态并行查询</li>
</ol>
<p>如果需要执行的查询数量不固定，即在每次渲染之间都会变化，那就不能进行手动查询了</p>
<p><code>useQueries</code>接受一组作为查询配置的对象，并以数组形式返回查询的结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params">&#123; users &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> userQueries = <span class="title function_">useQueries</span>(&#123;</span><br><span class="line">    <span class="attr">queries</span>: users.<span class="title function_">map</span>(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">queryKey</span>: [<span class="string">&quot;user&quot;</span>, user.<span class="property">id</span>],</span><br><span class="line">        <span class="attr">queryFn</span>: <span class="function">() =&gt;</span> <span class="title function_">fetchUserById</span>(user.<span class="property">id</span>),</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="有依赖的查询"><a href="#有依赖的查询" class="headerlink" title="有依赖的查询"></a><a id="enabled"></a>有依赖的查询</h2><p>有依赖的查询 或者说 按顺序排列的查询，即当前查询是否执行（或何时执行）依赖于前一个查询的结果</p>
<p>可以使用<code>enable</code>配置项来告诉query何时可以运行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先执行这个query来拿到user的数据</span></span><br><span class="line"><span class="keyword">const</span> &#123; data &#125; = <span class="title function_">useQuery</span>(&#123;</span><br><span class="line">  <span class="attr">queryKey</span>: [<span class="string">&quot;user&quot;</span>, email],</span><br><span class="line">  <span class="attr">queryFn</span>: getUserByEmail,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userId = data?.<span class="property">id</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此query依赖于 user query 的结果</span></span><br><span class="line"><span class="keyword">const</span> &#123; data &#125; = <span class="title function_">useQuery</span>(&#123;</span><br><span class="line">  <span class="attr">queryKey</span>: [<span class="string">&quot;projects&quot;</span>, userId],</span><br><span class="line">  <span class="attr">queryFn</span>: getProjectsByUser,</span><br><span class="line">  <span class="comment">// 直到 userId 存在，查询才会被执行</span></span><br><span class="line">  <span class="attr">enabled</span>: !!userId,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="QueryClient"><a href="#QueryClient" class="headerlink" title="QueryClient"></a>QueryClient</h2><p>使用<code>QueryClient</code>可以创建一个query客户端，来与query缓存联系起来</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">QueryClient</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@tanstack/react-query&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queryClient = <span class="keyword">new</span> <span class="title class_">QueryClient</span>(&#123;</span><br><span class="line">  <span class="comment">// 全局设置query的一些配置</span></span><br><span class="line">  <span class="attr">defaultOptions</span>: &#123;</span><br><span class="line">    <span class="attr">queries</span>: &#123;</span><br><span class="line">      <span class="attr">staleTime</span>: <span class="title class_">Infinity</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>QueryClient</code>可传入一个对象，其中包含三个参数（三个参数都是可选的）：</p>
<ul>
<li><code>defaultOptions</code>：为使用该client的所有查询（query）和修改（mutation）设置默认的配置项</li>
<li><code>queryCache</code>：该client所连接的query缓存</li>
<li><code>mutationCache</code>：该client所连接的mutation缓存</li>
</ul>
<h3 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h3><ol>
<li><code>refetchOnWindowFocus</code></li>
</ol>
<p>如果用户在短暂离开窗口后回来时，数据被标记为过时的，react-query会在后台自动请求新的数据</p>
<p>可以使用该配置项在全局或者单个查询中禁用该功能</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局</span></span><br><span class="line"><span class="keyword">const</span> queryClient = <span class="keyword">new</span> <span class="title class_">QueryClient</span>(&#123;</span><br><span class="line">  <span class="attr">defaultOptions</span>: &#123;</span><br><span class="line">    <span class="attr">queries</span>: &#123;</span><br><span class="line">      <span class="attr">refetchOnWindowFocus</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个查询</span></span><br><span class="line"><span class="title function_">useQuery</span>(&#123;</span><br><span class="line">  <span class="attr">queryKey</span>: [<span class="string">&quot;useData&quot;</span>],</span><br><span class="line">  <span class="attr">queryFn</span>: getUserData,</span><br><span class="line">  <span class="attr">refetchOnWindowFocus</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>enabled</code></li>
</ol>
<p>可以为单个查询配置<code>enabled = false</code>来禁用自动查询</p>
<p>当<code>enabled = false</code>时：</p>
<ul>
<li>如果查询已经缓存了数据，将以<code>status === &#39;success&#39;</code>进行初始化</li>
<li>如果查询没有缓存数据，将以<code>status === &#39;loading&#39;</code>进行初始化</li>
<li>该查询不会在挂载时自动获取数据、不会在后台重新获取数据</li>
<li>将忽略客户端的<code>invalidateQueries</code>和<code>refetchQueries</code>调用</li>
<li>从<code>useQuery</code>返回的 <strong><code>refetch</code></strong> 可用于手动触发查询以进行数据获取</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动触发查询</span></span><br><span class="line"><span class="keyword">const</span> &#123; isError, data, error, refetch &#125; = <span class="title function_">useQuery</span>(&#123;</span><br><span class="line">  <span class="attr">queryKey</span>: [<span class="string">&quot;useData&quot;</span>],</span><br><span class="line">  <span class="attr">queryFn</span>: getUserData,</span><br><span class="line">  <span class="attr">enabled</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="title function_">refetch</span>()&#125; &gt;手动触发查询&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>永久性的禁用查询并不是你使用react-query的理由，你可能更多的需要进行<a href="#enabled">惰性查询</a></p>
<ol start="3">
<li><code>retry</code></li>
</ol>
<p>当<code>useQuery</code>查询失败时，如果该查询的请求未达到最大连续重试次数（默认 3 次），那么react-query将自动重试该查询。</p>
<p>可以在全局或者单个查询上配置重试逻辑</p>
<ul>
<li><code>retry = false</code> 将禁用重试  &amp;&amp;  <code>retry = true</code> 将无限次重试</li>
<li><code>retry = 5</code> 设置为一个数字，表示最大重试次数</li>
<li><code>retry =（failureCount，error）=&gt; ...</code> 允许基于请求失败的原因进行自定义逻辑</li>
</ul>
<h3 id="QueryClient的一些api"><a href="#QueryClient的一些api" class="headerlink" title="QueryClient的一些api"></a>QueryClient的一些api</h3><ol>
<li><code>queryClient.fetchQuery</code></li>
</ol>
<p>该方法是一个<strong>异步</strong>的方法，用于触发查询并将结果缓存，通常用于预加载数据。</p>
<p><strong>参数</strong></p>
<p><code>fetchQuery</code>接受的参数和<code>useQuery</code>相同，即 queryKey、queryFn、option（可选）</p>
<p><strong>返回值</strong></p>
<p>调用<code>fetchQuery</code>将返回一个promise对象，包含了请求错误的信息 或者 成功时的数据</p>
<p>当调用<code>fetchQuery</code>时会执行如下步骤：</p>
<ul>
<li>检查缓存中是否已有与提供的 queryKey 对应的缓存数据</li>
<li>如果缓存中有数据，并且数据是新鲜的，那么<code>fetchQuery</code>将返回这些数据。</li>
<li>如果缓存中没有数据，或者数据已过时，那么将执行 queryFn，并将结果数据放入缓存中。</li>
</ul>
<p><strong>使用示例</strong></p>
<p>演示用户在导航到用户详情页时，使用<code>fetchQuery</code>预加载用户数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">QueryClient</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-query&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 QueryClient 实例</span></span><br><span class="line"><span class="keyword">const</span> queryClient = <span class="keyword">new</span> <span class="title class_">QueryClient</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个函数，用于获取用户数据</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fetchUserById</span> = <span class="keyword">async</span> (<span class="params">userId</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`api/users/<span class="subst">$&#123;userId&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Network response was not ok&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这是一个事件处理函数，当用户点击时触发</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleUserLinkClick</span> = (<span class="params">userId</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 使用 fetchQuery 预加载用户数据</span></span><br><span class="line">  queryClient.<span class="title function_">fetchQuery</span>([<span class="string">&#x27;user&#x27;</span>, userId], <span class="function">() =&gt;</span> <span class="title function_">fetchUserById</span>(userId));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里，我们可能会进行路由导航操作</span></span><br><span class="line">  <span class="title function_">navigate</span>(<span class="string">`/users/<span class="subst">$&#123;userId&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户详情组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">UserDetails</span> = (<span class="params">&#123; userId &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 使用 useQuery 钩子查询用户数据</span></span><br><span class="line">  <span class="keyword">const</span> &#123; data, isLoading, error &#125; = <span class="title function_">useQuery</span>(</span><br><span class="line">    [<span class="string">&#x27;user&#x27;</span>, userId],</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="title function_">fetchUserById</span>(userId),</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 如果数据已经在 fetchQuery 中预加载，这里会立刻拿到缓存数据</span></span><br><span class="line">      <span class="attr">staleTime</span>: <span class="title class_">Infinity</span>, <span class="comment">// 你可以根据需要设置合适的新鲜度</span></span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isLoading) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Error: &#123;error.message&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;data.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* ... 其他用户信息 */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>queryClient.prefetchQuery</code></li>
</ol>
<p>该方法是一个<strong>异步</strong>的方法，用于在后台提前获取数据并将其存储在缓存中，以便在未来某个时刻需要时能够立即使用</p>
<p><code>prefetchQuery</code>的工作方式与<code>fetchQuery</code>大致相同，但<code>prefetchQuery</code>更关注于数据的预加载，它通常<strong>不返回数据</strong>，只是单纯地将数据预加载到缓存中。同时，<code>prefetchQuery</code>通常在数据需要之前调用，而不是在渲染组件时调用</p>
<ol start="3">
<li><code>queryClient.getQueryData</code></li>
</ol>
<p>该方法是一个<strong>同步</strong>方法，用于返回已存在的查询的缓存数据，如果没有缓存数据则返回<code>undefined</code></p>
<p><strong>参数</strong></p>
<p>只需要传入 queryKey 即可</p>
<p><strong>返回值</strong></p>
<p>如果缓存存在则返回数据，否则返回<code>undefined</code></p>
<p><strong>使用示例</strong></p>
<p><code>const data = queryClient.getQueryData(queryKey)</code></p>
<p><strong>更多</strong></p>
<p>其他更多的<code>queryClient</code> api 可以前往<a target="_blank" rel="noopener" href="https://tanstack.com/query/latest/docs/reference/QueryClient">官网</a>查看</p>
<h2 id="主动查询失败-Query-Invalidation"><a href="#主动查询失败-Query-Invalidation" class="headerlink" title="主动查询失败 Query Invalidation"></a>主动查询失败 Query Invalidation</h2><p>查询会在过时之后自动重新查询，但是在很多时候，由于修改了某些数据，你能明确的知道数据已经是过时的了（即使它还没有到默认的过时时间）。</p>
<p>这个时候可以调用<code>QueryClient</code>的<code>invalidateQueries</code>方法来明确的告诉react-query数据已经过时了，并重新查询新的数据</p>
<p>简单的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useQuery, useQueryClient &#125; <span class="keyword">from</span> <span class="string">&quot;@tanstack/react-query&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 queryClient</span></span><br><span class="line"><span class="keyword">const</span> queryClient = <span class="title function_">useQueryClient</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使缓存中的每个查询都无效</span></span><br><span class="line">queryClient.<span class="title function_">invalidateQueries</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无效以 userData 开头的键值的查询</span></span><br><span class="line">queryClient.<span class="title function_">invalidateQueries</span>(&#123; <span class="attr">queryKey</span>: [<span class="string">&quot;userData&quot;</span>] &#125;)</span><br></pre></td></tr></table></figure>

<p>对于传入queryKey使查询失效的精确度，也有多种方式进行控制</p>
<ol>
<li>传入特定的（或者完整）的queryKey</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">queryClient.<span class="title function_">invalidateQueries</span>(&#123;</span><br><span class="line">  <span class="attr">queryKey</span>: [<span class="string">&quot;userData&quot;</span>, &#123; <span class="attr">userName</span>: <span class="string">&quot;easy code sniper&quot;</span> &#125;],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该查询会被无效</span></span><br><span class="line"><span class="keyword">const</span> userQuery = <span class="title function_">useQuery</span>(&#123;</span><br><span class="line">  <span class="attr">queryKey</span>: [<span class="string">&quot;userData&quot;</span>, &#123; <span class="attr">userName</span>: <span class="string">&quot;easy code sniper&quot;</span> &#125;],</span><br><span class="line">  <span class="attr">queryFn</span>: getUserData,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该查询不会被无效</span></span><br><span class="line"><span class="keyword">const</span> userQuery = <span class="title function_">useQuery</span>(&#123;</span><br><span class="line">  <span class="attr">queryKey</span>: [<span class="string">&quot;userData&quot;</span>],</span><br><span class="line">  <span class="attr">queryFn</span>: getUserData,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用<code>exact</code>配置，表示只想使指定的queryKey对应的查询失效</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">queryClient.<span class="title function_">invalidateQueries</span>(&#123;</span><br><span class="line">  <span class="attr">queryKey</span>: [<span class="string">&quot;userData&quot;</span>],</span><br><span class="line">  <span class="attr">exact</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该查询会被无效</span></span><br><span class="line"><span class="keyword">const</span> userQuery = <span class="title function_">useQuery</span>(&#123;</span><br><span class="line">  <span class="attr">queryKey</span>: [<span class="string">&quot;userData&quot;</span>],</span><br><span class="line">  <span class="attr">queryFn</span>: getUserData,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该查询不会被无效</span></span><br><span class="line"><span class="keyword">const</span> userQuery = <span class="title function_">useQuery</span>(&#123;</span><br><span class="line">  <span class="attr">queryKey</span>: [<span class="string">&quot;userData&quot;</span>, &#123; <span class="attr">userName</span>: <span class="string">&quot;easy code sniper&quot;</span> &#125;],</span><br><span class="line">  <span class="attr">queryFn</span>: getUserData,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>自定义更精细化的查询失效</li>
</ol>
<p>可以将 <strong><code>predicate</code></strong> 函数传递给<code>invalidateQueries</code>方法。 此函数将从查询缓存中接收每个Query实例，并允许你返回 true 或 false 来确定是否使该查询无效</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">queryClient.<span class="title function_">invalidateQueries</span>(&#123;</span><br><span class="line">  <span class="attr">predicate</span>: <span class="function">(<span class="params">query</span>) =&gt;</span></span><br><span class="line">    query.<span class="property">queryKey</span>[<span class="number">0</span>] === <span class="string">&quot;userData&quot;</span> &amp;&amp; query.<span class="property">queryKey</span>[<span class="number">1</span>]?.<span class="property">age</span> &gt;= <span class="number">18</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该查询会被无效</span></span><br><span class="line"><span class="keyword">const</span> userQuery = <span class="title function_">useQuery</span>(&#123;</span><br><span class="line">  <span class="attr">queryKey</span>: [<span class="string">&quot;userData&quot;</span>, &#123; <span class="attr">age</span>: <span class="number">20</span> &#125;],</span><br><span class="line">  <span class="attr">queryFn</span>: getUserData,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该查询会被无效</span></span><br><span class="line"><span class="keyword">const</span> userQuery = <span class="title function_">useQuery</span>(&#123;</span><br><span class="line">  <span class="attr">queryKey</span>: [<span class="string">&quot;userData&quot;</span>, &#123; <span class="attr">age</span>: <span class="number">10</span> &#125;],</span><br><span class="line">  <span class="attr">queryFn</span>: getUserData,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h2 id="修改-Mutations"><a href="#修改-Mutations" class="headerlink" title="修改 Mutations"></a>修改 Mutations</h2><blockquote>
<p>对于mutations的定义，在官方文档中是这么说的：<br>“mutations are typically used to create&#x2F;update&#x2F;delete data or perform server side-effects.”</p>
</blockquote>
<p>即：<strong>用于创建、删除、更新数据或者执行服务器命令等操作</strong></p>
<p>你可以在组件或者自定义hook中使用 <strong><code>useMutation</code></strong> 来修改数据</p>
<p>简单示例：修改用户的信息</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> mutation = <span class="title function_">useMutation</span>(&#123;</span><br><span class="line">    <span class="attr">mutationFn</span>: <span class="function">(<span class="params">userInfo</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> axios.<span class="title function_">post</span>(<span class="string">&quot;/updateUserInfo&quot;</span>, userInfo);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;mutation.isLoading ? (</span></span><br><span class="line"><span class="language-xml">        &quot;updating ...&quot;</span></span><br><span class="line"><span class="language-xml">      ) : (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;mutation.isError ? (</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>An error occurred: &#123;mutation.error.message&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          ) : null&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">          &#123;mutation.isSuccess ? <span class="tag">&lt;<span class="name">div</span>&gt;</span>updated!<span class="tag">&lt;/<span class="name">div</span>&gt;</span> : null&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">              mutation.mutate(&#123; userName: &#x27;easy code sniper&#x27; &#125;);</span></span><br><span class="line"><span class="language-xml">            &#125;&#125;</span></span><br><span class="line"><span class="language-xml">          &gt;</span></span><br><span class="line"><span class="language-xml">            修改用户信息</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面的例子可以看出，你可以通过调用<code>mutation</code>方法来给mutationFn传入参数</p>
<p><code>useMutation</code>和查询一样也会返回一些状态和信息：</p>
<p>状态：</p>
<ul>
<li>布尔值<code>isLoading</code> 或者 <code>status === &#39;loading&#39;</code> 表示修改正在进行</li>
<li>布尔值<code>isError</code> 或者 <code>status === &#39;error&#39;</code> 表示修改遇到了错误</li>
<li>布尔值<code>isSuccess</code> 或者 <code>status === &#39;success&#39;</code> 表示修改成功，数据可用</li>
</ul>
<p>信息：</p>
<ul>
<li><code>error</code> 如果修改处于<code>isError</code>状态,可以获取到错误的具体信息</li>
<li><code>data</code> 如果修改处于<code>isSuccess</code>状态，可以获取到数据</li>
</ul>
<blockquote>
<p><strong>注意：</strong> <code>mutate</code>函数是一个异步函数，在React16及以前版本，你不能在事件回调中直接使用它。你需要将mutate包装在另一个函数中</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在React16及之前的版本，这将无法正常工作</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">CreateTodo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mutation = <span class="title function_">useMutation</span>(&#123;</span><br><span class="line">    <span class="attr">mutationFn</span>: <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      event.<span class="title function_">preventDefault</span>()</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fetch</span>(<span class="string">&quot;/api&quot;</span>, <span class="keyword">new</span> <span class="title class_">FormData</span>(event.<span class="property">target</span>))</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;mutation.mutate&#125;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这将正常工作</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">CreateTodo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mutation = <span class="title function_">useMutation</span>(&#123;</span><br><span class="line">    <span class="attr">mutationFn</span>: <span class="function">(<span class="params">formData</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fetch</span>(<span class="string">&quot;/api&quot;</span>, formData)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onSubmit</span> = (<span class="params">event</span>) =&gt; &#123;</span><br><span class="line">    event.<span class="title function_">preventDefault</span>()</span><br><span class="line">    mutation.<span class="title function_">mutate</span>(<span class="keyword">new</span> <span class="title class_">FormData</span>(event.<span class="property">target</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;onSubmit&#125;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h3><p><code>useMutation</code>最便利，也是最有用的功能可能就在于它能定义一些副作用配置，这些配置允许在其生命周期的任何阶段快速而简单地产生副作用。</p>
<p>一个最常见的例子就是，在修改数据之后能自动的重新获取最新的数据（如果你经历过一些开发，那你一定会对这个功能感到兴奋🚀～～）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useMutation</span>(&#123;</span><br><span class="line">  <span class="attr">mutationFn</span>: updateUserInfo,</span><br><span class="line">  <span class="attr">onMutate</span>: <span class="function">(<span class="params">variables</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 修改即将发生！</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">onError</span>: <span class="function">(<span class="params">error, variables, context</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 错误触发！</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">onSuccess</span>: <span class="function">(<span class="params">data, variables, context</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 成功时触发</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">onSettled</span>: <span class="function">(<span class="params">data, error, variables, context</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 错误或成功……这并不重要</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>除了在<code>useMutation</code>中可以配置这些副作用项外，还可以在调用<code>mutate</code>函数时配置组件特定的副作用，支持的配置项包括：<code>onSuccess</code>、<code>onError</code> 和  <code>onSettled</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">mutate</span>(userInfo, &#123;</span><br><span class="line">  <span class="attr">onSuccess</span>: <span class="function">(<span class="params">data, variables, context</span>) =&gt;</span> &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">onError</span>: <span class="function">(<span class="params">error, variables, context</span>) =&gt;</span> &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">onSettled</span>: <span class="function">(<span class="params">data, error, variables, context</span>) =&gt;</span> &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 如果组件在修改完成之前就被卸载了，那使用mutate配置的组件特定的副作用将不被运行</p>
<h3 id="修改导致的查询失败"><a href="#修改导致的查询失败" class="headerlink" title="修改导致的查询失败"></a>修改导致的查询失败</h3><p>在开发中非常常见的是，当应用中的一个对数据的修改成功时，很有可能在你的应用中有相关的查询需要作废，并需要重新获取数据来解释修改所产生的新变化</p>
<p>假设我们调用<code>const mutation = useMutation(&#123; mutationFn: updateUserInfo &#125;)</code>对用户信息进行了修改，那么势必导致现在渲染的数据是过时的。我们希望所有对userInfo的查询都失效，并重新获取最新的数据</p>
<p>我们可以使用<code>useMutation</code>的副作用<code>onSuccess</code>配置 和QueryClient的<code>invalidateQueries</code>函数来实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useMutation, useQueryClient &#125; <span class="keyword">from</span> <span class="string">&quot;@tanstack/react-query&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queryClient = <span class="title function_">useQueryClient</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当此修改成功时，将所有带有useData查询键值的查询都无效</span></span><br><span class="line"><span class="keyword">const</span> mutation = <span class="title function_">useMutation</span>(&#123;</span><br><span class="line">  <span class="attr">mutationFn</span>: updateUserInfo,</span><br><span class="line">  <span class="attr">onSuccess</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    queryClient.<span class="title function_">invalidateQueries</span>(&#123; <span class="attr">queryKey</span>: [<span class="string">&quot;userData&quot;</span>] &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="通过修改的数据更新查询内容"><a href="#通过修改的数据更新查询内容" class="headerlink" title="通过修改的数据更新查询内容"></a>通过修改的数据更新查询内容</h3><p>当在处理更新某些数据时，新的数据往往会在更新的响应中自动返回，我们可以利用修改函数返回的对象，并使用 Query Client 的 <strong><code>setQueryData</code></strong> 方法立即用新数据更新现有的查询，而不是去触发新的数据获取，浪费对已有数据的网络调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queryClient = <span class="title function_">useQueryClient</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutation = <span class="title function_">useMutation</span>(&#123;</span><br><span class="line">  <span class="attr">mutationFn</span>: updateUserInfo,</span><br><span class="line">  <span class="attr">onSuccess</span>: <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    queryClient.<span class="title function_">setQueryData</span>([<span class="string">&quot;userData&quot;</span>, &#123; <span class="attr">userName</span>: <span class="string">&#x27;cqy&#x27;</span> &#125;], data);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mutation.<span class="title function_">mutate</span>(&#123;</span><br><span class="line">  <span class="attr">userName</span>: <span class="string">&#x27;cqy&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">22</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的查询将被更新为成功的修改响应</span></span><br><span class="line"><span class="keyword">const</span> &#123; status, data, error &#125; = <span class="title function_">useQuery</span>(&#123;</span><br><span class="line">  <span class="attr">queryKey</span>: [<span class="string">&quot;useData&quot;</span>, &#123; <span class="attr">userName</span>: <span class="string">&#x27;cqy&#x27;</span> &#125;],</span><br><span class="line">  <span class="attr">queryFn</span>: fetchTodoById,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="useInfiniteQuery"><a href="#useInfiniteQuery" class="headerlink" title="useInfiniteQuery"></a>useInfiniteQuery</h2><p><code>useInfiniteQuery</code>钩子用于处理无限滚动或分页场景，它可以用来逐页加载数据，并且可以无缝地集成更多数据加载到现有数据集中。</p>
<p><strong>参数</strong></p>
<p><code>useInfiniteQuery</code>接受以下参数：</p>
<ul>
<li>queryKey</li>
<li>queryFn</li>
<li>options (可选): 一个配置对象，包含以下属性：<ul>
<li><code>getNextPageParam</code>: 一个函数，用于从最后一页的数据中获取下一页的 pageParam</li>
<li><code>getPreviousPageParam</code>: 一个函数，用于从第一页的数据中获取上一页的 pageParam</li>
<li>其他 React Query 提供的所有配置选项，如 staleTime, cacheTime, onSuccess, onError 等</li>
</ul>
</li>
</ul>
<p><strong>getNextPageParam</strong></p>
<p><code>getNextPageParam</code>用于定义如何从获取到的数据中提取分页参数，以便加载下一页的数据。</p>
<p><code>getNextPageParam</code>函数接收两个参数：</p>
<ul>
<li><code>lastPage</code>: 当前查询返回的最后一页数据。</li>
<li><code>allPages</code>: 当前已经加载的所有页面组成的数组。</li>
</ul>
<p>函数的返回值应该是一个值，这个值将作为下一个 <code>pageParam</code> 参数传递给 <code>queryFn</code> 函数以获取下一页数据。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getNextPageParam</span> = (<span class="params">lastPage, allPages</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 如果 API 有一个 &#x27;nextPage&#x27; 字段，就返回它来获取下一页</span></span><br><span class="line">  <span class="keyword">return</span> lastPage.<span class="property">nextPage</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getNextPageParam</span> = (<span class="params">lastPage, allPages</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 如果 API 使用游标，并且存在一个 &#x27;nextCursor&#x27; 字段，就返回它</span></span><br><span class="line">  <span class="keyword">return</span> lastPage.<span class="property">nextCursor</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>getPreviousPageParam</strong></p>
<p><code>getPreviousPageParam</code>用于获取前一页数据，在实现双向无限滚动或分页时特别有用。</p>
<p><code>getPreviousPageParam</code>函数接收两个参数：</p>
<ul>
<li><code>firstPage</code>: 当前查询返回的第一页数据。</li>
<li><code>allPages</code>: 目前已经加载的所有页面数据的数组。<br>这个函数的返回值应该是一个标识，表示用于 <code>queryFn</code> 函数获取前一页数据时所需的 <code>pageParam</code></li>
</ul>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getPreviousPageParam</span> = (<span class="params">firstPage, allPages</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 如果 API 有一个 &#x27;prevPage&#x27; 字段，就返回它来获取前一页</span></span><br><span class="line">  <span class="keyword">return</span> firstPage.<span class="property">prevPage</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getPreviousPageParam</span> = (<span class="params">firstPage, allPages</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 如果 API 使用游标，并且存在一个 &#x27;prevCursor&#x27; 字段，就返回它</span></span><br><span class="line">  <span class="keyword">return</span> firstPage.<span class="property">prevCursor</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>返回值</strong></p>
<p><code>useInfiniteQuery</code>返回一个对象，其中包含以下属性：</p>
<ul>
<li><code>status</code>: 查询的状态（’loading’, ‘error’, ‘success’, ‘idle’）。</li>
<li><code>data</code>: 包含每一页数据的数组。</li>
<li><code>error</code>: 查询失败时的错误对象。</li>
<li><code>fetchNextPage</code>: 函数，用于获取下一页数据。</li>
<li><code>fetchPreviousPage</code>: 函数，用于获取上一页数据。</li>
<li><code>hasNextPage</code>: 布尔值，表示是否还有下一页数据。</li>
<li><code>hasPreviousPage</code>: 布尔值，表示是否还有上一页数据。</li>
<li><code>isFetchingNextPage</code>: 布尔值，表示是否正在获取下一页数据。</li>
<li><code>isFetchingPreviousPage</code>: 布尔值，表示是否正在获取上一页数据。</li>
<li><code>isFetching</code>: 布尔值，表示是否正在进行查询（包括初始查询和后续的分页查询）。</li>
<li><code>isLoading</code>: 布尔值，表示是否正在进行初始查询。</li>
<li><code>isRefetching</code>: 布尔值，表示是否正在重新获取数据。</li>
<li>其他 React Query 钩子通常返回的属性，如 refetch, remove 等。</li>
</ul>
<p><strong>data</strong></p>
<p><code>useInfiniteQuery</code>返回的<strong>data</strong>与常规的<code>useQuery</code>不同，因为它需要处理多个“页”的数据，而不是单个数据集。</p>
<p><code>data</code> 是一个对象，它包含以下属性：</p>
<ul>
<li><code>pages</code>: 一个数组，其中的每一个元素代表了每一页加载的数据。这些数据按照加载的顺序排列。例如，<code>data.pages[0]</code> 是第一页的数据，<code>data.pages[1]</code> 是第二页的数据，依此类推。</li>
<li><code>pageParams</code>: 这个数组与 <code>pages</code> 数组有相同的长度，包含了获取每一页数据时 queryFn 函数使用的参数。通常这些参数是由 <code>getNextPageParam</code> 或 <code>getPreviousPageParam</code> 函数提供的。</li>
</ul>
<p><strong>使用示例</strong></p>
<p>下面是一个使用 <code>useInfiniteQuery</code> 来实现无限滚动加载文章列表的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useInfiniteQuery &#125; <span class="keyword">from</span> <span class="string">&#x27;react-query&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分页获取文章的函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fetchArticles</span> = <span class="keyword">async</span> (<span class="params">&#123; pageParam = <span class="number">1</span> &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`/api/articles?page=<span class="subst">$&#123;pageParam&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">json</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件内部</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ArticlesList</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    data,</span><br><span class="line">    error,</span><br><span class="line">    fetchNextPage,</span><br><span class="line">    hasNextPage,</span><br><span class="line">    isFetchingNextPage,</span><br><span class="line">    status,</span><br><span class="line">  &#125; = <span class="title function_">useInfiniteQuery</span>(<span class="string">&#x27;articles&#x27;</span>, fetchArticles, &#123;</span><br><span class="line">    <span class="attr">getNextPageParam</span>: <span class="function">(<span class="params">lastPage, pages</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (lastPage.<span class="property">nextPage</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> lastPage.<span class="property">nextPage</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (status === <span class="string">&#x27;loading&#x27;</span>) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (status === <span class="string">&#x27;error&#x27;</span>) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Error: &#123;error.message&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;data.pages.map((page, i) =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">React.Fragment</span> <span class="attr">key</span>=<span class="string">&#123;i&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;page.articles.map(article =&gt; (</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">key</span>=<span class="string">&#123;article.id&#125;</span>&gt;</span>&#123;article.title&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          ))&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ))&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> fetchNextPage()&#125;</span></span><br><span class="line"><span class="language-xml">          disabled=&#123;!hasNextPage || isFetchingNextPage&#125;</span></span><br><span class="line"><span class="language-xml">        &gt;</span></span><br><span class="line"><span class="language-xml">          &#123;isFetchingNextPage</span></span><br><span class="line"><span class="language-xml">            ? &#x27;Loading more...&#x27;</span></span><br><span class="line"><span class="language-xml">            : hasNextPage</span></span><br><span class="line"><span class="language-xml">            ? &#x27;Load More&#x27;</span></span><br><span class="line"><span class="language-xml">            : &#x27;Nothing more to load&#x27;&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="useMutation"><a href="#useMutation" class="headerlink" title="useMutation"></a>useMutation</h2><p><code>useMutation</code> 钩子是用来处理异步逻辑（如创建、更新或删除数据）的，这些逻辑会引起数据的变化。与<code>useQuery</code>和<code>useInfiniteQuery</code>不同的是，<code>useMutation</code>不是用来获取数据的，而是用来修改数据</p>
<p><strong>参数</strong></p>
<p><code>useMutation</code> 接受以下参数：</p>
<ul>
<li><code>mutationFn</code> (必须): 一个函数，它执行异步逻辑（比如API调用）。这个函数接受你传递给mutate函数的变量。</li>
<li><code>options</code> (可选): 一个配置对象，可以包含如下属性：<ul>
<li><code>onMutate</code>: 在 mutationFn 执行之前调用的函数，用于执行乐观更新或返回回滚函数的数据。</li>
<li><code>onSuccess</code>: 当 mutationFn 成功完成时调用的函数。</li>
<li><code>onError</code>: 当 mutationFn 执行失败时调用的函数。</li>
<li><code>onSettled</code>: 无论 mutationFn 成功还是失败都会调用的函数。</li>
<li>以及其他选项</li>
</ul>
</li>
</ul>
<p><strong>返回值</strong></p>
<p><code>useMutation</code> 返回一个对象，其中包含以下属性和方法:</p>
<ul>
<li><code>mutate</code>: 一个函数，你可以用它来触发异步逻辑（mutationFn）的执行。</li>
<li><code>mutateAsync</code>: 类似于mutate，但是返回一个Promise，可以用于async&#x2F;await。</li>
<li><code>data</code>: mutationFn成功解析的数据。</li>
<li><code>error</code>: 如果mutationFn抛出错误，这里会包含错误对象。</li>
<li><code>isLoading</code>: 如果mutationFn正在执行，这里会是true。</li>
<li><code>isSuccess</code>: 如果mutationFn成功完成，这里会是true。</li>
<li><code>isError</code>: 如果mutationFn执行失败，这里会是true。</li>
<li><code>status</code>: mutation的状态（idle、loading、success、error）。</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/React/">React</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/04/12/读JS红宝书/"><span>读JS红宝书</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/04/12/读JS红宝书/" rel="bookmark">
        <time class="entry-date published" datetime="2024-04-12T12:55:53.000Z">
          2024-04-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="for-in-和-for-of"><a href="#for-in-和-for-of" class="headerlink" title="for-in 和 for-of"></a>for-in 和 for-of</h2><h3 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h3><p>for-in语句用于枚举对象中的非符号键属性，for-in语句<strong>不能保证返回对象属性的顺序</strong></p>
<p><strong>语法：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">const</span> key <span class="keyword">in</span> obj ) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用示例：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;cqy&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">11</span>,</span><br><span class="line">    <span class="attr">hobby</span>: [<span class="string">&#x27;play&#x27;</span>, <span class="string">&#x27;code&#x27;</span>, <span class="string">&#x27;sleep&#x27;</span>],</span><br><span class="line">    <span class="attr">family</span>: &#123;</span><br><span class="line">        <span class="attr">mom</span>: <span class="string">&#x27;mother&#x27;</span>,</span><br><span class="line">        <span class="attr">father</span>: <span class="string">&#x27;father&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">isMale</span>: <span class="literal">true</span>,</span><br><span class="line">    [<span class="title class_">Symbol</span>()]: <span class="string">&#x27;tag&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">const</span> key <span class="keyword">in</span> obj ) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( key );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// name</span></span><br><span class="line"><span class="comment">// age</span></span><br><span class="line"><span class="comment">// hobby</span></span><br><span class="line"><span class="comment">// family</span></span><br><span class="line"><span class="comment">// isMale</span></span><br></pre></td></tr></table></figure>

<h3 id="for-of"><a href="#for-of" class="headerlink" title="for-of"></a>for-of</h3><p>for-of语句用于遍历<strong>可迭代对象</strong>的属性，会按照可迭代对象的<code>next()</code>方法产生值的顺序迭代元素</p>
<p><strong>语法：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">const</span> key <span class="keyword">of</span> iterator ) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用示例：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">const</span> el <span class="keyword">of</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] ) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(el)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="执行上下文与作用域"><a href="#执行上下文与作用域" class="headerlink" title="执行上下文与作用域"></a>执行上下文与作用域</h2><p>变量或函数的上下文决定了它们可以访问哪些数据，每个上下文都有一个关联的<strong>变量对象</strong>，这个上下文中定义的所有变量和函数都存在于这个对象上。</p>
<p>上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数。</p>
<p><strong>上下文栈：</strong><br>每个函数调用都有自己的上下文。当代码执行流进入函数，函数的上下文被推到一个上下文栈上。在函数执行完后，上下文栈会弹出该函数上下文，将控制权还给之前的执行上下文。</p>
<p><strong>作用域链：</strong><br>上下文中的代码在执行时，会创建 变量对象 的一个 作用域链。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。</p>
<p>正在执行的上下文的 变量对象 始终位于作用域链的<strong>最前端（即最先被访问）</strong></p>
<p>代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索从作用域链的最前端开始，逐级往后，直到找到标识符。</p>
<h2 id="原始值包装类型"><a href="#原始值包装类型" class="headerlink" title="原始值包装类型"></a>原始值包装类型</h2><p>为了方便操作原始值，ES提供了3种特殊的引用类型：<code>Boolean</code>、<code>Number</code>、<code>String</code></p>
<p>每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;easy code sniper&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = name.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// [ &#x27;easy&#x27;, &#x27;code&#x27;, &#x27;sniper&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>在这里 name 是一个字符串类型的变量，是一个原始值。但却可以调用<code>split</code>方法。原始值本身不是对象，因此逻辑上不应该有方法。</p>
<p>name原始值能够调用<code>split</code>方法，是后台进行了许多处理。在以读模式（读取变量保存的值）访问字符串值的任何时候：</p>
<ul>
<li>后台会创建一个String类型的实例</li>
<li>调用实例上的特定方法</li>
<li>销毁实例</li>
</ul>
<p>可以将上述3步想象成执行了如下3行代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;easy code sniper&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> arr = name.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">name = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>这种行为可以让我们在原始值上调用对象的方法。对于布尔值和数值，也是执行以上步骤，只不过使用的是<code>Boolean</code>和<code>Number</code>包装类型而已。</p>
<p>这种自动创建的原始值包装对象只存在于访问它的那行代码执行期间，这意味着不能在运行时给原始值添加属性和方法</p>
<h2 id="Array-from-和-Array-of"><a href="#Array-from-和-Array-of" class="headerlink" title="Array.from 和 Array.of"></a>Array.from 和 Array.of</h2><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h3><p><code>Array.from</code>用于将 类数组结构 转换为 数组。第一个参数是一个类数组对象（任何可迭代的结构），或者有一个length属性和可索引元素的结构</p>
<p>使用场景：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符串会被拆分为单字符数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="string">&#x27;cqy&#x27;</span>)); <span class="comment">// [ &#x27;c&#x27;, &#x27;q&#x27;, &#x27;y&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对现有数组进行浅拷贝</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, &#123; <span class="attr">name</span>: <span class="string">&#x27;cqy&#x27;</span> &#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(arr1)</span><br><span class="line"></span><br><span class="line">arr2[<span class="number">2</span>].<span class="property">name</span> = <span class="string">&#x27;easy code sniper&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">// [ 1, 2, &#123; name: &#x27;easy code sniper&#x27; &#125; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将arguments转化为数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment">// [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<p><code>Array.from()</code>还接受 第二个可选的映射函数参数，新数组的每一项都会调用这个映射函数，并将每一项作为参数传入映射函数。<br>还可以接受 第三个可选参数 ，用于指定映射函数中this的值（<strong>箭头函数中不适用</strong>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="title class_">Array</span>.<span class="title function_">from</span>(arr, <span class="keyword">function</span>(<span class="params">x</span>) &#123; <span class="keyword">return</span> x * <span class="variable language_">this</span>.<span class="property">num</span> &#125;, &#123; <span class="attr">num</span>: <span class="number">2</span> &#125;) <span class="comment">// [ 2, 4, 6, 8 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of"></a>Array.of</h3><p><code>Array.of</code>用于将一组参数转换为数组实例</p>
<h2 id="数组迭代方法"><a href="#数组迭代方法" class="headerlink" title="数组迭代方法"></a>数组迭代方法</h2><p>ES为数组定义了5个迭代方法。每个方法接收两个参数：</p>
<ul>
<li>以每一项为参数运行的函数，该函数接收3个参数：数组元素、索引、数组本身</li>
<li>可选的 作为函数运行上下文的作用域对象（影响函数中的this的值）</li>
</ul>
<p>5个迭代方法如下：</p>
<ul>
<li><code>every</code>：对数组的每一项都运行传入的函数，如果每一项函数都返回true，则这个方法返回true</li>
<li><code>filter</code>：对数组每一项都运行传入的函数，函数返回true的项会组成数组之后返回</li>
<li><code>forEach</code>：对数组每一项都运行传入的函数，没有返回值</li>
<li><code>map</code>：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组</li>
<li><code>some</code>：对数组每一项都运行传入的函数，如果有一项函数返回true，则这个方法返回true</li>
</ul>
<h2 id="数组归并方法"><a href="#数组归并方法" class="headerlink" title="数组归并方法"></a>数组归并方法</h2><p>ES为数组定义了2个归并方法：<code>reduce()</code> 和 <code>reduceRight()</code>。这两个方法都会迭代数组的所有项，并在此基础上构建一个最终返回值。</p>
<p><code>reduce()</code>方法从数组第一项开始遍历到最后一项，而<code>reduceRight()</code>从最后一项开始遍历到第一项</p>
<p>这两个方法都接收两个参数：</p>
<ul>
<li>对每一项都会运行的 归并函数<ul>
<li>归并函数接收4个参数：上一个归并值、当前项、当前项索引、数组本身</li>
<li>归并函数的返回值会作为下一次调用本归并函数的第一个参数（如果没有给这两个方法传入可选的第二个参数(作为归并起点值)，则第一次迭代将从数组的第二项开始，因此传给归并函数的 第一个参数是数组的第一项 ，第二个参数是数组的第二项）</li>
</ul>
</li>
<li>可选的 以之为归并起点的初始值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, current, index, array</span>) =&gt;</span> prev + current)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>循环是迭代机制的基础，它可以指定迭代的次数，以及每次迭代要执行什么操作。</p>
<p>但循环又不适用于所有的数据结构。首先数组可以通过<code>[]</code>操作符取得特定索引位置上的项，这并不适用于所有数据结构；其次通过递增索引来访问数据是特定于数组的方式，并不适用于其他具有隐式顺序的数据结构</p>
<p><code>Array.prototype.forEach</code>方法向通用迭代需求迈进了一步，解决了单独记录索引和通过数组对象取得值的问题。但是无法标识迭代何时终止，且回调结构也比较笨拙</p>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p><strong>迭代器模式</strong>把有些结构称为「可迭代对象（iterable）」，因为它们实现了正式的<code>Iterable</code>接口，而且可以通过迭代器<code>Iterator</code>消费</p>
<p><strong>可迭代对象</strong>是抽象的说法，可以将它理解成数组、集合类型的对象 或者 具有类似数组行为的其他数据结构。它们包含的元素都是有限的，而且都具有无歧义的遍历顺序。</p>
<p><strong>迭代器（iterator）</strong>是按需创建的一次性对象，每个迭代器都会关联一个可迭代对象，并且迭代器会暴露用于迭代 可迭代对象 的API。迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值</p>
<p>可迭代对象必须暴露一个属性作为「默认迭代器」，这个属性使用特殊的<code>Symbol.iterator</code>作为键。这个默认迭代器属性引用一个迭代器工厂函数，调用这个工厂函数返回一个新迭代器</p>
<p>很多内置类型都实现了<code>Iterable</code>接口：</p>
<ul>
<li>字符串</li>
<li>数组</li>
<li>映射</li>
<li>集合</li>
<li>arguments对象</li>
<li>NodeList等DOM集合类型</li>
</ul>
<p>检查是否存在默认迭代器属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有实现迭代器工厂函数</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num[<span class="title class_">Symbol</span>.<span class="property">iterable</span>]) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现了迭代器工厂函数</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;cqy&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// [Function: [Symbol.iterator]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用这个工厂函数会生成一个迭代器</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;cqy&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// Object [String Iterator] &#123;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在实际开发中，不需要显式调用这个工厂函数来生成迭代器，一些原生语言结构会在后台调用可迭代对象的工厂函数</p>
<ul>
<li>for-of循环</li>
<li>数组解构</li>
<li>扩展操作符</li>
<li>Array.from()</li>
<li>创建集合、映射</li>
<li><code>Promise.all()</code>和<code>Promise.race()</code></li>
<li>yield*操作符</li>
</ul>
<p>迭代器API使用<code>next()</code>方法在可迭代对象中遍历数据，每次成功调用<code>next()</code>，都会返回一个<code>IteratorResult</code>对象，其中包括：迭代器返回的下一个值<code>value</code> 和 <code>done</code>状态（<code>done</code>为true 表示「耗尽」，即没有下一个值了）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; value: &#x27;aa&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; value: &#x27;bb&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; value: &#x27;cc&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>每个迭代器都表示对可迭代对象的一次性有序遍历。不同迭代器的实例相互之间没有联系，只会单独的遍历可迭代对象</p>
<h3 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h3><p>任何实现Iterator接口的对象都可以作为迭代器使用，下面的例子中的Counter类只能被迭代一定的次数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">limit</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">limit</span> = limit <span class="comment">// 限制迭代的次数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">count</span> &lt;= <span class="variable language_">this</span>.<span class="property">limit</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">count</span>++ &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; <span class="comment">// 返回实例，实例中定义了next方法用于迭代</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当使用for-of循环counter时，后台会去查找counter身上是否有 [Symbol.iterator]() 工厂函数，并调用它， </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 1  2  3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类实现了Iterator接口，但是它的每个实例只能被迭代一次。第二次迭代没有输出的原因是，第一次迭代已经使<code>count === limit</code>，所以第二次迭代不会返回任何内容</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 1  2  3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);  <span class="comment">// 没有输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要实现可以创建多个迭代器，必须美创建一个迭代器就对应一个新计数器。基于此需求，可以把计数器变量放到闭包中，通过闭包返回迭代器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">limit</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">limit</span> = limit</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">let</span> limit = <span class="variable language_">this</span>.<span class="property">limit</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(count &lt;= limit) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 1  2  3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 1  2  3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>提前终止迭代器</strong></p>
<p>提前终止迭代也是一个常见的需求，for-of循环可以通过break、continue、return或者throw提前退出，在退出时会寻找实现Iterator接口的对象上是否有<code>return()</code>方法。如果对象上有这个方法，在退出时就会调用这个方法</p>
<p><code>return()</code>方法必须返回一个有效的<code>IteratorResult</code>对象，可以只简单的返回<code>&#123; done: true &#125;</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">limit</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">limit</span> = limit</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">let</span> limit = <span class="variable language_">this</span>.<span class="property">limit</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(count &lt;= limit) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>() &#123; <span class="comment">// 自定义提前退出迭代方法</span></span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Exiting iter&#x27;</span>);</span><br><span class="line">              <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// Exiting iter</span></span><br></pre></td></tr></table></figure>

<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器是 ES6 新增的结构，可以让函数拥有在函数块内暂停和恢复代码执行的能力</p>
<p>生成器的形式是一个函数，函数名称前面加一个星号（ * ）表示它是一个生成器，标识生成器函数的星号（ * ）不受两侧空格的影响：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> *<span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generatorFn = <span class="keyword">function</span>* () &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorFn); <span class="comment">// [GeneratorFunction: generatorFn]</span></span><br></pre></td></tr></table></figure>

<p>调用生成器函数会产生一个<strong>生成器对象</strong>，生成器对象一开始处于暂停执行的状态。</p>
<p>生成器对象也实现了Iterator接口，因此具有<code>next()</code>方法，调用这个方法会让生成器开始或恢复执行</p>
<p><code>next()</code>方法的返回值类似于迭代器，有一个<code>done</code>属性和一个<code>value</code>属性。函数体为空的生成器函数中间不会停留，调用一次<code>next()</code>就会让生成器到达<code>done: true</code>状态</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generatorFn</span>()); <span class="comment">// Object [Generator] &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generatorFn</span>().<span class="property">next</span>); <span class="comment">// [Function: next]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generatorFn</span>().<span class="title function_">next</span>()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p><code>value</code>属性是生成器函数的返回值，默认是undefined，可以通过生成器函数的返回值来指定</p>
<p>生成器函数只会在初次调用<code>next()</code>方法后开始执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;easy code sniper&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generatorFn</span>()); <span class="comment">// 不会打印 easy code sniper</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generatorFn</span>().<span class="title function_">next</span>()); <span class="comment">// &#123; value: &#x27;easy code sniper&#x27;, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="yield中断执行"><a href="#yield中断执行" class="headerlink" title="yield中断执行"></a>yield中断执行</h3><p>yield关键字可以让生成器停止和开始执行，也是生成器最有用的地方。生成器函数在遇到 yield 关键字之前会正常执行。遇到这个关键字后，执行会停止，函数作用域的状态会被保留。停止执行的生成器函数只能通过在生成器对象上调用<code>next()</code>方法来恢复执行</p>
<p>yield关键字有点像函数的中间返回语句，它生成的值会出现在<code>next()</code>方法返回的对象中</p>
<p><strong>与 return 的区别：</strong>通过yield关键字退出的生成器函数处于<code>done: false</code>状态；通过return关键字退出的生成器函数处于<code>done: true</code>状态</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;cqy&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;kyrie&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;easy code sniper&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generatorObj = <span class="title function_">generatorFn</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObj.<span class="title function_">next</span>()); <span class="comment">// &#123; value: &#x27;cqy&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObj.<span class="title function_">next</span>()); <span class="comment">// &#123; value: &#x27;kyrie&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObj.<span class="title function_">next</span>()); <span class="comment">// &#123; value: &#x27;easy code sniper&#x27;, done: true &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>显式的调用<code>next()</code>方法用处不大，但是可以在需要自定义迭代对象时，把生成器对象当作可迭代对象使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;cqy&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;kyrie&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;easy code sniper&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">of</span> <span class="title function_">generatorFn</span>()) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cqy</span></span><br><span class="line"><span class="comment">// kyrie</span></span><br><span class="line"><span class="comment">// easy code sniper</span></span><br></pre></td></tr></table></figure>

<h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><p>JS使用一些内部特性来描述对象的属性的特征，对象的属性分两种：数据属性 和 访问器属性</p>
<p><strong>数据属性</strong>包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。数据属性有4个特性描述它们的行为：</p>
<ul>
<li><code>[[Configurable]]</code>：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认是 true</li>
<li><code>[[Enumerable]]</code>：表示属性是否可以通过 for-in 循环返回。默认情况下是 true</li>
<li><code>[[Writable]]</code>：表示属性的值是否可以被修改。默认情况下是 true</li>
<li><code>[[Value]]</code>：属性实际的值。默认是 undefined</li>
</ul>
<p>使用<code>Object.defineProperty()</code>方法可以修改属性的默认特性。</p>
<p>该方法接收3个参数；要给其添加属性的对象、属性名称 和 一个描述符对象（描述符对象上的属性可以包含：configurable、enumerable、writable、value）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 obj 创建一个 name 属性，并配置为不可修改</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;easy code sniper&#x27;</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// easy code sniper</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;cqy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// easy code sniper</span></span><br></pre></td></tr></table></figure>

<p><strong>访问器属性</strong>不包含数据值。它包含一个获取函数（getter）和一个设置函数（setter）。在读取访问器属性时，会调用getter，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用setter函数并传入新值，这个函数必须对数据做出修改</p>
<p>访问器属性有4个特性描述它们的行为：</p>
<ul>
<li><code>[[Configurable]]</code>：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认是 true</li>
<li><code>[[Enumerable]]</code>：表示属性是否可以通过 for-in 循环返回。默认情况下是 true</li>
<li><code>[[Get]]</code>：获取函数</li>
<li><code>[[Set]]</code>：设置函数</li>
</ul>
<p>使用<code>Object.defineProperty()</code>方法可以定义访问器属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 _name 为 伪私有变量，通过 name 属性去访问和设置 _name 属性</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">_name</span>: <span class="string">&#x27;easy code sniper&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_name</span> = newValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// easy code sniper</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;cqy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">//cqy</span></span><br></pre></td></tr></table></figure>

<h2 id="理解原型"><a href="#理解原型" class="headerlink" title="理解原型"></a>理解原型</h2><p><strong>构造函数 和 原型对象</strong></p>
<p>只要创建一个函数，就会按照规则为该函数创建一个<code>prototype</code>属性，该属性指向原型对象</p>
<p>所有的原型对象自动获得一个名为<code>constructor</code>属性，指回与之关联的构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     constructor: f Person(),</span></span><br><span class="line"><span class="comment">//     __proto__: Object</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>); <span class="comment">// f Person()</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>实例 和 原型对象</strong></p>
<p>每次调用构造函数创建一个实例，实例内部的<code>[[Prototype]]</code>就会被赋值为 构造函数的原型对象</p>
<p>实例通过<code>__proto__</code>属性可以访问到构造函数的原型</p>
<p><strong>关键在于理解：</strong>实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">__proto__</span>.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>isPrototypeOf()</code>可以确定两个对象之间的关系。本质上，<code>isPrototypeOf()</code>会在传入参数的<code>[[Prototype]]</code>指向调用它的对象时返回 true</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(person)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Object.getPrototypeOf()</code>方法可以返回参数的内部特性<code>[[Prototype]]</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person) == <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Object.setPrototypeOf(obj, prototype)</code>方法可以向实例的私有特性<code>[[Prototype]]</code>写入一个新值，即重写原型</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Pig</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(person, <span class="title class_">Pig</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person)); <span class="comment">// [Function: Pig]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>in 操作符<br>in 操作符会在可以通过对象访问指定属性时返回 true，无论该属性是在实例上还是在原型上</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;cqy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;name&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/JavaScript/">JavaScript</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/04/09/classnames源码阅读/"><span>classnames源码阅读</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/04/09/classnames源码阅读/" rel="bookmark">
        <time class="entry-date published" datetime="2024-04-09T14:27:15.000Z">
          2024-04-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong><code>classnames</code></strong> 是一个JavaScript工具库，用于 有条件地 将不同的class类名组合在一起</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">classNames</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); <span class="comment">// =&gt; &#x27;foo bar&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">classNames</span>(<span class="string">&#x27;foo&#x27;</span>, &#123; <span class="attr">bar</span>: <span class="literal">true</span> &#125;); <span class="comment">// =&gt; &#x27;foo bar&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">classNames</span>(&#123; <span class="string">&#x27;foo-bar&#x27;</span>: <span class="literal">true</span> &#125;); <span class="comment">// =&gt; &#x27;foo-bar&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">classNames</span>(&#123; <span class="string">&#x27;foo-bar&#x27;</span>: <span class="literal">false</span> &#125;); <span class="comment">// =&gt; &#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">classNames</span>(&#123; <span class="attr">foo</span>: <span class="literal">true</span> &#125;, &#123; <span class="attr">bar</span>: <span class="literal">true</span> &#125;); <span class="comment">// =&gt; &#x27;foo bar&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">classNames</span>(&#123; <span class="attr">foo</span>: <span class="literal">true</span>, <span class="attr">bar</span>: <span class="literal">true</span> &#125;); <span class="comment">// =&gt; &#x27;foo bar&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多种不同类型的参数</span></span><br><span class="line"><span class="title function_">classNames</span>(<span class="string">&#x27;foo&#x27;</span>, &#123; <span class="attr">bar</span>: <span class="literal">true</span>, <span class="attr">duck</span>: <span class="literal">false</span> &#125;, <span class="string">&#x27;baz&#x27;</span>, &#123; <span class="attr">quux</span>: <span class="literal">true</span> &#125;); <span class="comment">// =&gt; &#x27;foo bar baz quux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假值对应的类名都会被忽略</span></span><br><span class="line"><span class="title function_">classNames</span>(<span class="literal">null</span>, <span class="literal">false</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="literal">undefined</span>, <span class="number">0</span>, &#123; <span class="attr">baz</span>: <span class="literal">null</span> &#125;, <span class="string">&#x27;&#x27;</span>); <span class="comment">// =&gt; &#x27;bar&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持动态类名</span></span><br><span class="line"><span class="keyword">let</span> buttonType = <span class="string">&#x27;primary&#x27;</span>;</span><br><span class="line"><span class="title function_">classNames</span>(&#123; [<span class="string">`btn-<span class="subst">$&#123;buttonType&#125;</span>`</span>]: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在React中的使用：将classNames赋值给元素的className属性即可</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;classNames(...)&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取对象的hasOwnProperty方法，该方法用于判断某个属性是否是对象本身的，而不是继承自原型链</span></span><br><span class="line"><span class="keyword">const</span> hasOwn = &#123;&#125;.<span class="property">hasOwnProperty</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">classNames</span> () &#123;</span><br><span class="line">	<span class="keyword">let</span> classes = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">const</span> arg = <span class="variable language_">arguments</span>[i];</span><br><span class="line">		<span class="keyword">if</span> (arg) &#123;</span><br><span class="line">			classes = <span class="title function_">appendClass</span>(classes, <span class="title function_">parseValue</span>(arg));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> classes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">parseValue</span> (arg) &#123;</span><br><span class="line">	<span class="comment">// 如果是字符串，直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> arg === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> arg;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果既不是字符串，也不是对象和数组，就返回空字符串</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果是数组，调用classNames来返回一个组合好的结果字符串</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arg)) &#123;</span><br><span class="line">		<span class="keyword">return</span> classNames.<span class="title function_">apply</span>(<span class="literal">null</span>, arg);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// arg.toString !== Object.prototype.toString 表示arg的toString方法不是继承自Object上</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *   !arg.toString.toString().includes(&#x27;[native code]&#x27;)</span></span><br><span class="line"><span class="comment">	 *   如果arg有toString方法，进一步检查这个方法是否是原生的</span></span><br><span class="line"><span class="comment">	 *   方法是将 arg.toString 方法转换成字符串，然后检查它是否包含字符串 &#x27;[native code]&#x27;。如果一个函数的字符串表示中包含 &#x27;[native code]&#x27;，这通常意味着函数是原生提供的，而不是用户定义的。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (arg.<span class="property">toString</span> !== <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> &amp;&amp; !arg.<span class="property">toString</span>.<span class="title function_">toString</span>().<span class="title function_">includes</span>(<span class="string">&#x27;[native code]&#x27;</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> arg.<span class="title function_">toString</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> classes = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果arg是对象</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> arg) &#123;</span><br><span class="line">		<span class="comment">// hasOwn 判断key是否是arg对象本身的属性，而不是继承自原型链的属性</span></span><br><span class="line">		<span class="comment">// arg[key] 判断key对应的值是否存在，且不为false</span></span><br><span class="line">		<span class="keyword">if</span> (hasOwn.<span class="title function_">call</span>(arg, key) &amp;&amp; arg[key]) &#123;</span><br><span class="line">			classes = <span class="title function_">appendClass</span>(classes, key);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> classes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">appendClass</span> (value, newClass) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!newClass) &#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> value ? (value + <span class="string">&#x27; &#x27;</span> + newClass) : newClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/工具库-CSS/">工具库 CSS</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/03/29/react-use源码阅读/"><span>react-use源码阅读</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/03/29/react-use源码阅读/" rel="bookmark">
        <time class="entry-date published" datetime="2024-03-29T13:07:05.000Z">
          2024-03-29
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>React的开发离不开hooks，在社区中也有各种的hooks工具库。本篇阅读的就是<a target="_blank" rel="noopener" href="https://github.com/streamich/react-use">react-use</a>工具库</p>
<p>希望通过阅读源码，加深自己对于React Hook的理解。</p>
<h2 id="useCustomCompareEffect"><a href="#useCustomCompareEffect" class="headerlink" title="useCustomCompareEffect"></a>useCustomCompareEffect</h2><p>React的<code>useEffect</code>比较依赖项的规则是<code>Object.is()</code>，它大部分情况下和<code>===</code>的效果是相同的<br><code>useCustomCompareEffect</code>Hook 用于当依赖项是对象或者数组时自定义依赖项比较方法，定义更加复杂的比较逻辑</p>
<p>使用示例:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> useCustomCompareEffect <span class="keyword">from</span> <span class="string">&quot;./hooks/useCustomCompareEffect&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [obj, setObj] = <span class="title function_">useState</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;kyrie&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">21</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 自定义比较函数，只有当name值发生变化是重新渲染</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">depsEqual</span> = (<span class="params">newDeps, prevDeps</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (prevDeps[<span class="number">0</span>]?.<span class="property">name</span> === newDeps[<span class="number">0</span>]?.<span class="property">name</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useCustomCompareEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;🚀~~ useCustomCompareEffect working !&#x27;</span>);</span><br><span class="line">  &#125;, depsEqual, [obj])</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>name: &#123; obj.name &#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>age: &#123; obj.age &#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setObj(&#123; ...obj, name: &#x27;easy code sniper&#x27; &#125;)&#125;&gt;修改name<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setObj(&#123; ...obj, age: 30 &#125;)&#125;&gt;修改age<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<p>源码及解析如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">DependencyList</span>, <span class="title class_">EffectCallback</span>, useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是基本类型值，是基本类型就返回true</span></span><br><span class="line"><span class="comment">// Object()：给Object()函数传递一个值，如果是对象或者数组，则返回该值的引用；如果是基本类型值，则把该基本类型值包装成为对应的对象类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isPrimitive</span> = (<span class="params">val: any</span>) =&gt; val !== <span class="title class_">Object</span>(val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义比较函数有两个参数：旧的deps 和 新的deps ，该函数需要返回一个bool值来表示依赖是否发生变化</span></span><br><span class="line">type <span class="title class_">DepsEqualFnType</span>&lt;<span class="title class_">TDeps</span> <span class="keyword">extends</span> <span class="title class_">DependencyList</span>&gt; = <span class="function">(<span class="params">prevDeps: TDeps, nextDeps: TDeps</span>) =&gt;</span> boolean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接受三个参数</span></span><br><span class="line"><span class="comment"> * effect：副作用函数</span></span><br><span class="line"><span class="comment"> * deps：依赖项</span></span><br><span class="line"><span class="comment"> * depsEqual：自定义比较函数，该函数有两个参数，前一个依赖项 和 当前依赖项，要求返回一个boolean来表示依赖项是否发生了变化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> useCustomCompareEffect = &lt;<span class="title class_">TDeps</span> <span class="keyword">extends</span> <span class="title class_">DependencyList</span>&gt;<span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  effect: EffectCallback,</span></span></span><br><span class="line"><span class="params"><span class="function">  deps: TDeps,</span></span></span><br><span class="line"><span class="params"><span class="function">  depsEqual: DepsEqualFnType&lt;TDeps&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 生产环境下的一些警告提示，可以忽略</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// deps依赖必须有</span></span><br><span class="line">    <span class="keyword">if</span> (!(deps <span class="keyword">instanceof</span> <span class="title class_">Array</span>) || !deps.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">&#x27;`useCustomCompareEffect` should not be used with no dependencies. Use React.useEffect instead.&#x27;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果每一项依赖都是基本类型，那使用useEffect即可</span></span><br><span class="line">    <span class="keyword">if</span> (deps.<span class="title function_">every</span>(isPrimitive)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">&#x27;`useCustomCompareEffect` should not be used with dependencies that are all primitive values. Use React.useEffect instead.&#x27;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// depsEqual 必须是一个函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> depsEqual !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">&#x27;`useCustomCompareEffect` should be used with depsEqual callback for comparing deps list&#x27;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//定义一个ref来存储依赖项</span></span><br><span class="line">  <span class="keyword">const</span> ref = useRef&lt;<span class="title class_">TDeps</span> | <span class="literal">undefined</span>&gt;(<span class="literal">undefined</span>); </span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  !ref.current 表示初次渲染</span></span><br><span class="line"><span class="comment">  *  !depsEqual(deps, ref.current) 根据自定义的比较函数来判断依赖是否发生变化</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (!ref.<span class="property">current</span> || !<span class="title function_">depsEqual</span>(deps, ref.<span class="property">current</span>)) &#123; </span><br><span class="line">    ref.<span class="property">current</span> = deps; <span class="comment">// 当初次渲染时，或者依赖项发生变化时，ref存储新的依赖</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// useEffect依赖的并不是deps，实际依赖的是ref.current </span></span><br><span class="line">  <span class="comment">// 只有在depsEqual函数判断依赖项发生了变化，并更新ref.current之后，useEffect才会重新执行effect</span></span><br><span class="line">  <span class="title function_">useEffect</span>(effect, ref.<span class="property">current</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useCustomCompareEffect;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="useShallowCompareEffect"><a href="#useShallowCompareEffect" class="headerlink" title="useShallowCompareEffect"></a>useShallowCompareEffect</h2><p>React的<code>useEffect</code>比较依赖项的规则是<code>Object.is()</code>，它大部分情况下和<code>===</code>的效果是相同的<br><code>useShallowCompareEffect</code>Hook 会对每个依赖项进行浅比较，而不是引用相等</p>
<blockquote>
<p>浅比较<br>通常是检查对象的顶层属性是否具有相同的值和相同的引用，对于嵌套对象不进行深入比较</p>
</blockquote>
<p>源码及解析如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">DependencyList</span>, <span class="title class_">EffectCallback</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; equal <span class="keyword">as</span> isShallowEqual &#125; <span class="keyword">from</span> <span class="string">&#x27;fast-shallow-equal&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> useCustomCompareEffect <span class="keyword">from</span> <span class="string">&#x27;./useCustomCompareEffect&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是基本类型值</span></span><br><span class="line"><span class="comment">// 给Object()函数传递一个值，如果是对象或者数组，则返回该值的引用；如果是基本类型值，则把该基本类型值包装成为对应的对象类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isPrimitive</span> = (<span class="params">val: any</span>) =&gt; val !== <span class="title class_">Object</span>(val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用第三方库，实现依赖项的浅比较</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">shallowEqualDepsList</span> = (<span class="params">prevDeps: DependencyList, nextDeps: DependencyList</span>) =&gt;</span><br><span class="line">  prevDeps.<span class="title function_">every</span>(<span class="function">(<span class="params">dep, index</span>) =&gt;</span> <span class="title function_">isShallowEqual</span>(dep, nextDeps[index]));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接受两个参数</span></span><br><span class="line"><span class="comment"> * effect：副作用函数</span></span><br><span class="line"><span class="comment"> * deps：依赖项</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useShallowCompareEffect</span> = (<span class="params">effect: EffectCallback, deps: DependencyList</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 生产环境下的一些警告提示，可以忽略</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(deps <span class="keyword">instanceof</span> <span class="title class_">Array</span>) || !deps.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">&#x27;`useShallowCompareEffect` should not be used with no dependencies. Use React.useEffect instead.&#x27;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (deps.<span class="title function_">every</span>(isPrimitive)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">&#x27;`useShallowCompareEffect` should not be used with dependencies that are all primitive values. Use React.useEffect instead.&#x27;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 调用 useCustomCompareEffect , 将shallowEqualDepsList作为自定义比较方法</span></span><br><span class="line">  <span class="comment">// 实际上就是对 useCustomCompareEffect 的又一层封装</span></span><br><span class="line">  <span class="title function_">useCustomCompareEffect</span>(effect, deps, shallowEqualDepsList);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useShallowCompareEffect;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="useEvent"><a href="#useEvent" class="headerlink" title="useEvent"></a>useEvent</h2><p>用于在特定的事件目标（如 window、document 或任何实现了特定事件监听器接口的对象）上添加和移除事件监听器，它旨在 在不同类型的事件目标上 提供一个统一的 API</p>
<p>源码及解析如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="comment">// isBrower 判断是否是浏览器环境</span></span><br><span class="line"><span class="comment">// on off 是封装好的浏览器事件监听器添加和移除方法</span></span><br><span class="line"><span class="keyword">import</span> &#123; isBrowser, off, on &#125; <span class="keyword">from</span> <span class="string">&#x27;./misc/util&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ListenerType1 和 ListenerType2 接口定义了两种不同的事件监听模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface <span class="title class_">ListenerType1</span> &#123;</span><br><span class="line">  <span class="title function_">addEventListener</span>(<span class="attr">name</span>: string, <span class="attr">handler</span>: <span class="function">(<span class="params">event?: any</span>) =&gt;</span> <span class="keyword">void</span>, ...<span class="attr">args</span>: any[]);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">removeEventListener</span>(<span class="attr">name</span>: string, <span class="attr">handler</span>: <span class="function">(<span class="params">event?: any</span>) =&gt;</span> <span class="keyword">void</span>, ...<span class="attr">args</span>: any[]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface <span class="title class_">ListenerType2</span> &#123;</span><br><span class="line">  <span class="title function_">on</span>(<span class="attr">name</span>: string, <span class="attr">handler</span>: <span class="function">(<span class="params">event?: any</span>) =&gt;</span> <span class="keyword">void</span>, ...<span class="attr">args</span>: any[]);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">off</span>(<span class="attr">name</span>: string, <span class="attr">handler</span>: <span class="function">(<span class="params">event?: any</span>) =&gt;</span> <span class="keyword">void</span>, ...<span class="attr">args</span>: any[]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">UseEventTarget</span> = <span class="title class_">ListenerType1</span> | <span class="title class_">ListenerType2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// isListenerType1 和 isListenerType2 用来判断目标事件对象是否有 addEventListener 或 on 属性来实现的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isListenerType1 = (<span class="attr">target</span>: any): target is <span class="title class_">ListenerType1</span> =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> !!target.<span class="property">addEventListener</span>; <span class="comment">// !! 任何真值都会被转化成true，假值都会被转化成false</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> isListenerType2 = (<span class="attr">target</span>: any): target is <span class="title class_">ListenerType2</span> =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> !!target.<span class="property">on</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultTarget = isBrowser ? <span class="variable language_">window</span> : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接受四个参数；</span></span><br><span class="line"><span class="comment"> * name：事件名称</span></span><br><span class="line"><span class="comment"> * handler：事件处理函数</span></span><br><span class="line"><span class="comment"> * target：事件监听器的目标对象，默认值是 defaultTarget</span></span><br><span class="line"><span class="comment"> * options：可选参数，用于传递给事件监听器的选项</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useEvent</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  name,</span></span><br><span class="line"><span class="params">  handler,</span></span><br><span class="line"><span class="params">  target,</span></span><br><span class="line"><span class="params">  options?</span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!handler || !target) &#123; <span class="comment">// 如果没有传入事件处理函数或者事件对象，不做任何处理直接返回</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isListenerType1</span>(target)) &#123; <span class="comment">//如果目标对象实现的是addEventListener模式，将它手动代理成on模式来添加监听器</span></span><br><span class="line">      <span class="title function_">on</span>(target, name, handler, options);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isListenerType2</span>(target)) &#123; <span class="comment">//如果目标对象实现的是on模式，直接用on模式添加监听器</span></span><br><span class="line">      target.<span class="title function_">on</span>(name, handler, options);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123; <span class="comment">// 在组件销毁时删除事件监听</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isListenerType1</span>(target)) &#123;</span><br><span class="line">        <span class="title function_">off</span>(target, name, handler, options);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isListenerType2</span>(target)) &#123;</span><br><span class="line">        target.<span class="title function_">off</span>(name, handler, options);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [name, handler, target, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(options)]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useEvent;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>on</code> 和 <code>off</code>函数的封装：</p>
<p>on函数接受一个可能为null的对象obj和一个参数列表args。参数列表可以是任何addEventListener方法接受的参数。函数内部会检查obj是否存在并且是否有addEventListener方法。如果条件满足，它会调用obj.addEventListener并传入args参数。<br>这个函数的主要作用是检查对象是否存在并且可以添加事件监听器，然后按照给定的参数调用addEventListener方法。这样做可以避免直接在组件内部调用addEventListener时可能遇到的null或undefined对象错误。</p>
<p>off函数同理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> on&lt;T <span class="keyword">extends</span> <span class="title class_">Window</span> | <span class="title class_">Document</span> | <span class="title class_">HTMLElement</span> | <span class="title class_">EventTarget</span>&gt;(</span><br><span class="line">  <span class="attr">obj</span>: T | <span class="literal">null</span>,</span><br><span class="line">  ...<span class="attr">args</span>: <span class="title class_">Parameters</span>&lt;T[<span class="string">&#x27;addEventListener&#x27;</span>]&gt; | [string, <span class="title class_">Function</span> | <span class="literal">null</span>, ...any]</span><br><span class="line">): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; obj.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">    obj.<span class="title function_">addEventListener</span>(...(args <span class="keyword">as</span> <span class="title class_">Parameters</span>&lt;<span class="title class_">HTMLElement</span>[<span class="string">&#x27;addEventListener&#x27;</span>]&gt;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> off&lt;T <span class="keyword">extends</span> <span class="title class_">Window</span> | <span class="title class_">Document</span> | <span class="title class_">HTMLElement</span> | <span class="title class_">EventTarget</span>&gt;(</span><br><span class="line">  <span class="attr">obj</span>: T | <span class="literal">null</span>,</span><br><span class="line">  ...<span class="attr">args</span>: <span class="title class_">Parameters</span>&lt;T[<span class="string">&#x27;removeEventListener&#x27;</span>]&gt; | [string, <span class="title class_">Function</span> | <span class="literal">null</span>, ...any]</span><br><span class="line">): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; obj.<span class="property">removeEventListener</span>) &#123;</span><br><span class="line">    obj.<span class="title function_">removeEventListener</span>(...(args <span class="keyword">as</span> <span class="title class_">Parameters</span>&lt;<span class="title class_">HTMLElement</span>[<span class="string">&#x27;removeEventListener&#x27;</span>]&gt;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="useGeolocation"><a href="#useGeolocation" class="headerlink" title="useGeolocation"></a>useGeolocation</h2><p>该hook用于获取和追踪用户的地理位置，基于浏览器内置对象<code>navigator</code>实现</p>
<p>使用示例:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> useGeolocation <span class="keyword">from</span> <span class="string">&quot;./hooks/useGeolocation&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> geolocation = <span class="title function_">useGeolocation</span>()</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(geolocation);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<p>源码及解析如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义获取位置错误的接口</span></span><br><span class="line"><span class="keyword">export</span> interface <span class="title class_">IGeolocationPositionError</span> &#123; </span><br><span class="line">  readonly <span class="attr">code</span>: number;</span><br><span class="line">  readonly <span class="attr">message</span>: string;</span><br><span class="line">  readonly <span class="attr">PERMISSION_DENIED</span>: number;</span><br><span class="line">  readonly <span class="attr">POSITION_UNAVAILABLE</span>: number;</span><br><span class="line">  readonly <span class="attr">TIMEOUT</span>: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义当前位置信息的接口</span></span><br><span class="line"><span class="keyword">export</span> interface <span class="title class_">GeoLocationSensorState</span> &#123; </span><br><span class="line">  <span class="attr">loading</span>: boolean; <span class="comment">//位置信息是否正在加载中</span></span><br><span class="line">  <span class="attr">accuracy</span>: number | <span class="literal">null</span>; <span class="comment">//获取的位置的精确度</span></span><br><span class="line">  <span class="attr">altitude</span>: number | <span class="literal">null</span>;  <span class="comment">//相对于海平面的高度</span></span><br><span class="line">  <span class="attr">altitudeAccuracy</span>: number | <span class="literal">null</span>; <span class="comment">//高度的精确度</span></span><br><span class="line">  <span class="attr">heading</span>: number | <span class="literal">null</span>; <span class="comment">//设备移动方向</span></span><br><span class="line">  <span class="attr">latitude</span>: number | <span class="literal">null</span>; <span class="comment">//纬度</span></span><br><span class="line">  <span class="attr">longitude</span>: number | <span class="literal">null</span>; <span class="comment">//经度</span></span><br><span class="line">  <span class="attr">speed</span>: number | <span class="literal">null</span>; <span class="comment">//速度</span></span><br><span class="line">  <span class="attr">timestamp</span>: number | <span class="literal">null</span>; <span class="comment">//这些位置数据的时间戳</span></span><br><span class="line">  error?: <span class="title class_">Error</span> | <span class="title class_">IGeolocationPositionError</span>; <span class="comment">//在获取地理位置信息时发生错误，这里会存储错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface <span class="title class_">PositionOptions</span> &#123;</span><br><span class="line">    enableHighAccuracy?: boolean; <span class="comment">// 是否需要高精度的位置信息</span></span><br><span class="line">    maximumAge?: number; <span class="comment">// 能接受多旧的位置信息</span></span><br><span class="line">    timeout?: number; <span class="comment">//获取位置信息的最长等待时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useGeolocation = (options?: <span class="title class_">PositionOptions</span>): <span class="function"><span class="params">GeoLocationSensorState</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState&lt;<span class="title class_">GeoLocationSensorState</span>&gt;(&#123;</span><br><span class="line">    <span class="attr">loading</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">accuracy</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">altitude</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">altitudeAccuracy</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">heading</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">latitude</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">longitude</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">speed</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">timestamp</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>(),</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">let</span> mounted = <span class="literal">true</span>; <span class="comment">// 表示组件是否挂载</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">watchId</span>: any; <span class="comment">// 调用navigator.geolocation.watchPosition返回的id，用于在组件卸载时清除监听</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 位置信息请求成功的回调函数，navigator.geolocation.getCurrentPosition会在成功时传给该函数一个Positon对象，包含了位置信息</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onEvent</span> = (<span class="params">event: any</span>) =&gt; &#123; </span><br><span class="line">    <span class="keyword">if</span> (mounted) &#123;</span><br><span class="line">      <span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">loading</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">accuracy</span>: event.<span class="property">coords</span>.<span class="property">accuracy</span>,</span><br><span class="line">        <span class="attr">altitude</span>: event.<span class="property">coords</span>.<span class="property">altitude</span>,</span><br><span class="line">        <span class="attr">altitudeAccuracy</span>: event.<span class="property">coords</span>.<span class="property">altitudeAccuracy</span>,</span><br><span class="line">        <span class="attr">heading</span>: event.<span class="property">coords</span>.<span class="property">heading</span>,</span><br><span class="line">        <span class="attr">latitude</span>: event.<span class="property">coords</span>.<span class="property">latitude</span>,</span><br><span class="line">        <span class="attr">longitude</span>: event.<span class="property">coords</span>.<span class="property">longitude</span>,</span><br><span class="line">        <span class="attr">speed</span>: event.<span class="property">coords</span>.<span class="property">speed</span>,</span><br><span class="line">        <span class="attr">timestamp</span>: event.<span class="property">timestamp</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 位置信息请求失败的回调函数，navigator.geolocation.getCurrentPosition会在失败时传给该函数一个error对象，包含了错误信息</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onEventError</span> = (<span class="params">error: IGeolocationPositionError</span>) =&gt;</span><br><span class="line">    mounted &amp;&amp; <span class="title function_">setState</span>(<span class="function">(<span class="params">oldState</span>) =&gt;</span> (&#123; ...oldState, <span class="attr">loading</span>: <span class="literal">false</span>, error &#125;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * navigator.geolocation.getCurrentPosition用于获取当前地理位置信息</span></span><br><span class="line"><span class="comment">   * 接受三个参数：成功的回调、错误时的回调（可选）、选项对象PositionOptions（可选）</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * navigator.geolocation.watchPosition用于注册一个监听器，在用户的设备地理位置发生变化时被调用。该方法返回一个id，用于取消监听</span></span><br><span class="line"><span class="comment">   * 接受三个参数：成功的回调、错误时的回调（可选）、选项对象PositionOptions（可选）</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * navigator.geolocation.clearWatch(watchId)用于取消监听，传入监听器id</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    navigator.<span class="property">geolocation</span>.<span class="title function_">getCurrentPosition</span>(onEvent, onEventError, options);</span><br><span class="line">    watchId = navigator.<span class="property">geolocation</span>.<span class="title function_">watchPosition</span>(onEvent, onEventError, options);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      mounted = <span class="literal">false</span>;</span><br><span class="line">      navigator.<span class="property">geolocation</span>.<span class="title function_">clearWatch</span>(watchId);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useGeolocation;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>navigator对象 是 浏览器内置对象，它提供了关于用户浏览器的信息</p>
</blockquote>
<img src="/2024/03/29/react-use%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/image-1.png" class title="This is an image">

<h2 id="useHover"><a href="#useHover" class="headerlink" title="useHover"></a>useHover</h2><p><code>useHover</code>提供一种简单的方式来跟踪鼠标悬停状态。这个钩子接受一个 React 元素或者一个返回 React 元素的函数，并返回一个数组，包含一个带有悬停事件处理的克隆元素以及一个表示悬停状态（true 或 false）的布尔值。</p>
<p><strong>使用示例：</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> useHover <span class="keyword">from</span> <span class="string">&quot;./hooks/useHover&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [ el, state ] = <span class="title function_">useHover</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">onMouseEnter</span>=<span class="string">&#123;()</span> =&gt;</span> console.log(&#x27;🚀~~ enter&#x27;)&#125;</span></span><br><span class="line"><span class="language-xml">      onMouseLeave=&#123;() =&gt; console.log(&#x27;🚀~~ leave&#x27;)&#125;</span></span><br><span class="line"><span class="language-xml">    &gt;我是一个div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;el&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;state &amp;&amp; <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hovered !<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<p>源码及解析如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// noop 不执行任何操作的空函数 () =&gt; &#123;&#125;</span></span><br><span class="line"><span class="keyword">import</span> &#123; noop &#125; <span class="keyword">from</span> <span class="string">&#x27;./misc/util&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; useState &#125; = <span class="title class_">React</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义Element接口，表示Element类型可以是一个React元素，也可以是一个函数，该函数接受一个boolean类型的参数，并返回React元素</span></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">Element</span> = (<span class="function">(<span class="params">state: boolean</span>) =&gt;</span> <span class="title class_">React</span>.<span class="property">ReactElement</span>&lt;any&gt;) | <span class="title class_">React</span>.<span class="property">ReactElement</span>&lt;any&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// useHover 接受一个Element类型的参数</span></span><br><span class="line"><span class="keyword">const</span> useHover = (<span class="attr">element</span>: <span class="title class_">Element</span>): [<span class="title class_">React</span>.<span class="property">ReactElement</span>&lt;any&gt;, boolean] =&gt; &#123;</span><br><span class="line">  <span class="comment">// state状态用于表示是否处于鼠标悬停状态</span></span><br><span class="line">  <span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接受一个原始事件处理函数，返回一个新的事件处理函数。</span></span><br><span class="line">  <span class="comment">// 新的事件处理函数首先调用传入的原始事件处理函数（如果没有提供，则调用 noop），然后通过 setState 更新悬停状态。</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onMouseEnter</span> = (<span class="params">originalOnMouseEnter?: any</span>) =&gt; <span class="function">(<span class="params">event: any</span>) =&gt;</span> &#123;</span><br><span class="line">    (originalOnMouseEnter || noop)(event);</span><br><span class="line">    <span class="title function_">setState</span>(<span class="literal">true</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onMouseLeave</span> = (<span class="params">originalOnMouseLeave?: any</span>) =&gt; <span class="function">(<span class="params">event: any</span>) =&gt;</span> &#123;</span><br><span class="line">    (originalOnMouseLeave || noop)(event);</span><br><span class="line">    <span class="title function_">setState</span>(<span class="literal">false</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 传入的element是一个函数，则将代表是否hover的状态state传入来返回对应的React元素</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> element === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    element = <span class="title function_">element</span>(state);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// element.props.onMouseEnter 和 element.props.onMouseLeave 是原始元素上可能存在的鼠标悬停和离开函数</span></span><br><span class="line">  <span class="keyword">const</span> el = <span class="title class_">React</span>.<span class="title function_">cloneElement</span>(element, &#123;</span><br><span class="line">    <span class="attr">onMouseEnter</span>: <span class="title function_">onMouseEnter</span>(element.<span class="property">props</span>.<span class="property">onMouseEnter</span>),</span><br><span class="line">    <span class="attr">onMouseLeave</span>: <span class="title function_">onMouseLeave</span>(element.<span class="property">props</span>.<span class="property">onMouseLeave</span>),</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回克隆的React元素 以及 表示悬浮状态的state</span></span><br><span class="line">  <span class="keyword">return</span> [el, state];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useHover;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><code>React.cloneElement()</code></strong></p>
<p>它允许你克隆一个React元素，并且可以选择性的传入props、子元素以及key。它的作用是基于已有的React元素创建一个新的元素，默认保留原有元素的props、内部状态和行为</p>
<blockquote>
<p>默认保留原有元素的props、内部状态和行为<br>因为在默认情况下，React只是浅克隆了原有元素，并传入新的props。在不改变key的情况下，React会视这两个组件为同一个实例，这就意味着，即使属性可能有所改变，但由于组件类型和 key 没有变化，React的重用逻辑会保留组件实例及其内部状态。</p>
</blockquote>
<p>使用<code>React.cloneElement</code>可以很方便地扩展或修改组件的子元素，而不需要创建一个全新的组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">cloneElement</span>(</span><br><span class="line">  element, <span class="comment">// 想要克隆的React对象</span></span><br><span class="line">  props, <span class="comment">// 可选参数。传入一个对象，包含要添加或者覆盖的新属性</span></span><br><span class="line">  [...children] <span class="comment">// 可选参数。可以传入任意数量的子节点来替换被克隆元素的子节点</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>React.cloneElement</code> 使用示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ListItem</span> = (<span class="params">&#123; children, onClick &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">List</span> = (<span class="params">&#123; items &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;items.map((item, index) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">        // 克隆ListItem，并为每个item添加特定的onClick处理器</span></span><br><span class="line"><span class="language-xml">        return React.cloneElement(<span class="tag">&lt;<span class="name">ListItem</span>&gt;</span>&#123;item.text&#125;<span class="tag">&lt;/<span class="name">ListItem</span>&gt;</span>, &#123;</span></span><br><span class="line"><span class="language-xml">          key: index, // 必须提供key，特别是在map循环中</span></span><br><span class="line"><span class="language-xml">          onClick: () =&gt; alert(`Item $&#123;index + 1&#125; clicked!`), // 绑定了一个弹窗事件</span></span><br><span class="line"><span class="language-xml">        &#125;);</span></span><br><span class="line"><span class="language-xml">      &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用List组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> items = [</span><br><span class="line">    &#123; <span class="attr">text</span>: <span class="string">&#x27;Item 1&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">text</span>: <span class="string">&#x27;Item 2&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">text</span>: <span class="string">&#x27;Item 3&#x27;</span> &#125;,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">List</span> <span class="attr">items</span>=<span class="string">&#123;items&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<h2 id="useHoverDirty"><a href="#useHoverDirty" class="headerlink" title="useHoverDirty"></a>useHoverDirty</h2><p><code>useHoverDirty</code>提供一种方式来检测用户是否悬浮在某个元素上</p>
<p><code>useHover</code>接受一个React元素或者一个函数，而<code>useHoverDirty</code>接受<code>React ref</code><br><code>useHover</code>通过设置React元素的<code>onMouseOver</code>和<code>onMouseOut</code>事件，而<code>useHoverDirty</code>通过设置DOM元素的<code>onMouseOver</code>和<code>onMouseOut</code>事件</p>
<p><strong>使用示例：</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> useHoverDirty <span class="keyword">from</span> <span class="string">&#x27;./useHoverDirty&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">HoverComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 创建一个ref来引用我们想要检测悬停的DOM元素</span></span><br><span class="line">  <span class="keyword">const</span> hoverRef = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="comment">// 使用我们的自定义Hook来获取悬停状态</span></span><br><span class="line">  <span class="keyword">const</span> isHovered = <span class="title function_">useHoverDirty</span>(hoverRef);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据悬停状态动态设置样式</span></span><br><span class="line">  <span class="keyword">const</span> style = &#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="string">&#x27;200px&#x27;</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="string">&#x27;200px&#x27;</span>,</span><br><span class="line">    <span class="attr">backgroundColor</span>: isHovered ? <span class="string">&#x27;blue&#x27;</span> : <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    <span class="comment">// 当鼠标悬停时背景色变蓝，否则为红色</span></span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">    <span class="attr">display</span>: <span class="string">&#x27;flex&#x27;</span>,</span><br><span class="line">    <span class="attr">alignItems</span>: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">    <span class="attr">justifyContent</span>: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">    <span class="attr">transition</span>: <span class="string">&#x27;background-color 0.3s&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;hoverRef&#125;</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;isHovered ? &#x27;Hovering&#x27; : &#x27;Not Hovering&#x27;&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">HoverComponent</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>源码及解析如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RefObject</span>, useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; off, on &#125; <span class="keyword">from</span> <span class="string">&#x27;./misc/util&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ref: 这是一个React ref对象，指向要监听悬浮事件的DOM元素。使用ref是因为我们需要直接操作DOM元素来绑定和解绑事件监听器。</span></span><br><span class="line"><span class="comment"> * enabled: 这是一个可选参数，默认为true。它允许使用者启用或禁用悬浮监听功能。这可以用来在某些条件下动态开启或关闭事件监听。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useHoverDirty</span> = (<span class="params">ref: RefObject&lt;Element&gt;, enabled: boolean = <span class="literal">true</span></span>) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开发模式下的警告，可以忽略</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> ref !== <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> ref.<span class="property">current</span> === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;useHoverDirty expects a single ref argument.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否处于悬浮状态的state</span></span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">onMouseOver</span> = (<span class="params"></span>) =&gt; <span class="title function_">setValue</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">onMouseOut</span> = (<span class="params"></span>) =&gt; <span class="title function_">setValue</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enabled &amp;&amp; ref &amp;&amp; ref.<span class="property">current</span>) &#123;</span><br><span class="line">      <span class="title function_">on</span>(ref.<span class="property">current</span>, <span class="string">&#x27;mouseover&#x27;</span>, onMouseOver);</span><br><span class="line">      <span class="title function_">on</span>(ref.<span class="property">current</span>, <span class="string">&#x27;mouseout&#x27;</span>, onMouseOut);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; current &#125; = ref;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (enabled &amp;&amp; current) &#123;</span><br><span class="line">        <span class="title function_">off</span>(current, <span class="string">&#x27;mouseover&#x27;</span>, onMouseOver);</span><br><span class="line">        <span class="title function_">off</span>(current, <span class="string">&#x27;mouseout&#x27;</span>, onMouseOut);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [enabled, ref]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useHoverDirty;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// on函数 和 off函数 的封装</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> on&lt;T <span class="keyword">extends</span> <span class="title class_">Window</span> | <span class="title class_">Document</span> | <span class="title class_">HTMLElement</span> | <span class="title class_">EventTarget</span>&gt;(</span><br><span class="line">  <span class="attr">obj</span>: T | <span class="literal">null</span>,</span><br><span class="line">  ...<span class="attr">args</span>: <span class="title class_">Parameters</span>&lt;T[<span class="string">&#x27;addEventListener&#x27;</span>]&gt; | [string, <span class="title class_">Function</span> | <span class="literal">null</span>, ...any]</span><br><span class="line">): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; obj.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">    obj.<span class="title function_">addEventListener</span>(...(args <span class="keyword">as</span> <span class="title class_">Parameters</span>&lt;<span class="title class_">HTMLElement</span>[<span class="string">&#x27;addEventListener&#x27;</span>]&gt;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> off&lt;T <span class="keyword">extends</span> <span class="title class_">Window</span> | <span class="title class_">Document</span> | <span class="title class_">HTMLElement</span> | <span class="title class_">EventTarget</span>&gt;(</span><br><span class="line">  <span class="attr">obj</span>: T | <span class="literal">null</span>,</span><br><span class="line">  ...<span class="attr">args</span>: <span class="title class_">Parameters</span>&lt;T[<span class="string">&#x27;removeEventListener&#x27;</span>]&gt; | [string, <span class="title class_">Function</span> | <span class="literal">null</span>, ...any]</span><br><span class="line">): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; obj.<span class="property">removeEventListener</span>) &#123;</span><br><span class="line">    obj.<span class="title function_">removeEventListener</span>(...(args <span class="keyword">as</span> <span class="title class_">Parameters</span>&lt;<span class="title class_">HTMLElement</span>[<span class="string">&#x27;removeEventListener&#x27;</span>]&gt;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="useIntersection"><a href="#useIntersection" class="headerlink" title="useIntersection"></a>useIntersection</h2><p><code>useIntersection</code>使用了浏览器的 Intersection Observer API 来异步地检测目标元素与其祖先元素或顶级文档视口的交叉状态的变化。</p>
<blockquote>
<p>Intersection Observer API 是一个浏览器API，它允许你异步观察一个元素与其祖先元素或全局视口的交集变化。能够高效得获取元素是否进入或离开视口的信息。</p>
</blockquote>
<p><strong>相关概念</strong></p>
<ul>
<li><code>root（根）</code>: 想要检查目标元素与之相交的容器元素，如果未指定或为null，默认为浏览器视口</li>
<li><code>rootMargin（根边界）</code>: 类似于CSS的margin属性。它允许你指定一个在根元素的外围形成的边框区域，用于增加或减少用于检查交集的区域大小</li>
<li><code>threshold（阈值）</code>: 一个数字或由多个数字组成的数组，指定了观察者的回调函数被执行的条件。例如，如果阈值是0.5，则目标元素有50%进入根元素时，观察者的回调函数将被执行</li>
</ul>
<p><strong><code>IntersectionObserver()</code>方法</strong>是一个构造函数，用于创建一个新的 IntersectionObserver 对象。<br>这个构造函数接受两个参数：一个回调函数和一个可选的配置对象。</p>
<ul>
<li><p>回调函数：当被观察的元素进入或退出交集区域时，回调函数会被执行。这个函数接受两个参数：</p>
<ul>
<li><code>entries</code>: 一个 IntersectionObserverEntry 对象数组，每个对象都描述了一个被观察元素的交集状态</li>
<li><code>observer</code>: 对应的 IntersectionObserver 实例，允许你访问观察者的属性或调用其方法，如 disconnect 或 unobserve</li>
</ul>
</li>
<li><p>配置对象：包含三个属性</p>
<ul>
<li>root</li>
<li>rootMargin</li>
<li>threshold</li>
</ul>
</li>
</ul>
<p><strong>Intersection Observer</strong></p>
<ul>
<li><code>root</code>: 想要检查目标元素与之相交的容器元素，如果未指定或为null，默认为浏览器视口</li>
<li><code>rootMargin</code>: 类似于CSS的margin属性。它允许你指定一个在根元素的外围形成的边框区域，用于增加或减少用于检查交集的区域大小</li>
<li><code>thresholds</code>: 一个数字或由多个数字组成的数组，指定了观察者的回调函数被执行的条件。例如，如果阈值是0.5，则目标元素有50%进入根元素时，观察者的回调函数将被执行</li>
<li><code>disconnect()</code>: 停止观察所有目标</li>
<li><code>observe(target)</code>: 开始观察一个目标元素</li>
<li><code>takeRecords</code>: 返回所有目标的<code>IntersectionObserverEntry</code>对象数组</li>
<li><code>unobserve(targrt)</code>: 停止观察一个目标元素</li>
</ul>
<p><strong>Intersection Observer Entry</strong></p>
<ul>
<li><code>boundingClientRect</code>: 返回目标元素的矩形信息，用于计算与视口的交集</li>
<li><code>intersectionRatio</code>: 目标元素<strong>可见部分</strong>占总体的比例</li>
<li><code>intersectionRect</code>: 目标元素与视口<strong>交叉部分</strong>的矩形信息</li>
<li><code>isIntersecting</code>: 目标元素是否与根元素相交</li>
<li><code>rootBounds</code>: 根元素的矩形信息</li>
<li><code>target</code>: 目标元素</li>
<li><code>time</code>: 观察到交叉状态变化时的时间戳</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>懒加载：当图片或其他资源进入视口时才加载它们，以此节省带宽和提高页面加载速度</li>
<li>无限滚动: 当用户滚动到页面底部时，自动加载更多内容</li>
</ul>
<p>源码及解析如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RefObject</span>, useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * useIntersection接受两个参数</span></span><br><span class="line"><span class="comment"> * ref： 一个ref引用对象，指向要观察的目标元素</span></span><br><span class="line"><span class="comment"> * options： 配置对象，用于初始化Intersection Observer的选项，比如 root、rootMargin 和 threshold</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> useIntersection = (</span><br><span class="line">  <span class="attr">ref</span>: <span class="title class_">RefObject</span>&lt;<span class="title class_">HTMLElement</span>&gt;,</span><br><span class="line">  <span class="attr">options</span>: <span class="title class_">IntersectionObserverInit</span></span><br><span class="line">): <span class="title class_">IntersectionObserverEntry</span> | <span class="function"><span class="params">null</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 创建 intersectionObserverEntry 状态，用于存储 intersectionObserverEntry 对象信息</span></span><br><span class="line">  <span class="keyword">const</span> [intersectionObserverEntry, setIntersectionObserverEntry] =</span><br><span class="line">    useState&lt;<span class="title class_">IntersectionObserverEntry</span> | <span class="literal">null</span>&gt;(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ref是否存在，浏览器是否支持IntersectionObserver</span></span><br><span class="line">    <span class="keyword">if</span> (ref.<span class="property">current</span> &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">IntersectionObserver</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// handle函数用于更新 intersectionObserverEntry 状态</span></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">handler</span> = (<span class="params">entries: IntersectionObserverEntry[]</span>) =&gt; &#123;</span><br><span class="line">        <span class="title function_">setIntersectionObserverEntry</span>(entries[<span class="number">0</span>]);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建一个监听器对象</span></span><br><span class="line">      <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(handler, options);</span><br><span class="line">      <span class="comment">// 监听目标元素</span></span><br><span class="line">      observer.<span class="title function_">observe</span>(ref.<span class="property">current</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 组件销毁时取消监听，并清空 intersectionObserverEntry 状态</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setIntersectionObserverEntry</span>(<span class="literal">null</span>);</span><br><span class="line">        observer.<span class="title function_">disconnect</span>();</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">  &#125;, [ref.<span class="property">current</span>, options.<span class="property">threshold</span>, options.<span class="property">root</span>, options.<span class="property">rootMargin</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> intersectionObserverEntry;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useIntersection;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>使用示例</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> useIntersection <span class="keyword">from</span> <span class="string">&quot;./hooks/useIntersection&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> intersectionRef = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> intersection = <span class="title function_">useIntersection</span>(intersectionRef, &#123;</span><br><span class="line">    <span class="attr">root</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">rootMargin</span>: <span class="string">&#x27;0px&#x27;</span>,</span><br><span class="line">    <span class="attr">threshold</span>: <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(intersection);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:</span> &#x27;<span class="attr">200px</span>&#x27;, <span class="attr">height:</span> &#x27;<span class="attr">200px</span>&#x27;, <span class="attr">backgroundColor:</span> &#x27;<span class="attr">yellow</span>&#x27;, <span class="attr">overflowY:</span> &#x27;<span class="attr">scroll</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:</span> &#x27;<span class="attr">100</span>%&#x27;, <span class="attr">height:</span> &#x27;<span class="attr">200px</span>&#x27; &#125;&#125; &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:</span> &#x27;<span class="attr">100px</span>&#x27;, <span class="attr">height:</span> &#x27;<span class="attr">50px</span>&#x27;, <span class="attr">backgroundColor:</span> &#x27;<span class="attr">skyblue</span>&#x27; &#125;&#125; <span class="attr">ref</span>=<span class="string">&#123;intersectionRef&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;</span></span><br><span class="line"><span class="language-xml">          intersection &amp;&amp; (intersection.intersectionRatio &lt; 1)</span></span><br><span class="line"><span class="language-xml">          ? &#x27;Obscured&#x27;</span></span><br><span class="line"><span class="language-xml">          : &#x27;Full in view&#x27;</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="useKey"><a href="#useKey" class="headerlink" title="useKey"></a>useKey</h2><p><code>useKey</code>用于设置监听键盘事件</p>
<p>使用示例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useKey&#125; <span class="keyword">from</span> <span class="string">&#x27;react-use&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Demo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, set] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; <span class="title function_">set</span>(<span class="function"><span class="params">count</span> =&gt;</span> ++count);</span><br><span class="line">  <span class="title function_">useKey</span>(<span class="string">&#x27;ArrowUp&#x27;</span>, increment);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      Press arrow up: &#123;count&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>源码及解析如下；</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">DependencyList</span>, useMemo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> useEvent, &#123; <span class="title class_">UseEventOptions</span>, <span class="title class_">UseEventTarget</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./useEvent&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; noop &#125; <span class="keyword">from</span> <span class="string">&#x27;./misc/util&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">KeyPredicate</span> = <span class="function">(<span class="params">event: KeyboardEvent</span>) =&gt;</span> boolean;</span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">KeyFilter</span> = <span class="literal">null</span> | <span class="literal">undefined</span> | string | (<span class="function">(<span class="params">event: KeyboardEvent</span>) =&gt;</span> boolean);</span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">Handler</span> = <span class="function">(<span class="params">event: KeyboardEvent</span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface <span class="title class_">UseKeyOptions</span>&lt;T <span class="keyword">extends</span> <span class="title class_">UseEventTarget</span>&gt; &#123;</span><br><span class="line">  event?: <span class="string">&#x27;keydown&#x27;</span> | <span class="string">&#x27;keypress&#x27;</span> | <span class="string">&#x27;keyup&#x27;</span>;</span><br><span class="line">  target?: T | <span class="literal">null</span>;</span><br><span class="line">  options?: <span class="title class_">UseEventOptions</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// createKeyPredicate接受一个参数keyFilter，该参数可以是一个判断函数（用于判断何时符合条件）、一个字符串（指定的keyboard） 或者 undefined/null</span></span><br><span class="line"><span class="comment">// 然后 createKeyPredicate 根据不同的参数来创建判断函数</span></span><br><span class="line"><span class="comment">// 如果传入的是函数，就返回这个函数</span></span><br><span class="line"><span class="comment">// 如果传入的是字符串（特定的keyboard），则将它包装成一个函数，当event.key === 字符串 时返回true，表示符合条件触发回调函数</span></span><br><span class="line"><span class="comment">// 如果传入的是undefined/null，则包装一个固定返回false的函数，表示不符合条件不触发回调函数</span></span><br><span class="line"><span class="keyword">const</span> createKeyPredicate = (<span class="attr">keyFilter</span>: <span class="title class_">KeyFilter</span>): <span class="function"><span class="params">KeyPredicate</span> =&gt;</span></span><br><span class="line">  <span class="keyword">typeof</span> keyFilter === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">    ? keyFilter</span><br><span class="line">    : <span class="keyword">typeof</span> keyFilter === <span class="string">&#x27;string&#x27;</span></span><br><span class="line">    ? <span class="function">(<span class="params">event: KeyboardEvent</span>) =&gt;</span> event.<span class="property">key</span> === keyFilter</span><br><span class="line">    : keyFilter</span><br><span class="line">    ? <span class="function">() =&gt;</span> <span class="literal">true</span></span><br><span class="line">    : <span class="function">() =&gt;</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定触发回调的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fn 要触发的回调函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> opts 配置选项</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> deps 依赖项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> useKey = &lt;T <span class="keyword">extends</span> <span class="title class_">UseEventTarget</span>&gt;<span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  key: KeyFilter,</span></span></span><br><span class="line"><span class="params"><span class="function">  fn: Handler = noop,</span></span></span><br><span class="line"><span class="params"><span class="function">  opts: UseKeyOptions&lt;T&gt; = &#123;&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">  deps: DependencyList = [key]</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// event 指定是哪种键盘事件（keydown，keyup，keypress）</span></span><br><span class="line">  <span class="comment">// target 绑定事件的目标对象</span></span><br><span class="line">  <span class="comment">// options 传递给useEvent的配置项</span></span><br><span class="line">  <span class="keyword">const</span> &#123; event = <span class="string">&#x27;keydown&#x27;</span>, target, options &#125; = opts;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 包装后的回调函数</span></span><br><span class="line">  <span class="keyword">const</span> useMemoHandler = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 根据传入的key值创建一个判断函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">predicate</span>: <span class="title class_">KeyPredicate</span> = <span class="title function_">createKeyPredicate</span>(key);</span><br><span class="line">    <span class="comment">// handlerEvent 是浏览器事件对象，当向监听器添加事件处理函数时，浏览器会自动传入事件对象作为参数</span></span><br><span class="line">    <span class="comment">// 我们可以通过event参数访问到事件的详细信息，如被按下的键是什么（event.key）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">handler</span>: <span class="title class_">Handler</span> = <span class="function">(<span class="params">handlerEvent</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 判断是否符合触发回调的条件</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">predicate</span>(handlerEvent)) &#123;</span><br><span class="line">        <span class="comment">// 如果符合，就执行用户传入的回调函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fn</span>(handlerEvent);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">  &#125;, deps);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用useEvent来为目标对象绑定事件</span></span><br><span class="line">  <span class="title function_">useEvent</span>(event, useMemoHandler, target, options);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useKey;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="useLongPress"><a href="#useLongPress" class="headerlink" title="useLongPress"></a>useLongPress</h2><p><code>useLongPress</code>用于设置长按之后触发的回调</p>
<p>源码及解析如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useCallback, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; off, on &#125; <span class="keyword">from</span> <span class="string">&#x27;./misc/util&#x27;</span>;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">Options</span> &#123;</span><br><span class="line">  isPreventDefault?: boolean;</span><br><span class="line">  delay?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isTouchEvent = (<span class="attr">ev</span>: <span class="title class_">Event</span>): ev is <span class="title class_">TouchEvent</span> =&gt; &#123;</span><br><span class="line">  <span class="comment">// 检查浏览器传入的事件对象中是否有touches属性，即是否触发了touches事件</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;touches&#x27;</span> <span class="keyword">in</span> ev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">preventDefault</span> = (<span class="params">ev: Event</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isTouchEvent</span>(ev)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当触摸点个数小于2个时，阻止默认事件</span></span><br><span class="line">  <span class="keyword">if</span> (ev.<span class="property">touches</span>.<span class="property">length</span> &lt; <span class="number">2</span> &amp;&amp; ev.<span class="property">preventDefault</span>) &#123;</span><br><span class="line">    ev.<span class="title function_">preventDefault</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callback 长按之后的回调函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> options 配置项对象（可选），其中包括是否阻止默认事件，延迟时间等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useLongPress</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  callback: (e: TouchEvent | MouseEvent) =&gt; <span class="keyword">void</span>,</span></span><br><span class="line"><span class="params">  &#123; isPreventDefault = <span class="literal">true</span>, delay = <span class="number">300</span> &#125;: Options = &#123;&#125;</span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 用于缓存 定时器id 和 目标对象</span></span><br><span class="line">  <span class="keyword">const</span> timeout = useRef&lt;<span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> <span class="built_in">setTimeout</span>&gt;&gt;();</span><br><span class="line">  <span class="keyword">const</span> target = useRef&lt;<span class="title class_">EventTarget</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装监听触摸事件的函数</span></span><br><span class="line">  <span class="keyword">const</span> start = <span class="title function_">useCallback</span>(</span><br><span class="line">    <span class="function">(<span class="params">event: TouchEvent | MouseEvent</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 绑定触摸事件，并缓存目标对象</span></span><br><span class="line">      <span class="keyword">if</span> (isPreventDefault &amp;&amp; event.<span class="property">target</span>) &#123;</span><br><span class="line">        <span class="title function_">on</span>(event.<span class="property">target</span>, <span class="string">&#x27;touchend&#x27;</span>, preventDefault, &#123; <span class="attr">passive</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">        target.<span class="property">current</span> = event.<span class="property">target</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 缓存定时器id</span></span><br><span class="line">      timeout.<span class="property">current</span> = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">callback</span>(event), delay);</span><br><span class="line">    &#125;,</span><br><span class="line">    [callback, delay, isPreventDefault]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装解除监听事件的函数</span></span><br><span class="line">  <span class="keyword">const</span> clear = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    timeout.<span class="property">current</span> &amp;&amp; <span class="built_in">clearTimeout</span>(timeout.<span class="property">current</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isPreventDefault &amp;&amp; target.<span class="property">current</span>) &#123;</span><br><span class="line">      <span class="title function_">off</span>(target.<span class="property">current</span>, <span class="string">&#x27;touchend&#x27;</span>, preventDefault);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [isPreventDefault]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回的对象可以直接解构赋值给目标元素</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">onMouseDown</span>: <span class="function">(<span class="params">e: any</span>) =&gt;</span> <span class="title function_">start</span>(e),</span><br><span class="line">    <span class="attr">onTouchStart</span>: <span class="function">(<span class="params">e: any</span>) =&gt;</span> <span class="title function_">start</span>(e),</span><br><span class="line">    <span class="attr">onMouseUp</span>: clear,</span><br><span class="line">    <span class="attr">onMouseLeave</span>: clear,</span><br><span class="line">    <span class="attr">onTouchEnd</span>: clear,</span><br><span class="line">  &#125; <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useLongPress;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>使用示例</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useLongPress &#125; <span class="keyword">from</span> <span class="string">&#x27;./useLongPress&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Demo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onLongPress</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;calls callback after long pressing 300ms&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> defaultOptions = &#123;</span><br><span class="line">    <span class="attr">isPreventDefault</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">delay</span>: <span class="number">300</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> longPressEvent = <span class="title function_">useLongPress</span>(onLongPress, defaultOptions);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直接解构赋值给元素</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> &#123;<span class="attr">...longPressEvent</span>&#125;&gt;</span>useLongPress<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="useMeasure"><a href="#useMeasure" class="headerlink" title="useMeasure"></a>useMeasure</h2><p><code>useMeasure</code>用于测量一个DOM元素的尺寸和位置，并在尺寸或位置变化时更新这些信息。这个Hook依赖于<code>ResizeObserver API</code>，它允许你监听一个元素的大小变化。</p>
<blockquote>
<p><code>ResizeObserver</code>是一个强大的Web API，允许开发者监听HTML元素的尺寸变化。</p>
</blockquote>
<p><strong>基本用法</strong></p>
<p>使用<code>ResizeObserver</code>创建一个observer实例，并给它提供一个回调函数，该函数会在被观察元素的尺寸位置发生变化时被调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resizeObserver = <span class="keyword">new</span> <span class="title class_">ResizeObserver</span>(<span class="function"><span class="params">entries</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> entries) &#123;</span><br><span class="line">    <span class="comment">// 从 entry.contentRect 中获取元素的尺寸位置信息</span></span><br><span class="line">    <span class="keyword">const</span> &#123; width, height &#125; = entry.<span class="property">contentRect</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Element:&#x27;</span>, entry.<span class="property">target</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Element size: <span class="subst">$&#123;width&#125;</span>px x <span class="subst">$&#123;height&#125;</span>px`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设有一个元素是这样的：&lt;div id=&quot;myElement&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">const</span> myElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myElement&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始观察myElement元素</span></span><br><span class="line">resizeObserver.<span class="title function_">observe</span>(myElement);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止观察某一个元素</span></span><br><span class="line">resizeObserver.<span class="title function_">unobserve</span>(myElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止观察所有元素并释放资源</span></span><br><span class="line">resizeObserver.<span class="title function_">disconnect</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>源码及解析如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useMemo, useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; isBrowser, noop &#125; <span class="keyword">from</span> <span class="string">&#x27;./misc/util&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">UseMeasureRect</span> = <span class="title class_">Pick</span>&lt;</span><br><span class="line">  <span class="title class_">DOMRectReadOnly</span>,</span><br><span class="line">  <span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span> | <span class="string">&#x27;top&#x27;</span> | <span class="string">&#x27;left&#x27;</span> | <span class="string">&#x27;right&#x27;</span> | <span class="string">&#x27;bottom&#x27;</span> | <span class="string">&#x27;height&#x27;</span> | <span class="string">&#x27;width&#x27;</span></span><br><span class="line">&gt;;</span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">UseMeasureRef</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Element</span> = <span class="title class_">Element</span>&gt; = <span class="function">(<span class="params">element: E</span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">UseMeasureResult</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Element</span> = <span class="title class_">Element</span>&gt; = [<span class="title class_">UseMeasureRef</span>&lt;E&gt;, <span class="title class_">UseMeasureRect</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义默认设置</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">defaultState</span>: <span class="title class_">UseMeasureRect</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">width</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">top</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">left</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">bottom</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">right</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> useMeasure&lt;E <span class="keyword">extends</span> <span class="title class_">Element</span> = <span class="title class_">Element</span>&gt;(): <span class="title class_">UseMeasureResult</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="comment">// element用于存储对DOM元素的引用</span></span><br><span class="line">  <span class="keyword">const</span> [element, ref] = useState&lt;E | <span class="literal">null</span>&gt;(<span class="literal">null</span>);</span><br><span class="line">  <span class="comment">// rect用于存储测量的结果</span></span><br><span class="line">  <span class="keyword">const</span> [rect, setRect] = useState&lt;<span class="title class_">UseMeasureRect</span>&gt;(defaultState);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个监听器函数，当被监听元素尺寸位置发生变化时，设置并返回新的位置尺寸信息</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="title function_">useMemo</span>(</span><br><span class="line">    <span class="function">() =&gt;</span></span><br><span class="line">      <span class="keyword">new</span> (<span class="variable language_">window</span> <span class="keyword">as</span> any).<span class="title class_">ResizeObserver</span>(<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (entries[<span class="number">0</span>]) &#123;</span><br><span class="line">          <span class="keyword">const</span> &#123; x, y, width, height, top, left, bottom, right &#125; = entries[<span class="number">0</span>].<span class="property">contentRect</span>;</span><br><span class="line">          <span class="title function_">setRect</span>(&#123; x, y, width, height, top, left, bottom, right &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;),</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!element) <span class="keyword">return</span>;</span><br><span class="line">    observer.<span class="title function_">observe</span>(element);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      observer.<span class="title function_">disconnect</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [element]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回ref回调函数 可以将它绑定到元素的ref属性上，React会在组件挂载时将DOM元素作为参数传递给该ref回调函数</span></span><br><span class="line">  <span class="comment">// 以及 rect对象（包含了元素的尺寸和位置信息）</span></span><br><span class="line">  <span class="keyword">return</span> [ref, rect];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浏览器兼容性处理</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> isBrowser &amp;&amp; <span class="keyword">typeof</span> (<span class="variable language_">window</span> <span class="keyword">as</span> any).<span class="property">ResizeObserver</span> !== <span class="string">&#x27;undefined&#x27;</span></span><br><span class="line">  ? useMeasure</span><br><span class="line">  : ((<span class="function">() =&gt;</span> [noop, defaultState]) <span class="keyword">as</span> <span class="keyword">typeof</span> useMeasure);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="useMouse"><a href="#useMouse" class="headerlink" title="useMouse"></a>useMouse</h2><p><code>useMouse</code>用于动态跟踪鼠标的位置</p>
<p>源码及解析如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RefObject</span>, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> useRafState <span class="keyword">from</span> <span class="string">&#x27;./useRafState&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; off, on &#125; <span class="keyword">from</span> <span class="string">&#x27;./misc/util&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface <span class="title class_">State</span> &#123;</span><br><span class="line">  <span class="attr">docX</span>: number; <span class="comment">// 鼠标的X坐标相对于整个文档（document）的位置</span></span><br><span class="line">  <span class="attr">docY</span>: number; <span class="comment">// 鼠标的Y坐标相对于整个文档的位置</span></span><br><span class="line">  <span class="attr">posX</span>: number; <span class="comment">// 目标元素的X坐标相对于其定位上下文（positioning context）的位置</span></span><br><span class="line">  <span class="attr">posY</span>: number; <span class="comment">// 目标元素的Y坐标相对于其定位上下文的位置</span></span><br><span class="line">  <span class="attr">elX</span>: number; <span class="comment">// 鼠标的X坐标相对于目标元素（offset parent）的位置</span></span><br><span class="line">  <span class="attr">elY</span>: number; <span class="comment">// 鼠标的Y坐标相对于目标元素（offset parent）的位置</span></span><br><span class="line">  <span class="attr">elH</span>: number; <span class="comment">// 目标元素自身的高度</span></span><br><span class="line">  <span class="attr">elW</span>: number; <span class="comment">// 目标元素自身的宽度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useMouse = (<span class="attr">ref</span>: <span class="title class_">RefObject</span>&lt;<span class="title class_">Element</span>&gt;): <span class="function"><span class="params">State</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useRafState&lt;<span class="title class_">State</span>&gt;(&#123;</span><br><span class="line">    <span class="attr">docX</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">docY</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">posX</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">posY</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">elX</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">elY</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">elH</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">elW</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">moveHandler</span> = (<span class="params">event: MouseEvent</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 如果已经绑定了元素的ref属性</span></span><br><span class="line">      <span class="keyword">if</span> (ref &amp;&amp; ref.<span class="property">current</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; left, top, <span class="attr">width</span>: elW, <span class="attr">height</span>: elH &#125; = ref.<span class="property">current</span>.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line">        <span class="comment">// window.pageXOffset 表示当前文档水平滚动的距离</span></span><br><span class="line">        <span class="keyword">const</span> posX = left + <span class="variable language_">window</span>.<span class="property">pageXOffset</span>;</span><br><span class="line">        <span class="keyword">const</span> posY = top + <span class="variable language_">window</span>.<span class="property">pageYOffset</span>;</span><br><span class="line">        <span class="keyword">const</span> elX = event.<span class="property">pageX</span> - posX;</span><br><span class="line">        <span class="keyword">const</span> elY = event.<span class="property">pageY</span> - posY;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">setState</span>(&#123;</span><br><span class="line">          <span class="attr">docX</span>: event.<span class="property">pageX</span>,</span><br><span class="line">          <span class="attr">docY</span>: event.<span class="property">pageY</span>,</span><br><span class="line">          posX,</span><br><span class="line">          posY,</span><br><span class="line">          elX,</span><br><span class="line">          elY,</span><br><span class="line">          elH,</span><br><span class="line">          elW,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">on</span>(<span class="variable language_">document</span>, <span class="string">&#x27;mousemove&#x27;</span>, moveHandler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">off</span>(<span class="variable language_">document</span>, <span class="string">&#x27;mousemove&#x27;</span>, moveHandler);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [ref]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useMouse;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="usePageLeave"><a href="#usePageLeave" class="headerlink" title="usePageLeave"></a>usePageLeave</h2><p><code>usePageLeave</code> 用于当鼠标离开页面时触发一个回调</p>
<blockquote>
<p><code>event.relatedTarget</code> 和 <code>event.toElement</code></p>
</blockquote>
<p>浏览器默认事件对象中的属性，<code>relatedTarget</code>属性是一个事件属性，它在某些特定的事件中提供了关于事件的额外上下文。这个属性特别用于鼠标事件，比如mouseover和mouseout，以及焦点事件，比如focusin和focusout。</p>
<p>relatedTarget属性引用了与事件相关的一个DOM元素</p>
<p>对于<strong>鼠标事件</strong>：</p>
<ul>
<li>在mouseover事件中，<code>relatedTarget</code>属性引用的是鼠标刚刚离开的那个元素，即鼠标指针之前所在的元素。</li>
<li>在mouseout事件中，<code>relatedTarget</code>属性引用的是鼠标即将移动到的那个元素，即鼠标指针即将进入的元素。</li>
</ul>
<p>对于<strong>焦点事件</strong>：</p>
<p>在focusin（或focus）事件中，<code>relatedTarget</code>属性引用的是失去焦点的元素，即焦点从哪个元素移开。<br>在focusout（或blur）事件中，<code>relatedTarget</code>属性引用的是即将获得焦点的元素，即焦点将要移到哪个元素上。</p>
<p><code>toElement</code>的作用与<code>relatedTarget</code>相似，特别是在mouseover和mouseout事件上，用于兼容旧版本浏览器</p>
<p>源码及解析如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; off, on &#125; <span class="keyword">from</span> <span class="string">&#x27;./misc/util&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">usePageLeave</span> = (<span class="params">onPageLeave, args = []</span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!onPageLeave) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handler</span> = (<span class="params">event</span>) =&gt; &#123;</span><br><span class="line">      event = event ? event : (<span class="variable language_">window</span>.<span class="property">event</span> <span class="keyword">as</span> any);</span><br><span class="line">      <span class="comment">// from 保存了鼠标即将移动到的元素</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">from</span> = event.<span class="property">relatedTarget</span> || event.<span class="property">toElement</span>;</span><br><span class="line">      <span class="comment">// 鼠标是否离开浏览器文档页面时触发回调</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">from</span> || (<span class="keyword">from</span> <span class="keyword">as</span> any).<span class="property">nodeName</span> === <span class="string">&#x27;HTML&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">onPageLeave</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">on</span>(<span class="variable language_">document</span>, <span class="string">&#x27;mouseout&#x27;</span>, handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">off</span>(<span class="variable language_">document</span>, <span class="string">&#x27;mouseout&#x27;</span>, handler);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, args);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> usePageLeave;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="useClickAway"><a href="#useClickAway" class="headerlink" title="useClickAway"></a>useClickAway</h2><p><code>useClickAway</code>用于当用户在目标元素外部单击时触发回调</p>
<p>源码及解析如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RefObject</span>, useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; off, on &#125; <span class="keyword">from</span> <span class="string">&#x27;./misc/util&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultEvents = [<span class="string">&#x27;mousedown&#x27;</span>, <span class="string">&#x27;touchstart&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ref：目标对象的ref引用</span></span><br><span class="line"><span class="comment"> * onClickAway：传入的回调函数</span></span><br><span class="line"><span class="comment"> * events：需要绑定的事件类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> useClickAway = &lt;E <span class="keyword">extends</span> <span class="title class_">Event</span> = <span class="title class_">Event</span>&gt;<span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  ref: RefObject&lt;HTMLElement | <span class="literal">null</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  onClickAway: (event: E) =&gt; <span class="keyword">void</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  events: string[] = defaultEvents</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 缓存传入的回调函数</span></span><br><span class="line">  <span class="keyword">const</span> savedCallback = <span class="title function_">useRef</span>(onClickAway);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    savedCallback.<span class="property">current</span> = onClickAway;</span><br><span class="line">  &#125;, [onClickAway]);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handler</span> = (<span class="params">event</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">current</span>: el &#125; = ref;</span><br><span class="line">      <span class="comment">// el 是对DOM元素的引用</span></span><br><span class="line">      <span class="comment">// 如果 el存在 并且 当前触发事件的元素不是el及其子孙节点 则 执行传入的回调函数</span></span><br><span class="line">      <span class="comment">// contains 方法是用来测试一个节点是否是另一个节点的后代。如果目标元素在 el 之外，contains 方法会返回 false，取反后为 true</span></span><br><span class="line">      el &amp;&amp; !el.<span class="title function_">contains</span>(event.<span class="property">target</span>) &amp;&amp; savedCallback.<span class="title function_">current</span>(event);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 绑定用户传入的所有事件类型</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> eventName <span class="keyword">of</span> events) &#123;</span><br><span class="line">      <span class="title function_">on</span>(<span class="variable language_">document</span>, eventName, handler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> eventName <span class="keyword">of</span> events) &#123;</span><br><span class="line">        <span class="title function_">off</span>(<span class="variable language_">document</span>, eventName, handler);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [events, ref]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useClickAway;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/React-Hooks/">React Hooks</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/03/29/useContext/"><span>useContext</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/03/29/useContext/" rel="bookmark">
        <time class="entry-date published" datetime="2024-03-29T12:59:23.000Z">
          2024-03-29
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="context"><a href="#context" class="headerlink" title="context"></a><code>context</code></h2><p>在开发中，父组件可能需要通过多层中间组件将 props 传递给某个子孙组件，这个传递 props 的过程就会变得十分冗长</p>
<p><code>context</code>可以在组件树中<strong>不需要</strong>props 传递数据，而是将数据<strong>直达</strong>所需的组件</p>
<p><code>context</code>可以让父组件为其<strong>内部的整个组件树人</strong>提供数据</p>
<h2 id="使用context"><a href="#使用context" class="headerlink" title="使用context"></a>使用<code>context</code></h2><p>使用<code>context</code>需要三个步骤：</p>
<ul>
<li>创建一个<code>context</code></li>
<li>在需要数据的组件中使用创建的<code>context</code></li>
<li>在指定数据的组件中提供<code>context</code></li>
</ul>
<h3 id="创建一个context"><a href="#创建一个context" class="headerlink" title="创建一个context"></a>创建一个<code>context</code></h3><p>新建一个 js 文件，在其中创建<code>constext</code>并导出他</p>
<p>使用<code>createContext()</code>来创建一个 context，需要给他传入一个默认值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title function_">createContext</span>(<span class="number">1</span>); <span class="comment">// 创建并导出一个context</span></span><br></pre></td></tr></table></figure>

<h3 id="使用context-1"><a href="#使用context-1" class="headerlink" title="使用context"></a>使用<code>context</code></h3><p>在需要用到数据的组件中，引入<code>useContext</code>Hook 以及 创建的<code>context</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">MyContext</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./MyContext.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>) [</span><br><span class="line">  <span class="keyword">const</span> context = <span class="title function_">useContext</span>(<span class="title class_">MyContext</span>) <span class="comment">// useContext 告诉 React 想要读取 myContext</span></span><br><span class="line">  <span class="comment">// 现在，得到的context就是myContext的默认值</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="提供context"><a href="#提供context" class="headerlink" title="提供context"></a>提供<code>context</code></h3><p>在父组件中使用<code>context provider</code>将子组件包裹起来，就可以提供<code>context</code>给他们</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">MyContext</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./MyContext.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> [ name, setName ] = <span class="title function_">useState</span>(<span class="string">&#x27;easy code sniper&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;MyContext.Provider value=&#123;name&#125;&gt;</span><br><span class="line">      &lt;MyContext.Provider&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这告诉 React：“如果在<code>Parent</code>组件中的任何子组件请求<code>MyContext</code>，给他们这个<code>name</code>。”<br>组件会使用 UI 树中在它上层最近的那个<code>MyContext.Provider</code>传递过来的值。</p>
<h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a><code>useContext</code></h2><p><strong>语法：</strong><code>const value = useContext(SomeContext)</code></p>
<ul>
<li><code>SomeContext</code>就是先前用<code>createContext</code>创建的 context，context 本身不包含信息，它只代表你可以提供或从组件中读取的信息类型。</li>
</ul>
<p><strong>返回值</strong></p>
<p><code>useContext</code>为调用它的组件返回 context 的值。它的返回值被确定为传递给树中调用组件上方最近的<code>SmeContext.Provider</code>的<code>value</code>。<br>如果没有这样的 provider，那么返回值将会是为创建该 context 传递给<code>createContext</code>的<code>defaultValue</code>。返回的值始终是最新的，如果 context 发生变化，React 会自动重新渲染读取 context 的组件。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/React-Hooks/">React Hooks</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/03/26/设计模式浅谈/"><span>设计模式浅谈</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/03/26/设计模式浅谈/" rel="bookmark">
        <time class="entry-date published" datetime="2024-03-26T13:01:25.000Z">
          2024-03-26
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态的含义是：同一操作作用于不同对象上，可以产生不同的解释和不同的执行结果。也就是说，给不同的对象发送同一个消息，对象会做出不同的反馈</p>
<p>下面的代码就体现着多态性，当我们分别向程序员和老师发出工作的消息时，他们根据此作出了不同的反应</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> work = <span class="keyword">function</span> (<span class="params">person</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(person <span class="keyword">instanceof</span> <span class="title class_">Coder</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;coding&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (person <span class="keyword">instanceof</span> <span class="title class_">Teacher</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;teaching&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Coder</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Teacher</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">work</span>(<span class="keyword">new</span> <span class="title class_">Coder</span>()) <span class="comment">// coding</span></span><br><span class="line"><span class="title function_">work</span>(<span class="keyword">new</span> <span class="title class_">Teacher</span>()) <span class="comment">// teaching</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但这样的多态性无法令人满意，如果现在要新增一个司机类型，那我们就需要修改work函数的代码。修改的代码越多，就存在越多的危险，并且work函数也会随着类型的变多成为一个巨大的函数</p>
<p>多态背后的思想是：将<strong>做什么</strong>与<strong>谁去做怎么做</strong>分离开来。<br>在上面的例子中，人都会工作，但是不同的人怎么工作是不同的。把不变的部分隔离出来，把可变的部分封装起来，这就给予了我们扩展程序的能力。</p>
<p>通过下面的改动，将不变的部分隔离出来，那就是所有人都会工作。然后把可变的部分各自封装起来</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> work = <span class="keyword">function</span> (<span class="params">person</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(person.<span class="property">work</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span>) &#123;</span><br><span class="line">    person.<span class="title function_">work</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Coder</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">Coder</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">work</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;coding&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Teacher</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">Teacher</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">work</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;teaching&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">work</span>(<span class="keyword">new</span> <span class="title class_">Coder</span>())</span><br><span class="line"><span class="title function_">work</span>(<span class="keyword">new</span> <span class="title class_">Teacher</span>())</span><br></pre></td></tr></table></figure>

<p>与静态语言类型不同的是，JavaScript的变量类型在运行期是可变的。一个JavaScript对象，既可以是<code>Coder</code>类型，也可以是<code>Teacher</code>类型。这就意味着<strong>JavaScript对象的多态性是与生俱来的</strong></p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装的目的是将信息隐藏，封装可以是<strong>对任何形式内容的封装</strong>。也就是说，封装不仅仅是隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型等</p>
<p>封装使得对象内部的变化对其他对象而言是透明的，其他对象也不关心它的内部实现。</p>
<p><strong>封装变化</strong></p>
<p>通过封装变化的方式，把系统中稳定不变的部分和易于变化的部分隔离开来，我们只需要替换易于变化的部分。这可以很大程度上保证程序的稳定性和可扩展性</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>在以类为中心的面向对象编程语言中，对象总是从类中创建出来的。而在原型编程的思想中，类不是必须的，对象也未必需要从类中创建出来。一个对象是通过克隆另一个对象所得到的。</p>
<p>原型模式的关键在于<strong>通过克隆来创建对象</strong>，即语言本身是否提供了clone方法。在ES5中提供了<code>Object.create</code>方法来克隆对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;easy code sniper&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clonePerson = <span class="title class_">Object</span>.<span class="title function_">create</span>( person )</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(clonePerson) <span class="comment">// &#123; name: &#x27;easy code sniper&#x27;, age: 22 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="JavaScript中的原型继承"><a href="#JavaScript中的原型继承" class="headerlink" title="JavaScript中的原型继承"></a>JavaScript中的原型继承</h3><p>JavaScript遵循原型编程的基本规则：</p>
<ul>
<li>所有的数据都是对象</li>
<li>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它</li>
<li>对象会记住它的原型</li>
<li>如果对象无法响应某个请求，它会把这个请求委托给自己的原型</li>
</ul>
<p><strong>1.所有的数据都是对象</strong></p>
<p>JavaScript有两种类型机制：基本类型 和 对象类型</p>
<p>基于一切都应该是对象的本意（除了undefined之外），基本类型数据可以通过包装类的方式变成对象类型数据</p>
<p>JavaScript中的根对象是<code>Object.prototype</code>对象，<code>Object.prototype</code>对象是一个空的对象。在JS中遇到的每个对象，实际都是从<code>Object.prototype</code>对象克隆而来的</p>
<p><strong>2.要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它</strong></p>
<p>在JavaScript中我们不需要关心克隆的细节，只是显式地调用<code>let obj = new Object()</code>或<code>let obj = &#123;&#125;</code>，引擎内部会从<code>Object.prototype</code>上面克隆一个对象出来</p>
<p>JavaScript的函数集可以作为普通函数被调用，也可以作为构造器被调用。当使用<code>new</code>运算符来调用函数时，此时的函数就是一个构造器。用<code>new</code>运算符来创建对象的过程，实际上也只是先克隆<code>Object.prototype</code>对象，再进行一些其他额外操作的过程</p>
<p>模拟<code>new</code>创建对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> objectFactory = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>() <span class="comment">// 先克隆一个空对象</span></span><br><span class="line">    <span class="title class_">Constructor</span> = [].<span class="property">shift</span>.<span class="title function_">call</span>( <span class="variable language_">arguments</span> ) <span class="comment">// 取出参数中的第一项，即外部传入的构造器</span></span><br><span class="line">    obj.<span class="property">__proto__</span> = <span class="title class_">Constructor</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// 指向正常的原型</span></span><br><span class="line">    <span class="keyword">let</span> ret = <span class="title class_">Constructor</span>.<span class="title function_">apply</span>(obj, <span class="variable language_">arguments</span>) <span class="comment">// 基于剩余的arguments给obj设置属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">&#x27;object&#x27;</span> ? ret : obj <span class="comment">// 确保构造器总是返回一个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="title function_">objectFactory</span>(<span class="title class_">Person</span>, <span class="string">&#x27;easy code sniper&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a.<span class="property">name</span> ); <span class="comment">// easy code sniper</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a.<span class="title function_">getName</span>() ); <span class="comment">// easy code sniper</span></span><br></pre></td></tr></table></figure>

<p><strong>3.对象会记住它的原型</strong></p>
<p>JavaScript给对象提供一个<code>__proto__</code>属性，某个对象的<code>__proto__</code>属性默认会指向它的构造器的原型对象，即<code>Constructor.prototype</code></p>
<p><code>__proto__</code>就是 对象 和 对象构造器的原型 联系起来的纽带。这就是我们在<code>objectFactory</code>函数中需要手动给obj对象设置正确的<code>__proto__</code>指向</p>
<h2 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h2><p>this 的指向大致可以分为 4 种情况：</p>
<ul>
<li>作为对象的方法调用</li>
<li>作为普通函数调用</li>
<li>构造器调用</li>
<li><code>call</code> 和 <code>apply</code> 调用</li>
</ul>
<h3 id="作为对象的方法调用"><a href="#作为对象的方法调用" class="headerlink" title="作为对象的方法调用"></a>作为对象的方法调用</h3><p>当函数作为对象的方法被调用时，this 指向该对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;easy code sniper&quot;</span>,</span><br><span class="line">  <span class="attr">getName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === obj); <span class="comment">// true</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// easy code sniper</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">getName</span>();</span><br></pre></td></tr></table></figure>

<h3 id="作为普通函数调用"><a href="#作为普通函数调用" class="headerlink" title="作为普通函数调用"></a>作为普通函数调用</h3><p>当函数作为普通函数被调用时，this 指向全局对象。在浏览器中，全局对象就是 window；在 Node 环境中，全局对象就是 globalThis</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">globalThis.<span class="property">name</span> = <span class="string">&quot;easy code sniper&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>(); <span class="comment">// easy code sniper</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line">globalThis.<span class="property">name</span> = <span class="string">&quot;cqy&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;easy code sniper&quot;</span>,</span><br><span class="line">  <span class="attr">getName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === obj); <span class="comment">// false</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// cqy</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func = obj.<span class="property">getName</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>();</span><br></pre></td></tr></table></figure>

<h3 id="构造器调用"><a href="#构造器调用" class="headerlink" title="构造器调用"></a>构造器调用</h3><p>除了一些内置函数，大部分 JS 函数都可以当作构造器使用。当使用 new 运算符调用函数时，该函数总是返回一个对象，通常情况下，构造器里的 this 就<strong>指向返回的对象</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Func</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;easy code sniper&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Func</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// easy code sniper</span></span><br></pre></td></tr></table></figure>

<p>如果构造器显式的返回一个对象，那么返回的将会是这个对象，this也会指向这个对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Func</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;easy code sniper&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;cqy&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Func</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// cqy</span></span><br></pre></td></tr></table></figure>


<h2 id="call-和-apply"><a href="#call-和-apply" class="headerlink" title="call 和 apply"></a>call 和 apply</h2><p><code>Function.prototype.call</code>和<code>Function.prototype.apply</code>是定义在Function的原型上的两个方法，用于动态的改变this指向</p>
<p>call和apply的作用一模一样，区别仅在于传入参数的形式不同：</p>
<ul>
<li>apply接受两个参数，第一个参数指定函数体内this的指向，第二个参数会作为参数传递给被调用的函数，类型为数组或类数组</li>
<li>call传入参数数量不固定，第一个参数指定函数体内this的指向，从第二个参数开始往后，每个参数被依次传入函数</li>
</ul>
<p>当使用call或者apply的时候，如果传入的第一个参数为null，函数体内的this会指向默认的宿主对象，在浏览器中则是window</p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p><strong>1.改变this指向</strong></p>
<p>call和apply最常见的用途是改变函数内部的this指向</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;easy code sniper&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;cqy&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getName = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getName</span>() <span class="comment">// window</span></span><br><span class="line">getName.<span class="title function_">call</span>(obj1) <span class="comment">// easy code sniper</span></span><br><span class="line">getName.<span class="title function_">call</span>(obj2) <span class="comment">// cqy</span></span><br></pre></td></tr></table></figure>

<p><strong>2.Function.prototype.bind</strong></p>
<p>大部分高级浏览器都实现了内置的<code>Function.prototype.bind</code>，用来指定函数内部的this指向，即使没有原生的<code>Function.prototype.bind</code>实现，也可以使用call或者apply模拟</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span> <span class="comment">// 保存调用bind的原函数</span></span><br><span class="line">  context = [].<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>) <span class="comment">// 借用数组的shift方法拿到arguments的第一项，即需要指向的this</span></span><br><span class="line">  args = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>) <span class="comment">// 将剩余参数转化为数组</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 指定this为之前传入的context</span></span><br><span class="line">    <span class="comment">// 合并两次传入的参数，作为新函数的参数</span></span><br><span class="line">    <span class="keyword">return</span> self.<span class="title function_">apply</span>(context, [].<span class="property">concat</span>.<span class="title function_">call</span>(args, [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;cqy&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func = <span class="keyword">function</span>(<span class="params">a,b,c,d</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>([a,b,c,d])</span><br><span class="line">&#125;.<span class="title function_">bind</span>(obj, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 输出：cqy [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p><strong>3.借用其他对象的方法</strong></p>
<p>借用方法较为常见的就是：<br>函数的参数列表arguments是一个类数组对象，它并非真正的数组，所以不能像数组一样，进行排序操作或者往集合里添加一个新的元素。我们常常会借用<code>Array.prototype</code>对象上的方法</p>
<p>比如想往arguments中添加一个新的元素，通常借用<code>Array.prototype.push</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure>

<p>在操作arguments的时候，我们经常非常频繁地找<code>Array.prototype</code>对象借用方法。<br>想把arguments转成真正的数组的时候，可以借用<code>Array.prototype.slice</code>方法;想截去arguments列表中的头一个元素时，又可以借用<code>Array.prototype.shift</code>方法。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><strong>变量的作用域</strong></p>
<p>在JS中，函数可以用来创造函数作用域。函数就像一层半透明的玻璃，在函数里面可以看到外面的便利，而在函数外面则无法看到函数里面的变量。</p>
<p>这是因为当在函数中搜索一个变量的时候，如果该函数内并没有声明这个变量，那么此次搜索的过程会随着代码执行环境创建的作用域链往外层逐层搜索，一直搜索到全局对象为止。变量的搜索是<strong>从内到外</strong>的。</p>
<p><strong>变量的生存周期</strong></p>
<p>对于全局变量来说，生存周期是永久的，除非主动销毁这个全局变量</p>
<p>对于函数内的局部变量来说，当退出函数时，这些局部变量就失去了他们价值，随着函数调用的结束而销毁</p>
<p>退出函数后局部变量a将被销毁</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>

<p>再看看下面这段代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    a++</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="title function_">func</span>()</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，退出函数之后，局部变量a并没有消失。当执行<code>let f = func()</code>时，f拿到一个匿名函数的引用，它可以访问到func被调用时产生的环境，而局部变量a一直处在这个环境里。</p>
<p>既然局部变量所在的环境还能被外界访问，这个局部变量就有了不被销毁的理由。在这里产生了一个闭包结构，局部变量的生命看起来被延续了。</p>
<h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><p><strong>封装变量</strong></p>
<p>闭包可以帮助把一些不需要暴露在全局的变量封装成‘私有变量’，例如下面有一个计算参数乘积的简单函数，并使用全局的cache变量缓存结果来提高性能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cache = &#123;&#125; <span class="comment">// 缓存结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mult = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">join</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="string">&#x27;,&#x27;</span>) <span class="comment">// 将参数拼接成字符串，作为cache中的属性名</span></span><br><span class="line">  <span class="keyword">if</span>( cache[args] ) &#123; <span class="comment">// 如果命中缓存就返回结果</span></span><br><span class="line">    <span class="keyword">return</span> cache[args]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++ ) &#123;</span><br><span class="line">    a *= <span class="variable language_">arguments</span>[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cache[args] = a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cache变量仅在mult函数中被使用，与其让他暴露在全局作用域下，不如将它封闭在mult函数内部</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mult = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> cache = &#123;&#125; <span class="comment">// 将cache封装在mult里面</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">join</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="string">&#x27;,&#x27;</span>) <span class="comment">// 将参数拼接成字符串，作为cache中的属性名</span></span><br><span class="line">    <span class="keyword">if</span>( cache[args] ) &#123; <span class="comment">// 如果命中缓存就返回结果</span></span><br><span class="line">      <span class="keyword">return</span> cache[args]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++ ) &#123;</span><br><span class="line">      a *= <span class="variable language_">arguments</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[args] = a</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数是指至少满足下列条件之一的函数：</p>
<ul>
<li>函数可以作为参数被传递</li>
<li>函数可以作为返回值输出</li>
</ul>
<h3 id="函数作为参数传递"><a href="#函数作为参数传递" class="headerlink" title="函数作为参数传递"></a>函数作为参数传递</h3><p>将函数作为参数进行传递，一个很重要的应用场景就是回调函数。这代表我们将容易变化的业务逻辑抽离出来，把这部分业务逻辑放在函数参数中，这样一来可以分离业务代码中变化与不变的部分</p>
<p>比如我们想在页面中创建一个div节点，然后给这个节点设置一些样式，下面是一种编写代码的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> appendDiv = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">  div.<span class="property">innerHTML</span> = <span class="string">&#x27;我是一个div&#x27;</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div)</span><br><span class="line">  div.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span> <span class="comment">// 设置样式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把<code>div.style.display = &#39;none&#39;</code>的逻辑硬编码在appendDiv里显然不太合理，这使得appendDiv有点太个性化里，成为了一个难以敷用的函数。</p>
<p>如果把<code>div.style.display = &#39;none&#39;</code>的逻辑抽离出来，用回调函数的形式传入appendDiv，这样appendDiv只要专注于创建节点就行了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> appendDiv = <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">  div.<span class="property">innerHTML</span> = <span class="string">&#x27;我是一个div&#x27;</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div)</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>)   &#123;</span><br><span class="line">    <span class="title function_">callback</span>(div)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">appendDiv</span>(<span class="keyword">function</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  node.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>除此之外，<code>Array.prototype.sort</code>方法接受一个函数作为参数，这个函数里面封装了数组元素的排序规则。排序规则是可变的，把可变的封装在函数参数里。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>].<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1, 3, 5</span></span><br></pre></td></tr></table></figure>

<h3 id="函数作为返回值输出"><a href="#函数作为返回值输出" class="headerlink" title="函数作为返回值输出"></a>函数作为返回值输出</h3><p>让函数返回一个可执行的函数，意味着运算过程是可延续的，更能体现函数式编程的巧妙</p>
<p><strong>1.判断数据的类型</strong></p>
<p>要判断数据类型，更好的方法是用<code>Object.prototype.toString</code>来计算，<code>Object.prototype.toString.call(obj)</code>返回一个字符串</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isString = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object String]&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isArray = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object Array]&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isNumber = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object Number]&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isObject = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object Object]&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些函数的发部分实现都是相同的，不同的是判断部分。为了避免多余的代码，我们可以把这些代表数据类型的字符串作为参数提前传入<code>isType</code>函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isType = <span class="keyword">function</span>(<span class="params">type</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isString = <span class="title function_">isType</span>(<span class="string">&#x27;String&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> isArray = <span class="title function_">isType</span>(<span class="string">&#x27;Array&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> isNumber = <span class="title function_">isType</span>(<span class="string">&#x27;Number&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> isObject = <span class="title function_">isType</span>(<span class="string">&#x27;Object&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="高阶函数的其他应用"><a href="#高阶函数的其他应用" class="headerlink" title="高阶函数的其他应用"></a>高阶函数的其他应用</h3><p><strong>1.函数柯里化（currying）</strong></p>
<p>一个currying的函数首先会接受一些参数，接受了这些参数后，该函数不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数真正需要求值的时候，之前传入的所有参数都会被一次性用于求值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于将函数进行柯里化</span></span><br><span class="line"><span class="comment"> * 接受一个参数：即将要被currying的函数 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> currying = <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [].<span class="property">push</span>.<span class="title function_">apply</span>(args, <span class="variable language_">arguments</span>)</span><br><span class="line">        <span class="comment">// arguments.callee 是一个在函数内部可用的属性，它指向当前正在执行的函数。这在匿名函数中特别有用，因为它允许你引用函数本身，而不需要知道函数的名字。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">arguments</span>.<span class="property">callee</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      res += <span class="variable language_">arguments</span>[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将sum函数进行柯里化</span></span><br><span class="line"><span class="keyword">let</span> curryingSum = <span class="title function_">currying</span>(sum)</span><br><span class="line"></span><br><span class="line"><span class="title function_">curryingSum</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">curryingSum</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">curryingSum</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curryingSum</span>()); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p><strong>2.函数节流</strong></p>
<p>函数有可能被非常频繁地调用，而造成大的性能问题。函数节流的原理：将即将要被执行的函数用setTimeout延迟一段时间执行。如果该次延迟执行还没有完成，则忽略接下来调用该函数的请求</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流函数</span></span><br><span class="line"><span class="comment"> * fn：需要被延迟执行的函数</span></span><br><span class="line"><span class="comment"> * interval：延迟执行的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> throttle = <span class="keyword">function</span>(<span class="params">fn, interval</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> _self = fn <span class="comment">// 保存被延迟执行的函数引用</span></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span> <span class="comment">// 定时器</span></span><br><span class="line">  <span class="keyword">let</span> firstTime = <span class="literal">true</span> <span class="comment">// 是否是第一次调用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="variable language_">arguments</span></span><br><span class="line">    <span class="keyword">let</span> _me = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(firstTime) &#123; <span class="comment">// 如果是第一次调用，不需要延迟执行</span></span><br><span class="line">      _self.<span class="title function_">apply</span>(_me, args)</span><br><span class="line">      <span class="keyword">return</span> firstTime = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(timer) &#123; <span class="comment">// 前一次延迟执行还没有完成，忽略此次请求</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 延迟一段时间执行</span></span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">      timer = <span class="literal">null</span></span><br><span class="line">      _self.<span class="title function_">apply</span>(_me, args)</span><br><span class="line">    &#125;, interval || <span class="number">500</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例：监听浏览器尺寸变化</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onresize</span> = <span class="title function_">throttle</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br></pre></td></tr></table></figure>

<p><strong>3.分时函数</strong></p>
<p>某些函数是用户主动调用的，但因为一些客观原因，这些函数会严重影响页面性能</p>
<p>例如我们要在页面上渲染1000个div节点，在短时间内往页面中大量添加DOM节点会导致浏览器卡顿甚至假死</p>
<p>解决方案之一就是将创建节点的工作分批进行。比如把1秒创建1000个节点，改为每隔200毫秒创建8个节点</p>
<p>设计一个<code>timeChunk</code>函数来分批创建节点，函数接受3个参数：</p>
<ul>
<li>ary：创建节点时需要用到的原始数据</li>
<li>fn：封装了创建节点逻辑的函数</li>
<li>count：每一批创建的节点数量</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timeChunk = <span class="keyword">function</span>(<span class="params">ary, fn, count</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> obj, timer</span><br><span class="line">  <span class="keyword">let</span> len = ary.<span class="property">length</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> start = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="title class_">Math</span>.<span class="title function_">min</span>(count || <span class="number">1</span>, len); i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> item = ary.<span class="title function_">shift</span>()</span><br><span class="line">      <span class="title function_">fn</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    timer = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(len === <span class="number">0</span>) &#123; <span class="comment">// 如果全部节点都创建好了，取消定时器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">start</span>()</span><br><span class="line">    &#125;, <span class="number">200</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ary = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  ary.<span class="title function_">push</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> renderList = <span class="title function_">timeChunk</span>(ary, <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">  div.<span class="property">innerHTML</span> = n</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div)</span><br><span class="line">&#125;, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">renderList</span>()</span><br></pre></td></tr></table></figure>


      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/设计模式/">设计模式</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/03/26/useMemo和useCallback/"><span>useMemo &amp; useCallback</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/03/26/useMemo和useCallback/" rel="bookmark">
        <time class="entry-date published" datetime="2024-03-26T12:59:28.000Z">
          2024-03-26
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a><code>useMemo</code></h1><p><code>useMemo</code>用于缓存每次重新渲染都需要计算的结果</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><strong><code>useMemo(calculateValue,dependencies)</code></strong></p>
<ul>
<li><code>calculateValue</code>: 缓存计算值的函数，它应该是一个没有参数的纯函数。React将在首次渲染时调用该函数，在之后的渲染中，如果依赖项（<code>dependencies</code>）没有发生变化，React将不会调用该函数，而是直接返回缓存的值</li>
<li><code>dependencies</code>: 依赖项</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>在初次渲染时，返回<code>calculateValue</code>函数的返回值</li>
<li>在之后的渲染中，如果依赖项没有变化，则返回缓存的值；如果依赖项发生了变化，将重新调用<code>calculateValue</code>函数并计算出新的返回值</li>
</ul>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p><code>useMemo</code>主要的用法有两种：</p>
<ul>
<li>通过缓存数据，来跳过代价昂贵的计算</li>
<li>跳过组件的重新渲染</li>
</ul>
<p><strong>跳过代价昂贵的计算</strong></p>
<p>例如，我们有一个todos的大数组，需要根据tab来筛选出某些数组项。在初次渲染之后，只有当todos数组或者tab发生改变了才会重新执行过滤数组的方法。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TodoList</span>(<span class="params">&#123; todos, tab, theme &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> visibleTodos = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">filterTodos</span>(todos, tab), [todos, tab]);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>跳过组件的重新渲染</strong></p>
<p>例如，<code>ParentComp</code>组件接受一个<code>theme</code>的props，用于改变组件内部样式，<strong>默认情况下，一个组件重新渲染时，React会递归重新渲染它的所有子组建</strong>。也就是，当<code>theme</code>重新渲染时，会导致<code>SonComp</code>组件的重新渲染，但其实<code>SonComp</code>组件并不需要重新渲染。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ParentComp</span>(<span class="params">&#123; theme &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> visibleTodos = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">filterTodos</span>(todos, tab), [todos, tab]);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;theme&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">SonComp</span> <span class="attr">items</span>=<span class="string">&#123;visibleTodos&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过将组件用<code>memo</code>包裹起来，这样当它的props和上次传入的相同时，就不会触发重新渲染</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; memo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">SonComp</span> = <span class="title function_">memo</span>(<span class="keyword">function</span> <span class="title function_">SonComp</span>(<span class="params">&#123; items &#125;</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>引出<code>usecallback</code></strong></p>
<p>现在，<code>SonComp</code>组件被包裹在<code>memo</code>中，接收一个函数作为props。每次<code>ParentComp</code>组件重新渲染，都会导致<code>handleClick</code>函数的重新创建，即产生不同的<code>handleClick</code>，这就会导致<code>SonComp</code>组件的重新渲染</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ParentComp</span>(<span class="params">&#123; theme &#125;</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">SonComp</span> <span class="attr">handleClick</span>=<span class="string">&#123;handleClick&#125;/</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">SonComp</span> = <span class="title function_">memo</span>(<span class="keyword">function</span> <span class="title function_">SonComp</span>(<span class="params">&#123; handleClick &#125;</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>

<p>我们很容易想到使用<code>useMemo</code>来缓存handleClick函数，如下所示：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleClick = <span class="title function_">useMeme</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123; <span class="comment">// 原来handleClick的逻辑</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,[xxx])</span><br></pre></td></tr></table></figure>
<p>这样看上去就很冗余了，在React中有另外一个Hook用于缓存函数。</p>
<h1 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a><code>useCallback</code></h1><p><code>useCallback</code>允许你在多次渲染中缓存函数</p>
<h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><p><strong><code>useCallback(fn, dependencies)</code></strong></p>
<ul>
<li><code>fn</code>: 想要缓存函数，它可以传入任何参数并且返回任何值。React将在首次渲染时<strong>返回</strong>（不是调用）该函数，在之后的渲染中，如果依赖项（<code>dependencies</code>）没有发生变化，React将返回相同的函数。<strong>在任何渲染中，React都不会调用该函数，而是返回该函数</strong></li>
<li><code>dependencies</code>: 依赖项</li>
</ul>
<p><strong>返回值</strong></p>
<p>在初次渲染时，<code>useCallback</code>返回你已经传入的<code>fn</code>函数</p>
<p>在之后的渲染中, 如果依赖没有改变，<code>useCallback</code>返回上一次渲染中缓存的<code>fn</code>函数；否则返回这一次渲染传入的<code>fn</code>。</p>
<h2 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h2><p>接着上面的例子对<code>handleClick</code>进行改造，使它也被缓存起来</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleClick = <span class="title function_">useCallback</span>(<span class="function">(<span class="params">args</span>) =&gt;</span> &#123; <span class="comment">//和普通函数一样使用</span></span><br><span class="line">    <span class="comment">// 直接在此处书写逻辑代码</span></span><br><span class="line">&#125;,[xxx])</span><br></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/React-HookS/">React HookS</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/03/24/useRef/"><span>useRef</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/03/24/useRef/" rel="bookmark">
        <time class="entry-date published" datetime="2024-03-24T13:50:54.000Z">
          2024-03-24
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><code>useRef</code>可以用于引用一个不需要渲染的值</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><strong><code>useRef(initialValue)</code></strong></p>
<ul>
<li><code>initialValue</code>: ref对象的<code>current</code>属性的初始值，只在初次渲染的时候有效</li>
</ul>
<p><strong>返回值</strong></p>
<p><code>useRef</code>返回一个只有<code>current</code>属性的对象。<code>current</code>初始值为传递的<code>initialValue</code>，之后可以将其设置为其他值</p>
<p>如果将ref对象作为一个JSX节点的<code>ref</code>属性，React会为它设置<code>current</code>属性</p>
<p><strong>注意</strong></p>
<ul>
<li><code>ref.current</code>属性可以修改，它是可变的，这与<code>state</code>不同</li>
<li>改变<code>ref.current</code>属性，<strong>不会重新渲染组件</strong></li>
<li>除了进行初始化操作，不要在渲染期间写入或读取<code>ref.current</code></li>
</ul>
<blockquote>
<p>不要在渲染期间写入或者读取<code>ref.current</code>，如果不得不在渲染期间读取或写入，应该使用<code>state</code></p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  myRef.<span class="property">current</span> = <span class="number">123</span> <span class="comment">// ❌ 不要再渲染期间写入 ref</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;myRef.current&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> <span class="comment">// ❌ 不要再渲染期间读取 ref</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>事件处理程序或者Effect</strong>中读取或写入<code>ref</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    myRef.<span class="property">current</span> = <span class="number">123</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><code>useRef</code>的使用场景主要有两种：</p>
<ul>
<li>引用或存储一些不影响视图的信息。（因为改变ref不会触发重新渲染）</li>
<li>通过ref对象赋值给DOM的<code>ref</code>属性来获取或操作DOM</li>
</ul>
<h3 id="引用或存储一个值"><a href="#引用或存储一个值" class="headerlink" title="引用或存储一个值"></a>引用或存储一个值</h3><p>示例：保存定时器的id</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timerRef = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleStartClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 业务逻辑</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    timerRef.<span class="property">current</span> = timer <span class="comment">// 保存定时器id</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleStopClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timerRef.<span class="property">current</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      // ....</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过ref操作DOM"><a href="#通过ref操作DOM" class="headerlink" title="通过ref操作DOM"></a>通过ref操作DOM</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = <span class="title function_">useRef</span>(<span class="literal">null</span>) <span class="comment">// 声明一个初始值为 null 的ref对象</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    inputRef.<span class="property">current</span>.<span class="title function_">focus</span>() <span class="comment">//inputRef.current获取到DOm节点，并调用input节点上的focus方法</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span> <span class="comment">// 将DOM节点的ref对象赋值给ref</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无法获取自定义组件的ref"><a href="#无法获取自定义组件的ref" class="headerlink" title="无法获取自定义组件的ref"></a>无法获取自定义组件的ref</h3><p>默认情况下，自定义组件不会暴露他们内部DOM节点的ref</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useRef &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComp</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [x, setX] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;x&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> myRef = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(myRef.<span class="property">current</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">MyComp</span> <span class="attr">ref</span>=<span class="string">&#123;myRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>获取ref<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>控制台警告，无法获取到ref</p>
<img src="/2024/03/24/useRef/image.png" class title="This is an image">

<p>为了解决这个问题，可以使用<code>forwardRef</code>包裹子组件，这样父组件就能得到它的ref</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useState, useRef, forwardRef &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyComp</span> = <span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;  <span class="comment">//forwardRef包裹组件，函数的第二个参数就是ref对象</span></span><br><span class="line">  <span class="keyword">const</span> [x, setX] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span>&gt;</span>&#123;x&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> myRef = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(myRef.<span class="property">current</span>); <span class="comment">//可以获取到子组件的ref</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">MyComp</span> <span class="attr">ref</span>=<span class="string">&#123;myRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>获取ref<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/React-Hooks/">React Hooks</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/03/24/useState/"><span>useState</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/03/24/useState/" rel="bookmark">
        <time class="entry-date published" datetime="2024-03-24T03:29:45.000Z">
          2024-03-24
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><strong>作为一个React Hook</strong>，它只能在组件的顶层调用</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><strong><code>useState(initialState)</code></strong></p>
<ul>
<li><code>initialState</code>：state的初始值。当传递函数作为initialState时，它将被视为<strong>初始化函数</strong>，它应该是一个<strong>纯函数</strong>，不应该传入任何参数，并且应该返回一个值来作为初始值。<strong>此参数只有在初始化渲染时使用，在之后将被忽略</strong></li>
</ul>
<p><code>useState</code>返回一个数组：状态变量 和 状态设置（set）函数</p>
<p>按照惯例，使用解构赋值的方法来命名状态和状态设置函数，例如<code>const [x, setX] = useState(0)</code></p>
<p><strong><code>set</code>函数</strong></p>
<p>通过调用<code>set</code>函数来更新状态变量的值，你可以：</p>
<ul>
<li>传入一个不同的新值，例如: <code>setName(&#39;cqy&#39;)</code></li>
<li>基于待定的<code>state</code>来计算新的状态（<strong>更新函数</strong>），例如: <code>setAge(a =&gt; a + 1)</code></li>
</ul>
<blockquote>
<p>当将函数作为参数传递给<code>set</code>函数时，它被视为<strong>更新函数</strong>。它必须是纯函数，唯一的参数是待定的<code>state</code>，并应该返回下一个状态</p>
</blockquote>
<p><strong>注意事项</strong></p>
<p><code>set</code>函数<strong>仅更新 下一次 渲染的状态变量</strong>，如果在调用<code>set</code>函数后立刻读取状态便了，<strong>得到的仍然是渲染在屏幕上的旧值</strong>。</p>
<p><strong>待定的<code>state</code></strong></p>
<p>下面的例子中，我们希望在点击之后将count增加3，但结果是count只会增加1。<br>原因就在于，前一个<code>set</code>函数执行完后，后一个<code>set</code>函数读取的仍然是旧的状态，React会批量处理状态更新，在所有事件处理函数运行并调用其<code>set</code>函数后更新屏幕。所以<strong>在页面重新渲染前</strong>，获取到的仍然是<strong>旧值</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      You pressed me &#123;count&#125; times</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，可以给<code>set</code>函数传递一个<strong>更新函数</strong>，它可以根据**最新的<code>state</code>**（即待定的<code>state</code>，可以理解为若没有后续改变state的操作，该state将会在下一次渲染时被使用）状态来计算更新下一个<code>state</code>状态</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">setCount</span>(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>); <span class="comment">// setCount(0 =&gt; 1)</span></span><br><span class="line">  <span class="title function_">setCount</span>(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>); <span class="comment">// setCount(1 =&gt; 2)</span></span><br><span class="line">  <span class="title function_">setCount</span>(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>); <span class="comment">// setCount(2 =&gt; 3)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// c =&gt; c + 1 是更新函数，它获取 待定状态 并根据此计算下一个状态</span></span><br></pre></td></tr></table></figure>

<h2 id="更新状态中的对象和数组"><a href="#更新状态中的对象和数组" class="headerlink" title="更新状态中的对象和数组"></a>更新状态中的对象和数组</h2><p>当把对象和数组作为状态变量时，你应该替换它而不应该单纯的改变对象中的某个属性或者数组中的某项</p>
<p>示例代码：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [obj, setObj] = <span class="title function_">useState</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;easycodesniper&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">22</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;xxx&#x27;</span>  <span class="comment">//❌ 错误的修改方法</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">setObj</span>(&#123; <span class="comment">// 正确的修改方法</span></span><br><span class="line">  ...obj,  </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="避免重复创建初始状态"><a href="#避免重复创建初始状态" class="headerlink" title="避免重复创建初始状态"></a>避免重复创建初始状态</h2><p>React只在初次渲染时保存初始状态，后续渲染都会忽略</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [ x, setX ] = <span class="title function_">useState</span>(<span class="title function_">createInitialX</span>()) <span class="comment">//不好的实践</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管<code>createInitialX()</code>的结果仅用于初次渲染，但是每次重新渲染时都要调用此函数，如果它的执行需要昂贵的计算，会导致资源浪费<br>为了解决这个问题，你应该把函数本身作为初始化函数传递给<code>useState</code>，而不是调用该函数</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [ x, setX ] = <span class="title function_">useState</span>(createInitialX) <span class="comment">//合理的实践</span></span><br></pre></td></tr></table></figure>

<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/React-Hooks/">React Hooks</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2024 chen qiyi
    
  </p>
</footer>
    
    
  </div>
</div>
<script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>